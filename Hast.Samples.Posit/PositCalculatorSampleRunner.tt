<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="PositCalculatorTemplateFileManager.ttinclude" #>


<#

var manager = TemplateFileManager.Create(this);

#>

<#
	var positSizes = new byte[] {8,16,32,64};
	var underLyingStructureName= new string[] {"byte", "ushort","uint","ulong","BitMask"};	

for (var i = 0; i<3; i++){
	for(var MaximumExponentSize = 0; MaximumExponentSize <=4; MaximumExponentSize++){
		var positName = "Posit"+positSizes[i] + "_" + MaximumExponentSize;
		var calculatorName = positName + "_Calculator";
		var className = calculatorName + "SampleRunner";
		var quireSize = 1;
		while (quireSize < (4*positSizes[i]-8)*(1<<MaximumExponentSize)+31)
		{
			 quireSize <<= 1;
		}
		var maxValue = Math.Pow((1 << (1 << MaximumExponentSize)),positSizes[i]-2);
		// This is the biggest representable integer such that all smaller positive integers can also be exactly represented
		// by the given environment.
		long pIntMax = 0;
		double maxScaleFactor;
		for ( int n = positSizes[i]-2-MaximumExponentSize; n>=0 ;n--)
		{
			maxScaleFactor = Math.Pow((1 << (1 << MaximumExponentSize)), positSizes[i]-2-MaximumExponentSize-n) + (1<<MaximumExponentSize)-1;
			pIntMax =(long)1 << n;
			if (maxScaleFactor >= pIntMax) break;            
		}
		manager.StartNewFile(className + ".cs");
#>
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Hast.Layer;
using Hast.Samples.SampleAssembly;
using Lombiq.Arithmetics;

namespace Hast.Samples.Posit
{
	internal class <#=className#>
	{
		public static void Configure(HardwareGenerationConfiguration configuration)
		{
			configuration.AddHardwareEntryPointType<<#=calculatorName#>>();
		}

		public static async Task Run(IHastlayer hastlayer, IHardwareRepresentation hardwareRepresentation)
		{
			RunSoftwareBenchmarks();

			var positCalculator = await hastlayer.GenerateProxy(hardwareRepresentation, new <#=calculatorName#>());


			var integerSumUpToNumber = positCalculator.CalculateIntegerSumUpToNumber(100000);


            <# if (i == 0)
               {
			#>
			positCalculator.CalculatePowerOfReal( 5, (float)0.5);
		 
            <#  } else { #>
			positCalculator.CalculatePowerOfReal( <#=(int) Math.Pow(10,Math.Log(positSizes[i], 2)) #>, (float)1.015625);
			<#  } #>


			var numbers = new int[<#=calculatorName#>.MaxDegreeOfParallelism];
			for (int i = 0; i < <#=calculatorName#>.MaxDegreeOfParallelism; i++)
			{
				numbers[i] = 100000 + (i % 2 == 0 ? -1 : 1);
			}

			var integerSumsUpToNumbers = positCalculator.ParallelizedCalculateIntegerSumUpToNumbers(numbers);


			var <#=positName#>Array = new uint[100000];

			for (var i = 0; i < 100000; i++)
			{
				if (i % 2 == 0) <#=positName#>Array[i] = new <#=positName#>((float)0.25 * 2 * i).PositBits;
				else <#=positName#>Array[i] = new <#=positName#>((float)0.25 * -2 * i).PositBits;
			}

			var positsInArraySum = positCalculator.AddPositsInArray(<#=positName#>Array);
		}

		public static void RunSoftwareBenchmarks()
		{
			var positCalculator = new <#=calculatorName#>();


			// Not to run the benchmark below the first time, because JIT compiling can affect it.
			positCalculator.CalculateIntegerSumUpToNumber(100000);
			var sw = Stopwatch.StartNew();
			var integerSumUpToNumber = positCalculator.CalculateIntegerSumUpToNumber(100000);
			sw.Stop();

			Console.WriteLine("Result of counting up to 100000: " + integerSumUpToNumber);
			Console.WriteLine("Elapsed: " + sw.ElapsedMilliseconds + "ms");

			Console.WriteLine();

			positCalculator.CalculatePowerOfReal(100000, (float)1.0001);
			sw = Stopwatch.StartNew();
			
            <# if (i == 0)
               {
			#>

			var powerOfReal = positCalculator.CalculatePowerOfReal( 5, (float)0.5);
            <#  } else { #>
			 var powerOfReal = positCalculator.CalculatePowerOfReal( <#=(int) Math.Pow(10,Math.Log(positSizes[i], 2)) #>, (float)1.015625);
			<#  } #>

			sw.Stop();

			Console.WriteLine("Result of power of real number: " + powerOfReal);
			Console.WriteLine("Elapsed: " + sw.ElapsedMilliseconds + "ms");

			Console.WriteLine();

			var numbers = new int[<#=calculatorName#>.MaxDegreeOfParallelism];
			for (int i = 0; i < <#=calculatorName#>.MaxDegreeOfParallelism; i++)
			{
				numbers[i] = 100000 + (i % 2 == 0 ? -1 : 1);
			}

			positCalculator.ParallelizedCalculateIntegerSumUpToNumbers(numbers);
			sw = Stopwatch.StartNew();
			var integerSumsUpToNumbers = positCalculator.ParallelizedCalculateIntegerSumUpToNumbers(numbers);
			sw.Stop();

			Console.WriteLine("Result of counting up to ~100000 parallelized: " + string.Join(", ", integerSumsUpToNumbers));
			Console.WriteLine("Elapsed: " + sw.ElapsedMilliseconds + "ms");

			Console.WriteLine();

			var <#=positName#>Array = new uint[100000];

			for (var i = 0; i < 100000; i++)
			{
				if (i % 2 == 0)  <#=positName#>Array[i] = new  <#=positName#>((float)0.25 * 2 * i).PositBits;
				else  <#=positName#>Array[i] = new  <#=positName#>((float)0.25 * -2 * i).PositBits;
			}

			positCalculator.AddPositsInArray( <#=positName#>Array);
			sw = Stopwatch.StartNew();
			var positsInArraySum = positCalculator.AddPositsInArray( <#=positName#>Array);
			sw.Stop();

			Console.WriteLine("Result of addition of posits in array: " + positsInArraySum);
			Console.WriteLine("Elapsed: " + sw.ElapsedMilliseconds + "ms");

			Console.WriteLine();
		}
	}
}

<#
	}
}#>
<#

manager.Process();

#>