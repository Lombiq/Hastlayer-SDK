using Hast.Common.Models;
using Shouldly;
using Shouldly.Configuration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Hast.Transformer.Vhdl.Tests.VerificationTests;

public static class ShouldMatchApprovedExtensions
{
    /// <summary>
    /// Match the input VHDL hardware description's source, including the XDC constraints if available, against an
    /// existing approved source file. This quickly tells if something changed.
    /// </summary>
    /// <remarks>
    /// <para>Also see: <c>http://shouldly.readthedocs.io/en/latest/assertions/shouldMatchApproved.html</c>.</para>
    /// </remarks>
    public static void ShouldMatchApprovedWithVhdlConfiguration(
        this VhdlHardwareDescription hardwareDescription,
        string deviceName = null) =>
        (hardwareDescription.VhdlSource + hardwareDescription.XdcSource)
            .ShouldMatchApproved(configurationBuilder =>
            {
                var configuration = configurationBuilder.WithVhdlConfiguration().UseCallerLocation();
                if (!string.IsNullOrEmpty(deviceName)) configuration.WithDiscriminator(deviceName);
            });

    /// <summary>
    /// Match the input VHDL hardware descriptions' sources, including the XDC constraints if available, against an
    /// existing approved source file. This quickly tells if something changed.
    /// </summary>
    /// <remarks>
    /// <para>Also see: <c>http://shouldly.readthedocs.io/en/latest/assertions/shouldMatchApproved.html</c>.</para>
    /// </remarks>
    public static void ShouldMatchApprovedWithVhdlConfiguration(
        this IEnumerable<VhdlHardwareDescription> hardwareDescriptions,
        string deviceName = null) =>
        string.Join(
            string.Empty,
            hardwareDescriptions.Select(hardwareDescription => hardwareDescription.VhdlSource + hardwareDescription.XdcSource))
            .ShouldMatchApproved(configurationBuilder =>
            {
                var configuration = configurationBuilder.WithVhdlConfiguration().UseCallerLocation();
                if (!string.IsNullOrEmpty(deviceName)) configuration.WithDiscriminator(deviceName);
            });

    /// <summary>
    /// Match the input VHDL source against an existing approved source file. This quickly tells if something changed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Note that the two methods here can't be DRY because even with UseCallerLocation() Shouldly would loose track of
    /// where the verification file is.
    /// </para>
    /// </remarks>
    public static void ShouldMatchApprovedWithVhdlConfiguration(this string vhdlSource) =>
        vhdlSource
            .Replace("\r\n", "\n")
            .ShouldMatchApproved(configurationBuilder =>
                configurationBuilder.WithVhdlConfiguration().UseCallerLocation());
}

public static class ShouldMatchConfigurationBuilderExtensions
{
    private static readonly IEnumerable<Func<string, string>> _scrubbers = new[]
    {
        RemoveDateComments,
        RemoveHastIpId,
        ReplaceHashIdentifiers,
    };

    public static ShouldMatchConfigurationBuilder WithVhdlConfiguration(this ShouldMatchConfigurationBuilder configurationBuilder)
    {
        var builder = configurationBuilder
            .SubFolder(Path.Combine("VerificationSources"))
            .WithFileExtension("vhdl")
            .WithScrubber(source => _scrubbers.Aggregate(source, (updatedSource, scrubber) => scrubber(updatedSource)));

        // This is what the builder sets with no explicit WithFilenameGenerator. We decorate it using the
        // WithFilenameGenerator call below.
        var defaultFileNameGenerator = builder.Build().FilenameGenerator;

        // Alter the FileNameGenerator to strip out invalid path characters. Prevents weird file names like this:
        // StaticTestInputAssembliesVerificationTests.<ClassStructureAssembliesMatchApproved.received.vhdl
        builder = builder.WithFilenameGenerator((testMethodInfo, discriminator, type, extension) =>
            defaultFileNameGenerator(testMethodInfo, discriminator, type, extension)
                .MakeFileSystemFriendly(noSpaceOrDot: false)
                .Replace("_", string.Empty));

        return builder;
    }

    private static string RemoveDateComments(string source)
    {
        source = source.RegexReplace(
            @"-- Generated by Hastlayer \(hastlayer.com\) at ([0-9\-\s\:]*UTC)",
            "-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing>");
        source = source.RegexReplace(@"-- Date and time:([0-9\-\s\:]*UTC)", "-- (Date and time removed for approval testing.)");

        return source;
    }

    private static string RemoveHastIpId(string source) =>
        source.RegexReplace(@"-- Hast_IP ID: ([0-9a-z]*)", "-- (Hast_IP ID removed for approval testing.)");

    private static string ReplaceHashIdentifiers(string source)
    {
        // Matches words like "remainderOperand03b0c44298fc1c149426f4c8996fb92427ae41e4649b934ca495991b7852b855".
        const string hashIdentifierPattern = @"([\p{L}\p{N}]+)([0-9a-f]{64})\b";

        // The hashes are replaced by a simple integer, which is incremented in the order of appearance. This way it's
        // enough if their relative order stays the same, the exact hash contributor information (e.g. the line numbers
        // of the relevant ranges) can change. This makes the verification test less fragile.
        var counter = 0;

        while (source.RegexMatch(hashIdentifierPattern) is { Success: true } match)
        {
            var type = match.Groups[1].Value;
            var hash = match.Groups[2].Value;

            source = source.Replace(type + hash, type + counter.ToTechnicalString());
            counter++;
        }

        return source;
    }
}
