-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com

    -- Hast_IP's simple interface makes it suitable to plug it into any hardware implementation. The meaning and usage of the
    -- ports are as below:
    -- * MemberId: Each transformed .NET hardware entry point member (i.e. methods that are configured to be available to be
    --             called from the host PC) has a unique zero-based numeric ID. When selecting which one to execute this ID
    --             should be used.
    -- * Started: Indicates whether the execution of a given hardware entry point member is started. Used in the following way:
    --     1. Started is set to TRUE by the consuming framework, after which the execution of the given member starts
    --        internally. The Finished port will be initially set to FALSE.
    --     2. Once the execution is finished, the Finished port will be set to TRUE.
    --     3. The consuming framework sets Started to FALSE, after which Finished will also be set to FALSE.
    -- * Finished: Indicates whether the execution of a given hardware entry point member is complete. See the documentation of
    --             the Started port above on how it is used.
    -- * Reset: Synchronous reset.
    -- * Clock: The main clock.
    -- * DataIn: Data read out from the memory (usually on-board DDR RAM, but depends on the framework) should be assigned to
    --           this port by the framework. The width of this port is always 32b, independent of the hardware platform (if the
    --           bus to the memory is wider then caching needs to be implemented in the framework to make use of it). Inputs of
    --           the algorithm implemented in Hast_IP all come through this port.
    -- * DataOut: Data to be written to the memory is assigned to this port. The width of this port is always 32b, independent
    --            of the hardware platform (if the bus to the memory is wider then caching needs to be implemented in the
    --            framework to make use of it). Outputs of the algorithm implemented in Hast_IP all go through this port.
    -- * CellIndex: Zero-based index of the SimpleMemory memory cell currently being read or written. Transformed code in
    --              Hastlayer can access memory in a simplified fashion by addressing 32b "cells", the accessible physical
    --              memory space being divided up in such individually addressable cells.
    -- * ReadEnable: Indicates whether a memory read operation is initiated. The process of a memory read is as following:
    --     1. ReadEnable is FALSE by default. It's set to TRUE when a memory read is started. CellIndex is set to the index of
    --        the memory cell to be read out.
    --     2. Waiting for ReadsDone to be TRUE.
    --     3. Once ReadsDone is TRUE, data from DataIn will be read out and ReadEnable set to FALSE.
    -- * WriteEnable: Indicates whether a memory write operation is initiated. The process of a memory write is as following:
    --     1. WriteEnable is FALSE by default. It's set to TRUE when a memory write is started. CellIndex is set to the index
    --        of the memory cell to be written and the output data is assigned to DataOut.
    --     2. Waiting for WritesDone to be TRUE.
    --     3. Once WritesDone is TRUE, WriteEnable is set to FALSE.
    -- * ReadsDone: Indicates whether a memory read operation is completed.
    -- * WritesDone: Indicates whether a memory write operation is completed.

end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions, properties) in .NET a state machine was generated. Each state machine's name
    --   corresponds to the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic
    --   operations (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states
    --   can take more than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- When put on variables and signals this attribute instructs Vivado not to merge them, thus allowing us to define multi-cycle paths properly.
    attribute dont_touch: string;


    -- Custom inter-dependent type declarations start
    type \Lombiq.Arithmetics.Posit32\ is record 
        \IsNull\: boolean;
        \PositBits\: unsigned(31 downto 0);
    end record;
    type \Lombiq.Arithmetics.Posit32_Array\ is array (integer range <>) of \Lombiq.Arithmetics.Posit32\;
    type \unsigned64_Array\ is array (integer range <>) of unsigned(63 downto 0);
    type \Lombiq.Arithmetics.Quire\ is record 
        \IsNull\: boolean;
        \Size\: unsigned(15 downto 0);
        \SegmentCount\: unsigned(15 downto 0);
        \Segments\: \unsigned64_Array\(0 to 7);
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._States\ is (
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\);
    -- Signals:
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32,Boolean).0._States\ is (
        \Posit32::.ctor(UInt32,Boolean).0._State_0\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_1\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32,Boolean).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(Quire).0._States\ is (
        \Posit32::.ctor(Quire).0._State_0\, 
        \Posit32::.ctor(Quire).0._State_1\, 
        \Posit32::.ctor(Quire).0._State_2\, 
        \Posit32::.ctor(Quire).0._State_3\, 
        \Posit32::.ctor(Quire).0._State_4\, 
        \Posit32::.ctor(Quire).0._State_5\, 
        \Posit32::.ctor(Quire).0._State_6\, 
        \Posit32::.ctor(Quire).0._State_7\, 
        \Posit32::.ctor(Quire).0._State_8\, 
        \Posit32::.ctor(Quire).0._State_9\, 
        \Posit32::.ctor(Quire).0._State_10\, 
        \Posit32::.ctor(Quire).0._State_11\, 
        \Posit32::.ctor(Quire).0._State_12\, 
        \Posit32::.ctor(Quire).0._State_13\, 
        \Posit32::.ctor(Quire).0._State_14\, 
        \Posit32::.ctor(Quire).0._State_15\, 
        \Posit32::.ctor(Quire).0._State_16\, 
        \Posit32::.ctor(Quire).0._State_17\, 
        \Posit32::.ctor(Quire).0._State_18\, 
        \Posit32::.ctor(Quire).0._State_19\, 
        \Posit32::.ctor(Quire).0._State_20\, 
        \Posit32::.ctor(Quire).0._State_21\, 
        \Posit32::.ctor(Quire).0._State_22\, 
        \Posit32::.ctor(Quire).0._State_23\, 
        \Posit32::.ctor(Quire).0._State_24\);
    -- Signals:
    Signal \Posit32::.ctor(Quire).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Quire).0.q.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0._Started\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Quire).0.q.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\: unsigned(63 downto 0) := to_unsigned(0, 64);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32).0._States\ is (
        \Posit32::.ctor(UInt32).0._State_0\, 
        \Posit32::.ctor(UInt32).0._State_1\, 
        \Posit32::.ctor(UInt32).0._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(Int32).0._States\ is (
        \Posit32::.ctor(Int32).0._State_0\, 
        \Posit32::.ctor(Int32).0._State_1\, 
        \Posit32::.ctor(Int32).0._State_2\, 
        \Posit32::.ctor(Int32).0._State_3\);
    -- Signals:
    Signal \Posit32::.ctor(Int32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 declarations start
    -- State machine states:
    type \Posit32::IsNaN().0._States\ is (
        \Posit32::IsNaN().0._State_0\, 
        \Posit32::IsNaN().0._State_1\, 
        \Posit32::IsNaN().0._State_2\);
    -- Signals:
    Signal \Posit32::IsNaN().0._Finished\: boolean := false;
    Signal \Posit32::IsNaN().0.return\: boolean := false;
    Signal \Posit32::IsNaN().0._Started\: boolean := false;
    Signal \Posit32::IsNaN().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32::EncodeRegimeBits(Int32).0._States\ is (
        \Posit32::EncodeRegimeBits(Int32).0._State_0\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_1\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_2\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_3\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_4\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_5\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_6\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_7\);
    -- Signals:
    Signal \Posit32::EncodeRegimeBits(Int32).0._Finished\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0._Started\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ is (
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\);
    -- Signals:
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValue().0._States\ is (
        \Posit32::GetRegimeKValue().0._State_0\, 
        \Posit32::GetRegimeKValue().0._State_1\, 
        \Posit32::GetRegimeKValue().0._State_2\, 
        \Posit32::GetRegimeKValue().0._State_3\);
    -- Signals:
    Signal \Posit32::GetRegimeKValue().0._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 declarations end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 declarations start
    -- State machine states:
    type \Posit32::CalculateScaleFactor().0._States\ is (
        \Posit32::CalculateScaleFactor().0._State_0\, 
        \Posit32::CalculateScaleFactor().0._State_1\, 
        \Posit32::CalculateScaleFactor().0._State_2\, 
        \Posit32::CalculateScaleFactor().0._State_3\, 
        \Posit32::CalculateScaleFactor().0._State_4\, 
        \Posit32::CalculateScaleFactor().0._State_5\, 
        \Posit32::CalculateScaleFactor().0._State_6\, 
        \Posit32::CalculateScaleFactor().0._State_7\);
    -- Signals:
    Signal \Posit32::CalculateScaleFactor().0._Finished\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0.return\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0._Started\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 declarations start
    -- State machine states:
    type \Posit32::ExponentSize().0._States\ is (
        \Posit32::ExponentSize().0._State_0\, 
        \Posit32::ExponentSize().0._State_1\, 
        \Posit32::ExponentSize().0._State_2\, 
        \Posit32::ExponentSize().0._State_3\, 
        \Posit32::ExponentSize().0._State_4\, 
        \Posit32::ExponentSize().0._State_5\, 
        \Posit32::ExponentSize().0._State_6\, 
        \Posit32::ExponentSize().0._State_7\, 
        \Posit32::ExponentSize().0._State_8\, 
        \Posit32::ExponentSize().0._State_9\);
    -- Signals:
    Signal \Posit32::ExponentSize().0._Finished\: boolean := false;
    Signal \Posit32::ExponentSize().0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::ExponentSize().0._Started\: boolean := false;
    Signal \Posit32::ExponentSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 declarations start
    -- State machine states:
    type \Posit32::GetExponentValue().0._States\ is (
        \Posit32::GetExponentValue().0._State_0\, 
        \Posit32::GetExponentValue().0._State_1\, 
        \Posit32::GetExponentValue().0._State_2\, 
        \Posit32::GetExponentValue().0._State_3\, 
        \Posit32::GetExponentValue().0._State_4\, 
        \Posit32::GetExponentValue().0._State_5\, 
        \Posit32::GetExponentValue().0._State_6\, 
        \Posit32::GetExponentValue().0._State_7\, 
        \Posit32::GetExponentValue().0._State_8\, 
        \Posit32::GetExponentValue().0._State_9\);
    -- Signals:
    Signal \Posit32::GetExponentValue().0._Finished\: boolean := false;
    Signal \Posit32::GetExponentValue().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0._Started\: boolean := false;
    Signal \Posit32::GetExponentValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 declarations start
    -- State machine states:
    type \Posit32::FractionSize().0._States\ is (
        \Posit32::FractionSize().0._State_0\, 
        \Posit32::FractionSize().0._State_1\, 
        \Posit32::FractionSize().0._State_2\, 
        \Posit32::FractionSize().0._State_3\, 
        \Posit32::FractionSize().0._State_4\, 
        \Posit32::FractionSize().0._State_5\, 
        \Posit32::FractionSize().0._State_6\, 
        \Posit32::FractionSize().0._State_7\);
    -- Signals:
    Signal \Posit32::FractionSize().0._Finished\: boolean := false;
    Signal \Posit32::FractionSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().0._Started\: boolean := false;
    Signal \Posit32::FractionSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBit().0._States\ is (
        \Posit32::FractionWithHiddenBit().0._State_0\, 
        \Posit32::FractionWithHiddenBit().0._State_1\, 
        \Posit32::FractionWithHiddenBit().0._State_2\, 
        \Posit32::FractionWithHiddenBit().0._State_3\, 
        \Posit32::FractionWithHiddenBit().0._State_4\, 
        \Posit32::FractionWithHiddenBit().0._State_5\, 
        \Posit32::FractionWithHiddenBit().0._State_6\, 
        \Posit32::FractionWithHiddenBit().0._State_7\, 
        \Posit32::FractionWithHiddenBit().0._State_8\, 
        \Posit32::FractionWithHiddenBit().0._State_9\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBit().0._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt32).0._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Posit32::SetOne(UInt32,UInt16).0._States\ is (
        \Posit32::SetOne(UInt32,UInt16).0._State_0\, 
        \Posit32::SetOne(UInt32,UInt16).0._State_1\, 
        \Posit32::SetOne(UInt32,UInt16).0._State_2\);
    -- Signals:
    Signal \Posit32::SetOne(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Posit32::SetOne(UInt32,UInt16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetOne(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Posit32::SetZero(UInt32,UInt16).0._States\ is (
        \Posit32::SetZero(UInt32,UInt16).0._State_0\, 
        \Posit32::SetZero(UInt32,UInt16).0._State_1\, 
        \Posit32::SetZero(UInt32,UInt16).0._State_2\);
    -- Signals:
    Signal \Posit32::SetZero(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 declarations start
    -- State machine states:
    type \Posit32::LengthOfRunOfBits(UInt32,Byte).0._States\ is (
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\);
    -- Signals:
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::GetTwosComplement(UInt32).0._States\ is (
        \Posit32::GetTwosComplement(UInt32).0._State_0\, 
        \Posit32::GetTwosComplement(UInt32).0._State_1\, 
        \Posit32::GetTwosComplement(UInt32).0._State_2\);
    -- Signals:
    Signal \Posit32::GetTwosComplement(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetTwosComplement(UInt32).0._Started\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Posit32::FusedSum(Posit32[],Quire).0._States\ is (
        \Posit32::FusedSum(Posit32[],Quire).0._State_0\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_1\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_2\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_3\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_4\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_5\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_6\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_7\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_8\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_9\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_10\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_11\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_12\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_13\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_14\);
    -- Signals:
    Signal \Posit32::FusedSum(Posit32[],Quire).0._Finished\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0._Started\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().return.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Quire Posit32::op_Explicit(Posit32).0._States\ is (
        \Quire Posit32::op_Explicit(Posit32).0._State_0\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_1\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_2\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_3\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_4\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_5\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_6\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_7\);
    -- Signals:
    Signal \Quire Posit32::op_Explicit(Posit32).0._Finished\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0._Started\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().return.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 declarations start
    -- State machine states:
    type \Quire::.ctor(UInt64[],UInt16).0._States\ is (
        \Quire::.ctor(UInt64[],UInt16).0._State_0\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_1\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_2\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_3\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_4\);
    -- Signals:
    Signal \Quire::.ctor(UInt64[],UInt16).0._Finished\: boolean := false;
    Signal \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire::.ctor(UInt64[],UInt16).0._Started\: boolean := false;
    Signal \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Quire::.ctor(UInt32,UInt16).0._States\ is (
        \Quire::.ctor(UInt32,UInt16).0._State_0\, 
        \Quire::.ctor(UInt32,UInt16).0._State_1\, 
        \Quire::.ctor(UInt32,UInt16).0._State_2\, 
        \Quire::.ctor(UInt32,UInt16).0._State_3\, 
        \Quire::.ctor(UInt32,UInt16).0._State_4\, 
        \Quire::.ctor(UInt32,UInt16).0._State_5\, 
        \Quire::.ctor(UInt32,UInt16).0._State_6\, 
        \Quire::.ctor(UInt32,UInt16).0._State_7\, 
        \Quire::.ctor(UInt32,UInt16).0._State_8\);
    -- Signals:
    Signal \Quire::.ctor(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Quire Quire::op_Addition(Quire,Quire).0._States\ is (
        \Quire Quire::op_Addition(Quire,Quire).0._State_0\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_1\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_2\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_3\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_4\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_5\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_6\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_7\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_8\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_9\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_10\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_11\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_12\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_13\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_14\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_15\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_16\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_17\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_18\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_19\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_20\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_21\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_22\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_23\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_24\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_25\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_26\);
    -- Signals:
    Signal \Quire Quire::op_Addition(Quire,Quire).0._Finished\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0._Started\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_Addition(Quire,UInt32).0._States\ is (
        \Quire Quire::op_Addition(Quire,UInt32).0._State_0\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_1\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_2\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_3\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_4\);
    -- Signals:
    Signal \Quire Quire::op_Addition(Quire,UInt32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0._Started\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Quire Quire::op_OnesComplement(Quire).0._States\ is (
        \Quire Quire::op_OnesComplement(Quire).0._State_0\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_1\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_2\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_3\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_4\);
    -- Signals:
    Signal \Quire Quire::op_OnesComplement(Quire).0._Finished\: boolean := false;
    Signal \Quire Quire::op_OnesComplement(Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_OnesComplement(Quire).0._Started\: boolean := false;
    Signal \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Boolean Quire::op_Equality(Quire,Quire).0._States\ is (
        \Boolean Quire::op_Equality(Quire,Quire).0._State_0\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_1\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_2\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_3\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_4\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_5\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_6\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_7\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_8\);
    -- Signals:
    Signal \Boolean Quire::op_Equality(Quire,Quire).0._Finished\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.return\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0._Started\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_RightShift(Quire,Int32).0._States\ is (
        \Quire Quire::op_RightShift(Quire,Int32).0._State_0\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_1\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_2\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_3\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_4\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_5\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_6\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_7\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_8\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_9\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_10\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_11\);
    -- Signals:
    Signal \Quire Quire::op_RightShift(Quire,Int32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0._Started\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_LeftShift(Quire,Int32).0._States\ is (
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\);
    -- Signals:
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0._Started\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations end


    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \UInt64 Quire::op_Explicit(Quire).0._States\ is (
        \UInt64 Quire::op_Explicit(Quire).0._State_0\, 
        \UInt64 Quire::op_Explicit(Quire).0._State_1\, 
        \UInt64 Quire::op_Explicit(Quire).0._State_2\);
    -- Signals:
    Signal \UInt64 Quire::op_Explicit(Quire).0._Finished\: boolean := false;
    Signal \UInt64 Quire::op_Explicit(Quire).0.return\: unsigned(63 downto 0) := to_unsigned(0, 64);
    Signal \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \UInt64 Quire::op_Explicit(Quire).0._Started\: boolean := false;
    Signal \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \UInt32 Quire::op_Explicit(Quire).0._States\ is (
        \UInt32 Quire::op_Explicit(Quire).0._State_0\, 
        \UInt32 Quire::op_Explicit(Quire).0._State_1\, 
        \UInt32 Quire::op_Explicit(Quire).0._State_2\);
    -- Signals:
    Signal \UInt32 Quire::op_Explicit(Quire).0._Finished\: boolean := false;
    Signal \UInt32 Quire::op_Explicit(Quire).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \UInt32 Quire::op_Explicit(Quire).0._Started\: boolean := false;
    Signal \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._States\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\: \Lombiq.Arithmetics.Posit32\;
        attribute dont_touch of \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\: Variable is "true";
        attribute dont_touch of \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\ := (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 64);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 64);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\ := (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
            else 
                case \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ is 
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ = true) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ = true) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new Posit32[160];
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Quire quire;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32 objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98 = new Posit32 (0);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\.\IsNull\ := false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- quire = Posit32.op_Explicit (objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num / 160u;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\ => 
                        -- Waiting for the result to appear in \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ / to_unsigned(160, 32);
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\ => 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((long)(num - num / 160u * 160u) != 0L) {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\ => 
                        -- Waiting for the result to appear in \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(9, 32)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ / to_unsigned(160, 32);
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\ => 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ * to_unsigned(160, 32), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\ := signed(SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ - \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\, 64));
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\) /= to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.

                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\ => 
                        -- State after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num3) < (long)(num2)) {
                        -- 	int num4;
                        -- 	num4 = 0;
                        -- 	while (num4 < 160) {
                        -- 		Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                        -- 		if (((long)(num3 * 160 + num4) < (long)(num))) {
                        -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- 		} else {
                        -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- 		}
                        -- 		array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                        -- 		num4 = num4 + 1;
                        -- 	}
                        -- 	quire = Posit32.FusedSum (array, quire);
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\ => 
                        -- True branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (uint)((long)(num2) + 1L);
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\), 64)) + to_signed(1, 64)), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\);
                        -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\ => 
                        -- Repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.
                        -- The while loop's condition:
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\ := SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\), 64) < signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\), 64));
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num4;
                            -- 	num4 = 0;
                            -- 	while (num4 < 160) {
                            -- 		Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 		if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 		} else {
                            -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 		}
                            -- 		array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 		num4 = num4 + 1;
                            -- 	}
                            -- 	quire = Posit32.FusedSum (array, quire);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num4 < 160) {
                            -- 	Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 	if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 	} else {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 	}
                            -- 	array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\ => 
                        -- State after the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc = new Posit32 (quire);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\ => 
                        -- Repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\.
                        -- The while loop's condition:
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ < to_signed(160, 32);
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 	if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 	} else {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 	}
                            -- 	array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- } else {
                            -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- }
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ * to_signed(160, 32), 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\ => 
                        -- State after the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- quire = Posit32.FusedSum (array, quire);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\, 64);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\) < signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\), 64));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\.
                        --     * The false branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\.
                        --     * Execution after either branch will continue in the following state: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\.

                        if ((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.616
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\ => 
                        -- State after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\(to_integer(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\)) := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\);
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num4 + 1;
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ + to_signed(1, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\;
                        -- Returning to the repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\ if the loop wasn't exited with a state change.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\ => 
                        -- True branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ * to_signed(160, 32), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ := to_signed(1, 32) + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\;
                        -- Begin SimpleMemory read.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= ConvertStdLogicVectorToUInt32(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\ => 
                        -- False branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + 1;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ + to_signed(1, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\ if the loop wasn't exited with a state change.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 (0, objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc.PositBits);
                            -- 
                            -- Begin SimpleMemory write.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\PositBits\);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine start
    \Posit32::.ctor(UInt32,Boolean).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32,Boolean).0._State\: \Posit32::.ctor(UInt32,Boolean).0._States\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\: boolean := false;
        Variable \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                \Posit32::.ctor(UInt32,Boolean).0.bits\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := false;
                \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32,Boolean).0._State\ is 
                    when \Posit32::.ctor(UInt32,Boolean).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32,Boolean).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_2\ => 
                        \Posit32::.ctor(UInt32,Boolean).0.this\ := \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.bits\ := \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6 = bits;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\ := \Posit32::.ctor(UInt32,Boolean).0.bits\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = (conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6);
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.this\.\PositBits\ := (\Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\);
                        \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 state machine start
    \Posit32::.ctor(Quire).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Quire).0._State\: \Posit32::.ctor(Quire).0._States\ := \Posit32::.ctor(Quire).0._State_0\;
        Variable \Posit32::.ctor(Quire).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Quire).0.q\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.signBit\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.num2\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.1\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.return.2\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.3\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.4\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.return.6\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.7\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.8\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.9\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.9\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Quire).0._Finished\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_0\;
                \Posit32::.ctor(Quire).0.signBit\ := false;
                \Posit32::.ctor(Quire).0.num\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.num2\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.return.1\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.binaryOperationResult.0\ := false;
                \Posit32::.ctor(Quire).0.return.5\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.binaryOperationResult.1\ := false;
                \Posit32::.ctor(Quire).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.return.8\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.num3\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.4\ := false;
                \Posit32::.ctor(Quire).0.num4\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.num5\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.6\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.9\ := false;
                \Posit32::.ctor(Quire).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.11\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.return.10\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.return.11\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Quire).0._State\ is 
                    when \Posit32::.ctor(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Quire).0._Started\ = true) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Quire).0._Started\ = true) then 
                            \Posit32::.ctor(Quire).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Quire).0._Finished\ <= false;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Quire).0.this.parameter.Out\ <= \Posit32::.ctor(Quire).0.this\;
                        \Posit32::.ctor(Quire).0.q.parameter.Out\ <= \Posit32::.ctor(Quire).0.q\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_2\ => 
                        \Posit32::.ctor(Quire).0.this\ := \Posit32::.ctor(Quire).0.this.parameter.In\;
                        \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.q.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::.ctor(Quire).0.this\.\PositBits\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = false;
                        -- 
                        \Posit32::.ctor(Quire).0.signBit\ := false;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 511;
                        -- 
                        \Posit32::.ctor(Quire).0.num\ := to_signed(511, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- ulong num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.0\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.0\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.1\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.0\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (num2 >= 9223372036854775808uL) {
                            -- 	q = Quire.op_OnesComplement (q);
                            -- 	q = Quire.op_Addition (q, 1u);
                            -- 	signBit = true;
                            -- }
                            -- 
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Posit32::.ctor(Quire).0.binaryOperationResult.0\ := \Posit32::.ctor(Quire).0.num2\ >= "1000000000000000000000000000000000000000000000000000000000000000";

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_6\ and ends in state \Posit32::.ctor(Quire).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_5\.

                            if (\Posit32::.ctor(Quire).0.binaryOperationResult.0\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2999
                    when \Posit32::.ctor(Quire).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	q = Quire.op_OnesComplement (q);
                        -- 	q = Quire.op_Addition (q, 1u);
                        -- 	signBit = true;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- q = Quire.op_OnesComplement (q);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.2\ := \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- q = Quire.op_Addition (q, 1u);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.3\ := \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- signBit = true;
                            -- 
                            \Posit32::.ctor(Quire).0.signBit\ := true;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_4\.
                            if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_8\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.4\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.4\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.5\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.4\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2 < 9223372036854775808uL) {
                            -- 	q = Quire.op_LeftShift (q, 1);
                            -- 	num = num - 1;
                            -- 	num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_11\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\.
                        -- The while loop's condition:
                        -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                        \Posit32::.ctor(Quire).0.binaryOperationResult.1\ := \Posit32::.ctor(Quire).0.num2\ < "1000000000000000000000000000000000000000000000000000000000000000";
                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	q = Quire.op_LeftShift (q, 1);
                            -- 	num = num - 1;
                            -- 	num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- q = Quire.op_LeftShift (q, 1);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_13\;
                        else 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32::.ctor(Quire).0._State_12\ => 
                        -- State after the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num - 240;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.3\ := \Posit32::.ctor(Quire).0.num\ - to_signed(240, 32);
                        \Posit32::.ctor(Quire).0.num3\ := \Posit32::.ctor(Quire).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0) {
                        -- 	@this.PositBits = 0u;
                        -- 	return;
                        -- }
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.4\ := \Posit32::.ctor(Quire).0.num\ = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_17\ and ends in state \Posit32::.ctor(Quire).0._State_17\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_16\.

                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.4\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_17\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5903
                    when \Posit32::.ctor(Quire).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.6\ := \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num - 1;
                            -- 
                            \Posit32::.ctor(Quire).0.binaryOperationResult.2\ := \Posit32::.ctor(Quire).0.num\ - to_signed(1, 32);
                            \Posit32::.ctor(Quire).0.num\ := \Posit32::.ctor(Quire).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::.ctor(Quire).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.7\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.7\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.8\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.7\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.8\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\ if the loop wasn't exited with a state change.
                            if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_15\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_16\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num3 / 4;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.5\ := \Posit32::.ctor(Quire).0.num3\ / to_signed(4, 32);
                        \Posit32::.ctor(Quire).0.num4\ := \Posit32::.ctor(Quire).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (uint)(num3 - num3 / 4 * 4);
                        -- 
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0.7044
                    when \Posit32::.ctor(Quire).0._State_17\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	@this.PositBits = 0u;
                        -- 	return;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 0u;
                        -- 
                        \Posit32::.ctor(Quire).0.this\.\PositBits\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- return;
                        -- 
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_12\.
                        if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_17\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_18\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(Quire).0.binaryOperationResult.6\ := \Posit32::.ctor(Quire).0.num3\ / to_signed(4, 32);
                        \Posit32::.ctor(Quire).0.binaryOperationResult.7\ := SmartResize(\Posit32::.ctor(Quire).0.binaryOperationResult.6\ * to_signed(4, 32), 32);
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.8265
                    when \Posit32::.ctor(Quire).0._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(Quire).0.binaryOperationResult.8\ := unsigned(\Posit32::.ctor(Quire).0.num3\ - \Posit32::.ctor(Quire).0.binaryOperationResult.7\);
                        \Posit32::.ctor(Quire).0.num5\ := (\Posit32::.ctor(Quire).0.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((long)(num5) < 0L) {
                        -- 	num4 = num4 - 1;
                        -- 	num5 = (uint)((long)(num5) + 4L);
                        -- }
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.9\ := signed(SmartResize((\Posit32::.ctor(Quire).0.num5\), 64)) < to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_21\ and ends in state \Posit32::.ctor(Quire).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_20\.

                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.9\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_21\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.616
                    when \Posit32::.ctor(Quire).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = Posit32.AssemblePositBitsWithRounding (signBit, num4, num5, Quire.op_Explicit (Quire.op_RightShift (q, 480)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(480, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num4 = num4 - 1;
                        -- 	num5 = (uint)((long)(num5) + 4L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num4 - 1;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.10\ := \Posit32::.ctor(Quire).0.num4\ - to_signed(1, 32);
                        \Posit32::.ctor(Quire).0.num4\ := \Posit32::.ctor(Quire).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (uint)((long)(num5) + 4L);
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(Quire).0.num5\), 64)) + to_signed(4, 64)), 32);
                        \Posit32::.ctor(Quire).0.num5\ := (\Posit32::.ctor(Quire).0.binaryOperationResult.11\);
                        -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_19\.
                        if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_21\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7161
                    when \Posit32::.ctor(Quire).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.9\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.9\;
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.10\ := \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.9\ := \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.signBit\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.num4\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.num5\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.10\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.11\ := \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            \Posit32::.ctor(Quire).0.this\.\PositBits\ := \Posit32::.ctor(Quire).0.return.11\;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine start
    \Posit32::.ctor(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32).0._State\: \Posit32::.ctor(UInt32).0._States\ := \Posit32::.ctor(UInt32).0._State_0\;
        Variable \Posit32::.ctor(UInt32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32).0._Finished\ <= false;
                \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                \Posit32::.ctor(UInt32).0.value\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32).0._State\ is 
                    when \Posit32::.ctor(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_2\ => 
                        \Posit32::.ctor(UInt32).0.this\ := \Posit32::.ctor(UInt32).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32).0.value\ := \Posit32::.ctor(UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 0u;
                        -- 
                        \Posit32::.ctor(UInt32).0.this\.\PositBits\ := to_unsigned(0, 32);
                        \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine start
    \Posit32::.ctor(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Int32).0._State\: \Posit32::.ctor(Int32).0._States\ := \Posit32::.ctor(Int32).0._State_0\;
        Variable \Posit32::.ctor(Int32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).0.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\: \Lombiq.Arithmetics.Posit32\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Int32).0._Finished\ <= false;
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                \Posit32::.ctor(Int32).0.value\ := to_signed(0, 32);
                \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Int32).0._State\ is 
                    when \Posit32::.ctor(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Int32).0._Finished\ <= false;
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Int32).0.this.parameter.Out\ <= \Posit32::.ctor(Int32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_2\ => 
                        \Posit32::.ctor(Int32).0.this\ := \Posit32::.ctor(Int32).0.this.parameter.In\;
                        \Posit32::.ctor(Int32).0.value\ := \Posit32::.ctor(Int32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2 = new Posit32 (0u);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\;
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\ := \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48 = 0u;
                            -- 
                            \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = 0u;
                            -- 
                            \Posit32::.ctor(Int32).0.this\.\PositBits\ := to_unsigned(0, 32);
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 state machine start
    \Posit32::IsNaN().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsNaN().0._State\: \Posit32::IsNaN().0._States\ := \Posit32::IsNaN().0._State_0\;
        Variable \Posit32::IsNaN().0.this\: \Lombiq.Arithmetics.Posit32\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsNaN().0._Finished\ <= false;
                \Posit32::IsNaN().0.return\ <= false;
                \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_0\;
            else 
                case \Posit32::IsNaN().0._State\ is 
                    when \Posit32::IsNaN().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsNaN().0._Started\ = true) then 
                            \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsNaN().0._Started\ = true) then 
                            \Posit32::IsNaN().0._Finished\ <= true;
                        else 
                            \Posit32::IsNaN().0._Finished\ <= false;
                            \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().0._State_2\ => 
                        \Posit32::IsNaN().0.this\ := \Posit32::IsNaN().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Posit32::IsNaN().0.return\ <= false;
                        \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 state machine start
    \Posit32::EncodeRegimeBits(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::EncodeRegimeBits(Int32).0._State\: \Posit32::EncodeRegimeBits(Int32).0._States\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
        Variable \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= false;
                \Posit32::EncodeRegimeBits(Int32).0.return\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
                \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := false;
                \Posit32::EncodeRegimeBits(Int32).0.num\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.return.0\ := to_unsigned(0, 8);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.unaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
            else 
                case \Posit32::EncodeRegimeBits(Int32).0._State\ is 
                    when \Posit32::EncodeRegimeBits(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= true;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).0._State_2\ => 
                        \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (regimeKValue > 0) {
                        -- 	uint num;
                        -- 	num = (uint)((1 << regimeKValue + 1) - 1);
                        -- 	return num << 32 - (int)(Posit32.GetMostSignificantOnePosition (num)) - 1;
                        -- }
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::EncodeRegimeBits(Int32).0._State_4\ and ends in state \Posit32::EncodeRegimeBits(Int32).0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::EncodeRegimeBits(Int32).0._State_3\.

                        if (\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::EncodeRegimeBits(Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return 1073741824u >> -regimeKValue;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.unaryOperationResult.0\ := -\Posit32::EncodeRegimeBits(Int32).0.regimeKValue\;
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\ := shift_right(to_unsigned(1073741824, 32), to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).0.unaryOperationResult.0\, 5) and "11111")));
                        \Posit32::EncodeRegimeBits(Int32).0.return\ <= \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\;
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::EncodeRegimeBits(Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint num;
                        -- 	num = (uint)((1 << regimeKValue + 1) - 1);
                        -- 	return num << 32 - (int)(Posit32.GetMostSignificantOnePosition (num)) - 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (uint)((1 << regimeKValue + 1) - 1);
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ + to_signed(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\, 5))));
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::EncodeRegimeBits(Int32).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := unsigned((\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\) - to_signed(1, 32));
                        \Posit32::EncodeRegimeBits(Int32).0.num\ := (\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\);
                        -- The following section was transformed from the .NET statement below:
                        -- return num << 32 - (int)(Posit32.GetMostSignificantOnePosition (num)) - 1;
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::EncodeRegimeBits(Int32).0.num\;
                        \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::EncodeRegimeBits(Int32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).0.return.0\ := \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\ := to_signed(32, 32) - signed(SmartResize((\Posit32::EncodeRegimeBits(Int32).0.return.0\), 32));
                            \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\ - to_signed(1, 32);
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \Posit32::EncodeRegimeBits(Int32).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\ := shift_left(\Posit32::EncodeRegimeBits(Int32).0.num\, to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\, 5))));
                        \Posit32::EncodeRegimeBits(Int32).0.return\ <= \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\;
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        if (\Posit32::EncodeRegimeBits(Int32).0._State\ = \Posit32::EncodeRegimeBits(Int32).0._State_7\) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine start
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := to_signed(0, 64);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ is 
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\ => 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.EncodeRegimeBits (regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- byte b;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- b = Posit32.LengthOfRunOfBits (num, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= SmartResize(unsigned(to_signed(31, 32)), 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)(28 - (int)(b));
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := to_signed(28, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\), 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((num2 >= 0)) {
                            -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                            -- } else {
                            -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.

                            if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\)) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num2 < 0) {
                        -- 	uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 	if ((num2 > 28)) {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 	} else {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 	}
                        -- 	exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 	if (exponentBits < 2147483648u) {
                        -- 		uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 		if (signBit) {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- 		} else {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 		}
                        -- 		return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	}
                        -- 	uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 	if ((exponentBits != 2147483648u)) {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 	} else {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 	}
                        -- 	num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 	uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 	if (signBit) {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = Posit32.GetTwosComplement (num);
                        -- 	} else {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 	}
                        -- 	return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\ := -\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((int)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 	if ((num2 > 28)) {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 	} else {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 	}
                        -- 	exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 	if (exponentBits < 2147483648u) {
                        -- 		uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 		if (signBit) {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- 		} else {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 		}
                        -- 		return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	}
                        -- 	uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 	if ((exponentBits != 2147483648u)) {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 	} else {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 	}
                        -- 	num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 	uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 	if (signBit) {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = Posit32.GetTwosComplement (num);
                        -- 	} else {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 	}
                        -- 	return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num2 > 28)) {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- } else {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ > to_signed(28, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (exponentBits < 2147483648u) {
                        -- 	uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	if (signBit) {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- 	} else {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 	}
                        -- 	return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ < "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9774
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((exponentBits != 2147483648u)) {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- } else {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ /= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	if (signBit) {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- 	} else {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 	}
                        -- 	return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- } else {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = Posit32.GetTwosComplement (num);
                        -- } else {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) and to_signed(1, 64);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5632
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\), 32)) - to_signed(1, 32);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\), 16);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (int)((int)(28 - num3) - (int)(b));
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := to_signed(28, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\), 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((num4 >= 0)) {
                            -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                            -- } else {
                            -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.

                            if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\)) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num4 < 0) {
                        -- 	uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 	if ((32 + num4 < 0)) {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 	} else {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 	}
                        -- 	fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 	if (fractionBits >= 2147483648u) {
                        -- 		uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 		if ((fractionBits != 2147483648u)) {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 		} else {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 		}
                        -- 		num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 	}
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\ := -\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = Posit32.GetTwosComplement (num);
                        -- } else {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 	if ((32 + num4 < 0)) {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 	} else {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 	}
                        -- 	fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 	if (fractionBits >= 2147483648u) {
                        -- 		uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 		if ((fractionBits != 2147483648u)) {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 		} else {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 		}
                        -- 		num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((32 + num4 < 0)) {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- } else {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (fractionBits >= 2147483648u) {
                        -- 	uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 	if ((fractionBits != 2147483648u)) {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 	} else {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 	}
                        -- 	num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ >= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := to_signed(32, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\ := -(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\;
                        -- Clock cycles needed to complete this state (approximation): 0.6382
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6511
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 	if ((fractionBits != 2147483648u)) {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 	} else {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 	}
                        -- 	num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((fractionBits != 2147483648u)) {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- } else {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ /= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := unsigned(to_signed(1, 32));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) and to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 state machine start
    \Posit32::GetRegimeKValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValue().0._State\: \Posit32::GetRegimeKValue().0._States\ := \Posit32::GetRegimeKValue().0._State_0\;
        Variable \Posit32::GetRegimeKValue().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValue().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValue().0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValue().0._Finished\ <= false;
                \Posit32::GetRegimeKValue().0.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_0\;
                \Posit32::GetRegimeKValue().0.num\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.b\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.return.0\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737\ := to_signed(0, 8);
                \Posit32::GetRegimeKValue().0.unaryOperationResult.0\ := to_signed(0, 32);
            else 
                case \Posit32::GetRegimeKValue().0._State\ is 
                    when \Posit32::GetRegimeKValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValue().0._Started\ = true) then 
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValue().0._Started\ = true) then 
                            \Posit32::GetRegimeKValue().0._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValue().0._Finished\ <= false;
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_2\ => 
                        \Posit32::GetRegimeKValue().0.this\ := \Posit32::GetRegimeKValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716 = 0u;
                        -- 
                        \Posit32::GetRegimeKValue().0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0u;
                        -- 
                        \Posit32::GetRegimeKValue().0.num\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (0u, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= SmartResize(unsigned(to_signed(31, 32)), 8);
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().0.return.0\ := \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::GetRegimeKValue().0.b\ := \Posit32::GetRegimeKValue().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- sbyte conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737 = ((sbyte)(-(int)(b)));
                            -- 
                            \Posit32::GetRegimeKValue().0.unaryOperationResult.0\ := -signed(SmartResize((\Posit32::GetRegimeKValue().0.b\), 32));
                            \Posit32::GetRegimeKValue().0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737\ := (SmartResize((\Posit32::GetRegimeKValue().0.unaryOperationResult.0\), 8));
                            -- The following section was transformed from the .NET statement below:
                            -- return conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737;
                            -- 
                            \Posit32::GetRegimeKValue().0.return\ <= \Posit32::GetRegimeKValue().0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737\;
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3119
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 state machine end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 state machine start
    \Posit32::CalculateScaleFactor().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::CalculateScaleFactor().0._State\: \Posit32::CalculateScaleFactor().0._States\ := \Posit32::CalculateScaleFactor().0._State_0\;
        Variable \Posit32::CalculateScaleFactor().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::CalculateScaleFactor().0.regimeKValue\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::CalculateScaleFactor().0.return.0\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::CalculateScaleFactor().0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::CalculateScaleFactor().0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::CalculateScaleFactor().0.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::CalculateScaleFactor().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::CalculateScaleFactor().0.binaryOperationResult.2\: signed(15 downto 0) := to_signed(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::CalculateScaleFactor().0._Finished\ <= false;
                \Posit32::CalculateScaleFactor().0.return\ <= to_signed(0, 16);
                \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\ <= false;
                \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_0\;
                \Posit32::CalculateScaleFactor().0.regimeKValue\ := to_signed(0, 8);
                \Posit32::CalculateScaleFactor().0.return.0\ := to_signed(0, 8);
                \Posit32::CalculateScaleFactor().0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de\ := to_signed(0, 32);
                \Posit32::CalculateScaleFactor().0.binaryOperationResult.0\ := false;
                \Posit32::CalculateScaleFactor().0.binaryOperationResult.1\ := to_signed(0, 64);
                \Posit32::CalculateScaleFactor().0.return.1\ := to_unsigned(0, 32);
                \Posit32::CalculateScaleFactor().0.binaryOperationResult.2\ := to_signed(0, 16);
            else 
                case \Posit32::CalculateScaleFactor().0._State\ is 
                    when \Posit32::CalculateScaleFactor().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::CalculateScaleFactor().0._Started\ = true) then 
                            \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::CalculateScaleFactor().0._Started\ = true) then 
                            \Posit32::CalculateScaleFactor().0._Finished\ <= true;
                        else 
                            \Posit32::CalculateScaleFactor().0._Finished\ <= false;
                            \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor().0._State_2\ => 
                        \Posit32::CalculateScaleFactor().0.this\ := \Posit32::CalculateScaleFactor().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = Lombiq.Arithmetics.Posit32.GetRegimeKValue (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::CalculateScaleFactor().0.this\;
                        \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\ <= true;
                        \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::CalculateScaleFactor().0.return.0\ := \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().return.0\;
                            \Posit32::CalculateScaleFactor().0.regimeKValue\ := \Posit32::CalculateScaleFactor().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- int conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (((int)(regimeKValue) != -31)) {
                            -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = ((short)((long)((int)(regimeKValue) * 4) + (long)(Lombiq.Arithmetics.Posit32.GetExponentValue (@this))));
                            -- } else {
                            -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = 0;
                            -- }
                            -- 
                            \Posit32::CalculateScaleFactor().0.binaryOperationResult.0\ := SmartResize((\Posit32::CalculateScaleFactor().0.regimeKValue\), 32) /= to_signed(-31, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::CalculateScaleFactor().0._State_5\ and ends in state \Posit32::CalculateScaleFactor().0._State_6\.
                            --     * The false branch starts in state \Posit32::CalculateScaleFactor().0._State_7\ and ends in state \Posit32::CalculateScaleFactor().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::CalculateScaleFactor().0._State_4\.

                            if ((\Posit32::CalculateScaleFactor().0.binaryOperationResult.0\)) then 
                                \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_5\;
                            else 
                                \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::CalculateScaleFactor().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::CalculateScaleFactor().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (short)(conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de);
                        -- 
                        \Posit32::CalculateScaleFactor().0.return\ <= SmartResize((\Posit32::CalculateScaleFactor().0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de\), 16);
                        \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::CalculateScaleFactor().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = ((short)((long)((int)(regimeKValue) * 4) + (long)(Lombiq.Arithmetics.Posit32.GetExponentValue (@this))));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = ((short)((long)((int)(regimeKValue) * 4) + (long)(Lombiq.Arithmetics.Posit32.GetExponentValue (@this))));
                        -- 
                        \Posit32::CalculateScaleFactor().0.binaryOperationResult.1\ := SmartResize(SmartResize((\Posit32::CalculateScaleFactor().0.regimeKValue\), 32) * to_signed(4, 32), 64);
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::CalculateScaleFactor().0.this\;
                        \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\ <= true;
                        \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.1221
                    when \Posit32::CalculateScaleFactor().0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\ = \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::CalculateScaleFactor().0.return.1\ := \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().return.0\;
                            \Posit32::CalculateScaleFactor().0.binaryOperationResult.2\ := SmartResize((\Posit32::CalculateScaleFactor().0.binaryOperationResult.1\) + signed(SmartResize((\Posit32::CalculateScaleFactor().0.return.1\), 64)), 16);
                            \Posit32::CalculateScaleFactor().0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de\ := SmartResize(((\Posit32::CalculateScaleFactor().0.binaryOperationResult.2\)), 32);
                            -- Going to the state after the if-else which was started in state \Posit32::CalculateScaleFactor().0._State_3\.
                            if (\Posit32::CalculateScaleFactor().0._State\ = \Posit32::CalculateScaleFactor().0._State_6\) then 
                                \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32::CalculateScaleFactor().0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::CalculateScaleFactor().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de = 0;
                        -- 
                        \Posit32::CalculateScaleFactor().0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::CalculateScaleFactor().0._State_3\.
                        if (\Posit32::CalculateScaleFactor().0._State\ = \Posit32::CalculateScaleFactor().0._State_7\) then 
                            \Posit32::CalculateScaleFactor().0._State\ := \Posit32::CalculateScaleFactor().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 state machine start
    \Posit32::ExponentSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::ExponentSize().0._State\: \Posit32::ExponentSize().0._States\ := \Posit32::ExponentSize().0._State_0\;
        Variable \Posit32::ExponentSize().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::ExponentSize().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::ExponentSize().0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::ExponentSize().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.result\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.3\: boolean := false;
        Variable \Posit32::ExponentSize().0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::ExponentSize().0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.8\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::ExponentSize().0._Finished\ <= false;
                \Posit32::ExponentSize().0.return\ <= to_unsigned(0, 8);
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_0\;
                \Posit32::ExponentSize().0.bits\ := to_unsigned(0, 32);
                \Posit32::ExponentSize().0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3\ := to_unsigned(0, 32);
                \Posit32::ExponentSize().0.b\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.return.0\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.result\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.1\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.3\ := false;
                \Posit32::ExponentSize().0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.6\ := false;
                \Posit32::ExponentSize().0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.8\ := to_unsigned(0, 8);
            else 
                case \Posit32::ExponentSize().0._State\ is 
                    when \Posit32::ExponentSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::ExponentSize().0._Started\ = true) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::ExponentSize().0._Started\ = true) then 
                            \Posit32::ExponentSize().0._Finished\ <= true;
                        else 
                            \Posit32::ExponentSize().0._Finished\ <= false;
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_2\ => 
                        \Posit32::ExponentSize().0.this\ := \Posit32::ExponentSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3 = 0u;
                        -- 
                        \Posit32::ExponentSize().0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = 0u;
                        -- 
                        \Posit32::ExponentSize().0.bits\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (0u, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= SmartResize(unsigned(to_signed(31, 32)), 8);
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::ExponentSize().0.return.0\ := \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::ExponentSize().0.b\ := \Posit32::ExponentSize().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- byte result;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- result = (byte)(32 - (int)(b) - 1);
                            -- 
                            \Posit32::ExponentSize().0.binaryOperationResult.0\ := to_signed(32, 32) - signed(SmartResize((\Posit32::ExponentSize().0.b\), 32));
                            \Posit32::ExponentSize().0.binaryOperationResult.1\ := SmartResize(unsigned(\Posit32::ExponentSize().0.binaryOperationResult.0\ - to_signed(1, 32)), 8);
                            \Posit32::ExponentSize().0.result\ := (\Posit32::ExponentSize().0.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(b) + 2 <= 32) {
                            -- 	int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15;
                            -- 	if ((32 - ((int)(b) + 2) > 2)) {
                            -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = 2;
                            -- 	} else {
                            -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = ((byte)(32 - ((int)(b) + 2)));
                            -- 	}
                            -- 	result = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15);
                            -- }
                            -- 
                            \Posit32::ExponentSize().0.binaryOperationResult.2\ := signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32);
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Posit32::ExponentSize().0._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::ExponentSize().0.binaryOperationResult.3\ := \Posit32::ExponentSize().0.binaryOperationResult.2\ <= to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::ExponentSize().0._State_6\ and ends in state \Posit32::ExponentSize().0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::ExponentSize().0._State_5\.

                        if (\Posit32::ExponentSize().0.binaryOperationResult.3\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_6\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::ExponentSize().0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::ExponentSize().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::ExponentSize().0.return\ <= \Posit32::ExponentSize().0.result\;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::ExponentSize().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15;
                        -- 	if ((32 - ((int)(b) + 2) > 2)) {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = 2;
                        -- 	} else {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = ((byte)(32 - ((int)(b) + 2)));
                        -- 	}
                        -- 	result = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((32 - ((int)(b) + 2) > 2)) {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = 2;
                        -- } else {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = ((byte)(32 - ((int)(b) + 2)));
                        -- }
                        -- 
                        \Posit32::ExponentSize().0.binaryOperationResult.4\ := signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32);
                        \Posit32::ExponentSize().0.binaryOperationResult.5\ := to_signed(32, 32) - (\Posit32::ExponentSize().0.binaryOperationResult.4\);
                        \Posit32::ExponentSize().0.binaryOperationResult.6\ := \Posit32::ExponentSize().0.binaryOperationResult.5\ > to_signed(2, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::ExponentSize().0._State_8\ and ends in state \Posit32::ExponentSize().0._State_8\.
                        --     * The false branch starts in state \Posit32::ExponentSize().0._State_9\ and ends in state \Posit32::ExponentSize().0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::ExponentSize().0._State_7\.

                        if ((\Posit32::ExponentSize().0.binaryOperationResult.6\)) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_8\;
                        else 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \Posit32::ExponentSize().0._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::ExponentSize().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15);
                        -- 
                        \Posit32::ExponentSize().0.result\ := SmartResize(unsigned((\Posit32::ExponentSize().0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15\)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_4\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_7\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::ExponentSize().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = 2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = 2;
                        -- 
                        \Posit32::ExponentSize().0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15\ := to_signed(2, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_6\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_8\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_9\ => 
                        -- False branch of the if-else started in state \Posit32::ExponentSize().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = ((byte)(32 - ((int)(b) + 2)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15 = ((byte)(32 - ((int)(b) + 2)));
                        -- 
                        \Posit32::ExponentSize().0.binaryOperationResult.7\ := signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32);
                        \Posit32::ExponentSize().0.binaryOperationResult.8\ := SmartResize(unsigned(to_signed(32, 32) - (\Posit32::ExponentSize().0.binaryOperationResult.7\)), 8);
                        \Posit32::ExponentSize().0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15\ := signed(SmartResize(((\Posit32::ExponentSize().0.binaryOperationResult.8\)), 32));
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_6\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_9\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 state machine start
    \Posit32::GetExponentValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValue().0._State\: \Posit32::GetExponentValue().0._States\ := \Posit32::GetExponentValue().0._State_0\;
        Variable \Posit32::GetExponentValue().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValue().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.4\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValue().0._Finished\ <= false;
                \Posit32::GetExponentValue().0.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_0\;
                \Posit32::GetExponentValue().0.num\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.b\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().0.return.0\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().0.return.1\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.4\ := false;
            else 
                case \Posit32::GetExponentValue().0._State\ is 
                    when \Posit32::GetExponentValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValue().0._Started\ = true) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValue().0._Started\ = true) then 
                            \Posit32::GetExponentValue().0._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValue().0._Finished\ <= false;
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_2\ => 
                        \Posit32::GetExponentValue().0.this\ := \Posit32::GetExponentValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992 = 0u;
                        -- 
                        \Posit32::GetExponentValue().0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0u;
                        -- 
                        \Posit32::GetExponentValue().0.num\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = Lombiq.Arithmetics.Posit32.ExponentSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\;
                        \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.0\ := \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValue().0.b\ := \Posit32::GetExponentValue().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = 0u >> (int)Lombiq.Arithmetics.Posit32.FractionSize (@this) << 32 - (int)(b) >> 30;
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                            \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\;
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= true;
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ = \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.1\ := \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\;
                            \Posit32::GetExponentValue().0.binaryOperationResult.0\ := shift_right(to_unsigned(0, 32), to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValue().0.return.1\), 5) and "11111")));
                            \Posit32::GetExponentValue().0.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValue().0.b\), 32));
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9774
                    when \Posit32::GetExponentValue().0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::GetExponentValue().0.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValue().0.binaryOperationResult.0\, to_integer(unsigned(SmartResize(\Posit32::GetExponentValue().0.binaryOperationResult.1\, 5))));
                        \Posit32::GetExponentValue().0.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValue().0.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                        \Posit32::GetExponentValue().0.num\ := \Posit32::GetExponentValue().0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(b) != 0)) {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = num;
                        -- } else {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = 0u;
                        -- }
                        -- 
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.9522
                    when \Posit32::GetExponentValue().0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::GetExponentValue().0.binaryOperationResult.4\ := signed(SmartResize((\Posit32::GetExponentValue().0.b\), 32)) /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetExponentValue().0._State_8\ and ends in state \Posit32::GetExponentValue().0._State_8\.
                        --     * The false branch starts in state \Posit32::GetExponentValue().0._State_9\ and ends in state \Posit32::GetExponentValue().0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().0._State_7\.

                        if ((\Posit32::GetExponentValue().0.binaryOperationResult.4\)) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_8\;
                        else 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::GetExponentValue().0._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00;
                        -- 
                        \Posit32::GetExponentValue().0.return\ <= \Posit32::GetExponentValue().0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00\;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = num;
                        -- 
                        \Posit32::GetExponentValue().0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00\ := \Posit32::GetExponentValue().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_6\.
                        if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_8\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_9\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00 = 0u;
                        -- 
                        \Posit32::GetExponentValue().0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_6\.
                        if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_9\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 state machine start
    \Posit32::FractionSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSize().0._State\: \Posit32::FractionSize().0._States\ := \Posit32::FractionSize().0._State_0\;
        Variable \Posit32::FractionSize().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSize().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSize().0._Finished\ <= false;
                \Posit32::FractionSize().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_0\;
                \Posit32::FractionSize().0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionSize().0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92\ := to_unsigned(0, 32);
                \Posit32::FractionSize().0.num\ := to_signed(0, 32);
                \Posit32::FractionSize().0.return.0\ := to_unsigned(0, 8);
                \Posit32::FractionSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSize().0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1\ := to_unsigned(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSize().0._State\ is 
                    when \Posit32::FractionSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSize().0._Started\ = true) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSize().0._Started\ = true) then 
                            \Posit32::FractionSize().0._Finished\ <= true;
                        else 
                            \Posit32::FractionSize().0._Finished\ <= false;
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_2\ => 
                        \Posit32::FractionSize().0.this\ := \Posit32::FractionSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92 = 0u;
                        -- 
                        \Posit32::FractionSize().0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = 0u;
                        -- 
                        \Posit32::FractionSize().0.bits\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 32 - ((int)(Posit32.LengthOfRunOfBits (0u, 31)) + 2 + 2);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= SmartResize(unsigned(to_signed(31, 32)), 8);
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSize().0.return.0\ := \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSize().0.binaryOperationResult.0\ := signed(SmartResize((\Posit32::FractionSize().0.return.0\), 32)) + to_signed(2, 32);
                            \Posit32::FractionSize().0.binaryOperationResult.1\ := SmartResize(\Posit32::FractionSize().0.binaryOperationResult.0\ + to_signed(2, 32), 32);
                            \Posit32::FractionSize().0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSize().0.binaryOperationResult.1\);
                            \Posit32::FractionSize().0.num\ := \Posit32::FractionSize().0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((num > 0)) {
                            -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = ((uint)num);
                            -- } else {
                            -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = 0u;
                            -- }
                            -- 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Posit32::FractionSize().0._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSize().0.binaryOperationResult.3\ := \Posit32::FractionSize().0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSize().0._State_6\ and ends in state \Posit32::FractionSize().0._State_6\.
                        --     * The false branch starts in state \Posit32::FractionSize().0._State_7\ and ends in state \Posit32::FractionSize().0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().0._State_5\.

                        if ((\Posit32::FractionSize().0.binaryOperationResult.3\)) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_6\;
                        else 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::FractionSize().0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1;
                        -- 
                        \Posit32::FractionSize().0.return\ <= \Posit32::FractionSize().0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1\;
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = ((uint)num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = ((uint)num);
                        -- 
                        \Posit32::FractionSize().0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1\ := (unsigned(\Posit32::FractionSize().0.num\));
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_4\.
                        if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_6\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1 = 0u;
                        -- 
                        \Posit32::FractionSize().0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_4\.
                        if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_7\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 state machine start
    \Posit32::FractionWithHiddenBit().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBit().0._State\: \Posit32::FractionWithHiddenBit().0._States\ := \Posit32::FractionWithHiddenBit().0._State_0\;
        Variable \Posit32::FractionWithHiddenBit().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBit().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBit().0._Finished\ <= false;
                \Posit32::FractionWithHiddenBit().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_0\;
                \Posit32::FractionWithHiddenBit().0.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.num2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\ := false;
                \Posit32::FractionWithHiddenBit().0.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBit().0._State\ is 
                    when \Posit32::FractionWithHiddenBit().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().0._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBit().0._Finished\ <= false;
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_2\ => 
                        \Posit32::FractionWithHiddenBit().0.this\ := \Posit32::FractionWithHiddenBit().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.this\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.0\ := \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\;
                            \Posit32::FractionWithHiddenBit().0.num\ := \Posit32::FractionWithHiddenBit().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e = 0u;
                            -- 
                            \Posit32::FractionWithHiddenBit().0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0u;
                            -- 
                            \Posit32::FractionWithHiddenBit().0.num2\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- uint bits;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = 0u << (int)(32L - (long)(num)) >> (int)(32L - (long)(num));
                            -- 
                            \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\ := SmartResize(to_signed(32, 64) - signed(SmartResize((\Posit32::FractionWithHiddenBit().0.num\), 64)), 32);
                            \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\ := shift_left(to_unsigned(0, 32), to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\), 5))));
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9142
                    when \Posit32::FractionWithHiddenBit().0._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\ := SmartResize(to_signed(32, 64) - signed(SmartResize((\Posit32::FractionWithHiddenBit().0.num\), 64)), 32);
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32::FractionWithHiddenBit().0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBit().0.bits\ := \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((long)(num) == 0L)) {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = 1u;
                        -- } else {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = Posit32.SetOne (bits, (ushort)num);
                        -- }
                        -- 
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\ := signed(SmartResize((\Posit32::FractionWithHiddenBit().0.num\), 64)) = to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionWithHiddenBit().0._State_7\ and ends in state \Posit32::FractionWithHiddenBit().0._State_7\.
                        --     * The false branch starts in state \Posit32::FractionWithHiddenBit().0._State_8\ and ends in state \Posit32::FractionWithHiddenBit().0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().0._State_6\.

                        if ((\Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\)) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_7\;
                        else 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9328
                    when \Posit32::FractionWithHiddenBit().0._State_6\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2;
                        -- 
                        \Posit32::FractionWithHiddenBit().0.return\ <= \Posit32::FractionWithHiddenBit().0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2\;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_7\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = 1u;
                        -- 
                        \Posit32::FractionWithHiddenBit().0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2\ := to_unsigned(1, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_5\.
                        if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_7\) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_8\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = Posit32.SetOne (bits, (ushort)num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2 = Posit32.SetOne (bits, (ushort)num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.bits\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBit().0.num\, 16);
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.1\ := \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBit().0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2\ := \Posit32::FractionWithHiddenBit().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_5\.
                            if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_9\) then 
                                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0._State\: \Posit32::GetMostSignificantOnePosition(UInt32).0._States\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := SmartResize(unsigned(to_signed(0, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(bits) != 0L) {
                        -- 	bits = bits >> 1;
                        -- 	b = (byte)((int)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\ := signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt32).0.bits\), 64)) /= to_signed(0, 64);
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (byte)((int)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\ := shift_right(\Posit32::GetMostSignificantOnePosition(UInt32).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (byte)((int)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt32).0.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := (\Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8704
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.return\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 state machine start
    \Posit32::SetOne(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetOne(UInt32,UInt16).0._State\: \Posit32::SetOne(UInt32,UInt16).0._States\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
        Variable \Posit32::SetOne(UInt32,UInt16).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetOne(UInt32,UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= false;
                \Posit32::SetOne(UInt32,UInt16).0.return\ <= to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
                \Posit32::SetOne(UInt32,UInt16).0.bits\ := to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0.index\ := to_unsigned(0, 16);
                \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetOne(UInt32,UInt16).0._State\ is 
                    when \Posit32::SetOne(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetOne(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetOne(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetOne(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= false;
                            \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetOne(UInt32,UInt16).0._State_2\ => 
                        \Posit32::SetOne(UInt32,UInt16).0.bits\ := \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\;
                        \Posit32::SetOne(UInt32,UInt16).0.index\ := \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits | (uint)(1 << (int)index);
                        -- 
                        \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\ := unsigned(shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetOne(UInt32,UInt16).0.index\, 32)), 5)))));
                        \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\ := \Posit32::SetOne(UInt32,UInt16).0.bits\ or (\Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\);
                        \Posit32::SetOne(UInt32,UInt16).0.return\ <= \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.663
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 state machine start
    \Posit32::SetZero(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetZero(UInt32,UInt16).0._State\: \Posit32::SetZero(UInt32,UInt16).0._States\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
        Variable \Posit32::SetZero(UInt32,UInt16).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= false;
                \Posit32::SetZero(UInt32,UInt16).0.return\ <= to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
                \Posit32::SetZero(UInt32,UInt16).0.bits\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0.index\ := to_unsigned(0, 16);
                \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0.unaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetZero(UInt32,UInt16).0._State\ is 
                    when \Posit32::SetZero(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetZero(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetZero(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= false;
                            \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).0._State_2\ => 
                        \Posit32::SetZero(UInt32,UInt16).0.bits\ := \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\;
                        \Posit32::SetZero(UInt32,UInt16).0.index\ := \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits & (uint)(~(1 << (int)index));
                        -- 
                        \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetZero(UInt32,UInt16).0.index\, 32)), 5))));
                        \Posit32::SetZero(UInt32,UInt16).0.unaryOperationResult.0\ := not((\Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\));
                        \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\ := \Posit32::SetZero(UInt32,UInt16).0.bits\ and unsigned((\Posit32::SetZero(UInt32,UInt16).0.unaryOperationResult.0\));
                        \Posit32::SetZero(UInt32,UInt16).0.return\ <= \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.8078
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 state machine start
    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\: \Posit32::LengthOfRunOfBits(UInt32,Byte).0._States\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\ <= to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\ := to_signed(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.10\ := to_signed(0, 32);
            else 
                case \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ is 
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= true;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= false;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\ => 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (bits >> 31) & 1u;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\) and to_unsigned(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2) < (int)(startingPosition) && bits >> 31 == num) {
                        -- 	bits = bits << 1;
                        -- 	b = (byte)((int)(b) + 1);
                        -- 	num2 = num2 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\.
                        -- The while loop's condition:
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\) < signed(SmartResize((\Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\), 32));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\ and \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\;
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits << 1;
                            -- 	b = (byte)((int)(b) + 1);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits << 1;
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (byte)((int)(b) + 1);
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.10\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\ + to_signed(1, 32);
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num2\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.10\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\ if the loop wasn't exited with a state change.
                            if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\) then 
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\;
                            end if;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 state machine start
    \Posit32::GetTwosComplement(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetTwosComplement(UInt32).0._State\: \Posit32::GetTwosComplement(UInt32).0._States\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
        Variable \Posit32::GetTwosComplement(UInt32).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetTwosComplement(UInt32).0.unaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetTwosComplement(UInt32).0._Finished\ <= false;
                \Posit32::GetTwosComplement(UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
                \Posit32::GetTwosComplement(UInt32).0.bits\ := to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).0.unaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetTwosComplement(UInt32).0._State\ is 
                    when \Posit32::GetTwosComplement(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetTwosComplement(UInt32).0._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetTwosComplement(UInt32).0._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::GetTwosComplement(UInt32).0._Finished\ <= false;
                            \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).0._State_2\ => 
                        \Posit32::GetTwosComplement(UInt32).0.bits\ := \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(~bits) + 1L);
                        -- 
                        \Posit32::GetTwosComplement(UInt32).0.unaryOperationResult.0\ := not(\Posit32::GetTwosComplement(UInt32).0.bits\);
                        \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetTwosComplement(UInt32).0.unaryOperationResult.0\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::GetTwosComplement(UInt32).0.return\ <= (\Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\);
                        \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 state machine start
    \Posit32::FusedSum(Posit32[],Quire).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FusedSum(Posit32[],Quire).0._State\: \Posit32::FusedSum(Posit32[],Quire).0._States\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.posits\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
        Variable \Posit32::FusedSum(Posit32[],Quire).0.startingValue\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.1\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.2\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.3\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.4\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
                \Posit32::FusedSum(Posit32[],Quire).0.return.1\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.num\ := to_signed(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.return.2\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Posit32::FusedSum(Posit32[],Quire).0._State\ is 
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._Started\ = true) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._Started\ = true) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= true;
                        else 
                            \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits\;
                        \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_2\ => 
                        \Posit32::FusedSum(Posit32[],Quire).0.posits\ := \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\;
                        \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Quire quire;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Quire objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011 = new Quire (1u, 512);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\IsNull\ := false;
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\Size\ := to_unsigned(0, 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\;
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(512, 32)), 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- quire = Quire.op_LeftShift (objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011, 511);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(511, 32);
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.0\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.quire\ := \Posit32::FusedSum(Posit32[],Quire).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Quire.op_Equality (startingValue, quire)) {
                            -- 	return quire;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.1\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.quire\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FusedSum(Posit32[],Quire).0._State_7\ and ends in state \Posit32::FusedSum(Posit32[],Quire).0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FusedSum(Posit32[],Quire).0._State_6\.

                            if (\Posit32::FusedSum(Posit32[],Quire).0.return.1\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_7\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_6\ => 
                        -- State after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.num\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num < 160) {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsNaN (posits [num])) {
                        -- 		return quire;
                        -- 	}
                        -- 	startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_7\ => 
                        -- True branch of the if-else started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return quire;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return quire;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_7\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\.
                        -- The while loop's condition:
                        \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\ := \Posit32::FusedSum(Posit32[],Quire).0.num\ < to_signed(160, 32);
                        if (\Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	if (Lombiq.Arithmetics.Posit32.IsNaN (posits [num])) {
                            -- 		return quire;
                            -- 	}
                            -- 	startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit32.IsNaN (posits [num])) {
                            -- 	return quire;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                            \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits\(to_integer(\Posit32::FusedSum(Posit32[],Quire).0.num\));
                            \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_10\;
                        else 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_9\ => 
                        -- State after the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return startingValue;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.2\ := \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FusedSum(Posit32[],Quire).0._State_12\ and ends in state \Posit32::FusedSum(Posit32[],Quire).0._State_12\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FusedSum(Posit32[],Quire).0._State_11\.

                            if (\Posit32::FusedSum(Posit32[],Quire).0.return.2\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_12\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_11\ => 
                        -- State after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits\(to_integer(\Posit32::FusedSum(Posit32[],Quire).0.num\));
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_12\ => 
                        -- True branch of the if-else started in state \Posit32::FusedSum(Posit32[],Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return quire;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return quire;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_10\.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_12\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.3\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.return.3\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.4\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.3\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\ := \Posit32::FusedSum(Posit32[],Quire).0.num\ + to_signed(1, 32);
                            \Posit32::FusedSum(Posit32[],Quire).0.num\ := \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\ if the loop wasn't exited with a state change.
                            if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_14\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine start
    \Quire Posit32::op_Explicit(Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Posit32::op_Explicit(Posit32).0._State\: \Quire Posit32::op_Explicit(Posit32).0._States\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.x\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.2\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.3\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
                \Quire Posit32::op_Explicit(Posit32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Posit32::op_Explicit(Posit32).0.return.0\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return.1\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.return.2\ := to_signed(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Quire Posit32::op_Explicit(Posit32).0._State\ is 
                    when \Quire Posit32::op_Explicit(Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= true;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_2\ => 
                        \Quire Posit32::op_Explicit(Posit32).0.x\ := \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- array [0] = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.x\;
                        \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.0\ := \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.array\(to_integer(to_signed(0, 32))) := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.return.0\, 64);
                            -- The following section was transformed from the .NET statement below:
                            -- Quire quire;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- quire = new Quire (array, 0);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Quire Posit32::op_Explicit(Posit32).0.quire\.\IsNull\ := false;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\.\Size\ := to_unsigned(0, 16);
                            \Quire Posit32::op_Explicit(Posit32).0.quire\.\SegmentCount\ := to_unsigned(0, 16);
                            \Quire Posit32::op_Explicit(Posit32).0.quire\.\Segments\ := (others => to_unsigned(0, 64));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.array\;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.array\ := \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- quire = Quire.op_LeftShift (quire, (int)(240L - (long)(Lombiq.Arithmetics.Posit32.FractionSize (x)) + (long)(Lombiq.Arithmetics.Posit32.CalculateScaleFactor (x))));
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.x\;
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.1\ := \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := to_signed(240, 64) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return.1\), 64));
                            -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor()
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.x\;
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Quire Posit32::op_Explicit(Posit32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor()
                        if (\Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.2\ := \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ + SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return.2\), 64), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\);
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Quire Posit32::op_Explicit(Posit32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.3\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return quire;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.return\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 state machine start
    \Quire::.ctor(UInt64[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Quire::.ctor(UInt64[],UInt16).0._State\: \Quire::.ctor(UInt64[],UInt16).0._States\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
        Variable \Quire::.ctor(UInt64[],UInt16).0.this\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire::.ctor(UInt64[],UInt16).0.segments\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire::.ctor(UInt64[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt64[],UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= false;
                \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 64));
                \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
                \Quire::.ctor(UInt64[],UInt16).0.segments\ := (others => to_unsigned(0, 64));
                \Quire::.ctor(UInt64[],UInt16).0.size\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt64[],UInt16).0.num\ := to_signed(0, 32);
                \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\ := false;
                \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Quire::.ctor(UInt64[],UInt16).0._State\ is 
                    when \Quire::.ctor(UInt64[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire::.ctor(UInt64[],UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire::.ctor(UInt64[],UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= true;
                        else 
                            \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= false;
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\ <= \Quire::.ctor(UInt64[],UInt16).0.this\;
                        \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\ <= \Quire::.ctor(UInt64[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_2\ => 
                        \Quire::.ctor(UInt64[],UInt16).0.this\ := \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\;
                        \Quire::.ctor(UInt64[],UInt16).0.segments\ := \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\;
                        \Quire::.ctor(UInt64[],UInt16).0.size\ := \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = 8;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\SegmentCount\ := to_unsigned(8, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 0;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Size\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = new ulong[8];
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (segments, @this.Segments, 8);
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\ := \Quire::.ctor(UInt64[],UInt16).0.segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 8;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.num\ := to_signed(8, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < 8) {
                        -- 	@this.Segments [num] = 0uL;
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire::.ctor(UInt64[],UInt16).0._State_2\.
                        -- The while loop's condition:
                        \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\ := (\Quire::.ctor(UInt64[],UInt16).0.num\) < to_signed(8, 32);
                        if (\Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	@this.Segments [num] = 0uL;
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- @this.Segments [num] = 0uL;
                            -- 
                            \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\(to_integer(\Quire::.ctor(UInt64[],UInt16).0.num\)) := to_unsigned(0, 64);
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\ := \Quire::.ctor(UInt64[],UInt16).0.num\ + to_signed(1, 32);
                            \Quire::.ctor(UInt64[],UInt16).0.num\ := \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\;
                        else 
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Quire::.ctor(UInt64[],UInt16).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire::.ctor(UInt64[],UInt16).0._State_2\.
                        \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 state machine start
    \Quire::.ctor(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Quire::.ctor(UInt32,UInt16).0._State\: \Quire::.ctor(UInt32,UInt16).0._States\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
        Variable \Quire::.ctor(UInt32,UInt16).0.this\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire::.ctor(UInt32,UInt16).0.firstSegment\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt32,UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\: boolean := false;
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire::.ctor(UInt32,UInt16).0._Finished\ <= false;
                \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
                \Quire::.ctor(UInt32,UInt16).0.firstSegment\ := to_unsigned(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.size\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := false;
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt32,UInt16).0.num\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\ := false;
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\ := to_signed(0, 32);
            else 
                case \Quire::.ctor(UInt32,UInt16).0._State\ is 
                    when \Quire::.ctor(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._Finished\ <= false;
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\ <= \Quire::.ctor(UInt32,UInt16).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_2\ => 
                        \Quire::.ctor(UInt32,UInt16).0.this\ := \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\;
                        \Quire::.ctor(UInt32,UInt16).0.firstSegment\ := \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\;
                        \Quire::.ctor(UInt32,UInt16).0.size\ := \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Size\ := \Quire::.ctor(UInt32,UInt16).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b = (int)size;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ := signed(SmartResize(\Quire::.ctor(UInt32,UInt16).0.size\, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b - remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b / 32 * 32 != 0)) {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- } else {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- }
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ / to_signed(32, 32);
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := SmartResize(\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.861
                    when \Quire::.ctor(UInt32,UInt16).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ - \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire::.ctor(UInt32,UInt16).0._State_5\ and ends in state \Quire::.ctor(UInt32,UInt16).0._State_5\.
                        --     * The false branch starts in state \Quire::.ctor(UInt32,UInt16).0._State_6\ and ends in state \Quire::.ctor(UInt32,UInt16).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \Quire::.ctor(UInt32,UInt16).0._State_4\.

                        if ((\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\)) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_5\;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5903
                    when \Quire::.ctor(UInt32,UInt16).0._State_4\ => 
                        -- State after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(((int)(size) >> 6) + (conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517));
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := shift_right(signed(SmartResize((\Quire::.ctor(UInt32,UInt16).0.size\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5) and "11111")));
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := SmartResize(unsigned((\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\) + (\Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\)), 16);
                        \Quire::.ctor(UInt32,UInt16).0.this\.\SegmentCount\ := (\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = new ulong[8];
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments [0] = 1u;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\(to_integer(to_signed(0, 32))) := SmartResize(to_unsigned(1, 32), 64);
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.num\ := to_signed(1, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(@this.SegmentCount)) {
                        -- 	@this.Segments [num] = 0uL;
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.64
                    when \Quire::.ctor(UInt32,UInt16).0._State_5\ => 
                        -- True branch of the if-else started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        if (\Quire::.ctor(UInt32,UInt16).0._State\ = \Quire::.ctor(UInt32,UInt16).0._State_5\) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        if (\Quire::.ctor(UInt32,UInt16).0._State\ = \Quire::.ctor(UInt32,UInt16).0._State_6\) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Quire::.ctor(UInt32,UInt16).0._State_4\.
                        -- The while loop's condition:
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\ := (\Quire::.ctor(UInt32,UInt16).0.num\) < signed(SmartResize((\Quire::.ctor(UInt32,UInt16).0.this\.\SegmentCount\), 32));
                        if (\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	@this.Segments [num] = 0uL;
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- @this.Segments [num] = 0uL;
                            -- 
                            \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\(to_integer(\Quire::.ctor(UInt32,UInt16).0.num\)) := to_unsigned(0, 64);
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\ := \Quire::.ctor(UInt32,UInt16).0.num\ + to_signed(1, 32);
                            \Quire::.ctor(UInt32,UInt16).0.num\ := \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Quire::.ctor(UInt32,UInt16).0._State_8\ => 
                        -- State after the while loop which was started in state \Quire::.ctor(UInt32,UInt16).0._State_4\.
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine start
    \Quire Quire::op_Addition(Quire,Quire).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_Addition(Quire,Quire).0._State\: \Quire Quire::op_Addition(Quire,Quire).0._States\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.right\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag2\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag3\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_Addition(Quire,Quire).0.flag\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.num3\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.flag2\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.flag3\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.b\ := to_unsigned(0, 8);
                \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\ := to_unsigned(0, 8);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_Addition(Quire,Quire).0._State\ is 
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= false;
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\ <= \Quire Quire::op_Addition(Quire,Quire).0.left\;
                        \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\ <= \Quire Quire::op_Addition(Quire,Quire).0.right\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_2\ => 
                        \Quire Quire::op_Addition(Quire,Quire).0.left\ := \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\;
                        \Quire Quire::op_Addition(Quire,Quire).0.right\ := \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(left.SegmentCount) == 0 || (int)(right.SegmentCount) == 0) {
                        -- 	return left;
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ or \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_4\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_4\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_3\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_3\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = false;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.flag\ := false;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num3\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num3) < (int)((int)(left.SegmentCount) << 6)) {
                        -- 	bool flag2;
                        -- 	flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 	bool flag3;
                        -- 	flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 	byte b;
                        -- 	int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                        -- 	if (flag2) {
                        -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- 	} else {
                        -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- 	}
                        -- 	int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                        -- 	if (flag3) {
                        -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- 	} else {
                        -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- 	}
                        -- 	int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                        -- 	if (flag) {
                        -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- 	} else {
                        -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- 	}
                        -- 	b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                        -- 	if (((int)(b) & 1) == 1) {
                        -- 		array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- 	}
                        -- 	flag = (int)(b) >> 1 == 1;
                        -- 	num2 = (ushort)((int)(num2) + 1);
                        -- 	if ((int)(num2) >> 6 == 1) {
                        -- 		num2 = 0;
                        -- 		num = (ushort)((int)(num) + 1);
                        -- 	}
                        -- 	num3 = (ushort)((int)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_4\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return left;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.return\ <= \Quire Quire::op_Addition(Quire,Quire).0.left\;
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_4\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\ := shift_left(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.left\.\SegmentCount\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5))));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num3\), 32)) < (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\);
                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag2;
                            -- 	flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 	bool flag3;
                            -- 	flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 	byte b;
                            -- 	int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                            -- 	if (flag2) {
                            -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                            -- 	} else {
                            -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                            -- 	}
                            -- 	int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                            -- 	if (flag3) {
                            -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                            -- 	} else {
                            -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                            -- 	}
                            -- 	int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                            -- 	if (flag) {
                            -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                            -- 	} else {
                            -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                            -- 	}
                            -- 	b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                            -- 	if (((int)(b) & 1) == 1) {
                            -- 		array [num] = array [num] + (ulong)(1L << (int)num2);
                            -- 	}
                            -- 	flag = (int)(b) >> 1 == 1;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- 	if ((int)(num2) >> 6 == 1) {
                            -- 		num2 = 0;
                            -- 		num = (ushort)((int)(num) + 1);
                            -- 	}
                            -- 	num3 = (ushort)((int)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_7\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4003
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_6\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5 = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\IsNull\ := false;
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\;
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.array\;
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\ := SmartResize(shift_right(\Quire Quire::op_Addition(Quire,Quire).0.left\.\Segments\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6) and "111111"))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\) and to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.9145
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\) = to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag2\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\ := SmartResize(shift_right(\Quire Quire::op_Addition(Quire,Quire).0.right\.\Segments\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6) and "111111"))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\) and to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.9145
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\) = to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag3\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- } else {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_12\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_12\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_13\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_11\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag2\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_12\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_11\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- } else {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_15\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_15\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_16\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_14\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag3\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_15\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_12\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_12\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_13\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_13\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_14\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- } else {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_18\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_18\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_19\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_17\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_18\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_15\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_15\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_16\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_16\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_17\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ := (\Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\) + (\Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\ := SmartResize(unsigned(\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ + (\Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\)), 8);
                        \Quire Quire::op_Addition(Quire,Quire).0.b\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(b) & 1) == 1) {
                        -- 	array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.b\), 32)) and to_signed(1, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.7912
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_18\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_18\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_19\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_19\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\) = to_signed(1, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_22\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_21\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_22\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_21\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (int)(b) >> 1 == 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ := shift_right(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.b\), 32)), to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ = to_signed(1, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num2) >> 6 == 1) {
                        -- 	num2 = 0;
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0.8515
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_22\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\ := SmartResize(unsigned(shift_left(to_signed(1, 64), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6))))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\ := \Quire Quire::op_Addition(Quire,Quire).0.array\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)) + (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\);
                        \Quire Quire::op_Addition(Quire,Quire).0.array\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)) := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_22\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9498
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_23\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ := shift_right(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num2\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5) and "11111")));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ = to_signed(1, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_25\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_24\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_25\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5777
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_24\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (ushort)((int)(num3) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num3\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_24\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_25\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_25\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\ := \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.array\ := \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5;
                            -- 
                            \Quire Quire::op_Addition(Quire,Quire).0.return\ <= \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\;
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 state machine start
    \Quire Quire::op_Addition(Quire,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_Addition(Quire,UInt32).0._State\: \Quire Quire::op_Addition(Quire,UInt32).0._States\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.return.0\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
                \Quire Quire::op_Addition(Quire,UInt32).0.right\ := to_unsigned(0, 32);
                \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_Addition(Quire,UInt32).0._State\ is 
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_2\ => 
                        \Quire Quire::op_Addition(Quire,UInt32).0.left\ := \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\;
                        \Quire Quire::op_Addition(Quire,UInt32).0.right\ := \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0 = new Quire (1u, (ushort)((int)(left.SegmentCount) << 6));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\IsNull\ := false;
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\ := SmartResize(unsigned(shift_left(signed(SmartResize((\Quire Quire::op_Addition(Quire,UInt32).0.left\.\SegmentCount\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5))))), 16);
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\;
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= (\Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\);
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.125
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Quire.op_Addition (left, object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= true;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0.return.0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.left\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.return\ <= \Quire Quire::op_Addition(Quire,UInt32).0.return.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 state machine start
    \Quire Quire::op_OnesComplement(Quire).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_OnesComplement(Quire).0._State\: \Quire Quire::op_OnesComplement(Quire).0._States\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
        Variable \Quire Quire::op_OnesComplement(Quire).0.q\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_OnesComplement(Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= false;
                \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
                \Quire Quire::op_OnesComplement(Quire).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\ := false;
                \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\ := to_unsigned(0, 64);
                \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_OnesComplement(Quire).0._State\ is 
                    when \Quire Quire::op_OnesComplement(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_OnesComplement(Quire).0._Started\ = true) then 
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_OnesComplement(Quire).0._Started\ = true) then 
                            \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= false;
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\ <= \Quire Quire::op_OnesComplement(Quire).0.q\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_2\ => 
                        \Quire Quire::op_OnesComplement(Quire).0.q\ := \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_OnesComplement(Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(q.SegmentCount)) {
                        -- 	q.Segments [num] = ~q.Segments [num];
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_OnesComplement(Quire).0._State_2\.
                        -- The while loop's condition:
                        \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.num\), 32)) < signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.q\.\SegmentCount\), 32));
                        if (\Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	q.Segments [num] = ~q.Segments [num];
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- q.Segments [num] = ~q.Segments [num];
                            -- 
                            \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\ := not(\Quire Quire::op_OnesComplement(Quire).0.q\.\Segments\(to_integer(\Quire Quire::op_OnesComplement(Quire).0.num\)));
                            \Quire Quire::op_OnesComplement(Quire).0.q\.\Segments\(to_integer(\Quire Quire::op_OnesComplement(Quire).0.num\)) := \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (ushort)((int)(num) + 1);
                            -- 
                            \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                            \Quire Quire::op_OnesComplement(Quire).0.num\ := (\Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\);
                        else 
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7457
                    when \Quire Quire::op_OnesComplement(Quire).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_OnesComplement(Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return q;
                        -- 
                        \Quire Quire::op_OnesComplement(Quire).0.return\ <= \Quire Quire::op_OnesComplement(Quire).0.q\;
                        \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine start
    \Boolean Quire::op_Equality(Quire,Quire).0._StateMachine\: process (\Clock\) 
        Variable \Boolean Quire::op_Equality(Quire,Quire).0._State\: \Boolean Quire::op_Equality(Quire,Quire).0._States\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.right\: \Lombiq.Arithmetics.Quire\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= false;
                \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.num\ := to_unsigned(0, 16);
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \Boolean Quire::op_Equality(Quire,Quire).0._State\ is 
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._Started\ = true) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._Started\ = true) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= true;
                        else 
                            \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= false;
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\ <= \Boolean Quire::op_Equality(Quire,Quire).0.left\;
                        \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\ <= \Boolean Quire::op_Equality(Quire,Quire).0.right\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_2\ => 
                        \Boolean Quire::op_Equality(Quire,Quire).0.left\ := \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\;
                        \Boolean Quire::op_Equality(Quire,Quire).0.right\ := \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(left.SegmentCount) != (int)(right.SegmentCount)) {
                        -- 	return false;
                        -- }
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.left\.\SegmentCount\), 32)) /= signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.right\.\SegmentCount\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Boolean Quire::op_Equality(Quire,Quire).0._State_4\ and ends in state \Boolean Quire::op_Equality(Quire,Quire).0._State_4\.
                        --     * Execution after either branch will continue in the following state: \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.

                        if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_3\ => 
                        -- State after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(left.SegmentCount)) {
                        -- 	if (left.Segments [num] != right.Segments [num]) {
                        -- 		return false;
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_4\ => 
                        -- True branch of the if-else started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_4\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.
                        -- The while loop's condition:
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\ := signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.num\), 32)) < signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.left\.\SegmentCount\), 32));
                        if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	if (left.Segments [num] != right.Segments [num]) {
                            -- 		return false;
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (left.Segments [num] != right.Segments [num]) {
                            -- 	return false;
                            -- }
                            -- 
                            \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\ := \Boolean Quire::op_Equality(Quire,Quire).0.left\.\Segments\(to_integer(\Boolean Quire::op_Equality(Quire,Quire).0.num\)) /= \Boolean Quire::op_Equality(Quire,Quire).0.right\.\Segments\(to_integer(\Boolean Quire::op_Equality(Quire,Quire).0.num\));

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Boolean Quire::op_Equality(Quire,Quire).0._State_8\ and ends in state \Boolean Quire::op_Equality(Quire,Quire).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Boolean Quire::op_Equality(Quire,Quire).0._State_7\.

                            if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\) then 
                                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_8\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_7\;
                            end if;
                        else 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.557
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_6\ => 
                        -- State after the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return true;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= true;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_7\ => 
                        -- State after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Boolean Quire::op_Equality(Quire,Quire).0.num\ := (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\);
                        -- Returning to the repeated state of the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_7\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_8\ => 
                        -- True branch of the if-else started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_8\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine start
    \Quire Quire::op_RightShift(Quire,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_RightShift(Quire,Int32).0._State\: \Quire Quire::op_RightShift(Quire,Int32).0._States\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.flag\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.flag2\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
                \Quire Quire::op_RightShift(Quire,Int32).0.right\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_RightShift(Quire,Int32).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.num3\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.flag2\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_RightShift(Quire,Int32).0._State\ is 
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= false;
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\ <= \Quire Quire::op_RightShift(Quire,Int32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_2\ => 
                        \Quire Quire::op_RightShift(Quire,Int32).0.left\ := \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.right\ := \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- right = right & ((1 << (int)(left.SegmentCount) * 6) - 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.left\.\SegmentCount\), 32)) * to_signed(6, 32), 32);
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\, 5))));
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.9452
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\) - to_signed(1, 32);
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\ := \Quire Quire::op_RightShift(Quire,Int32).0.right\ and (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\);
                        \Quire Quire::op_RightShift(Quire,Int32).0.right\ := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (left.Segments, array, 8);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\ := \Quire Quire::op_RightShift(Quire,Int32).0.left\.\Segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(right)) {
                        -- 	bool flag;
                        -- 	flag = false;
                        -- 	ushort num2;
                        -- 	num2 = 1;
                        -- 	while ((int)(num2) <= 8) {
                        -- 		ushort num3;
                        -- 		num3 = (ushort)(8 - (int)(num2));
                        -- 		bool flag2;
                        -- 		flag2 = (array [num3] & 1uL) == 1uL;
                        -- 		array [num3] = array [num3] >> 1;
                        -- 		if (flag) {
                        -- 			array [num3] = array [num3] | 0x8000000000000000uL;
                        -- 		}
                        -- 		flag = flag2;
                        -- 		num2 = (ushort)((int)(num2) + 1);
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_4\;
                        -- Clock cycles needed to complete this state (approximation): 0.4649
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\ := signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num\), 32)) < (\Quire Quire::op_RightShift(Quire,Int32).0.right\);
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag;
                            -- 	flag = false;
                            -- 	ushort num2;
                            -- 	num2 = 1;
                            -- 	while ((int)(num2) <= 8) {
                            -- 		ushort num3;
                            -- 		num3 = (ushort)(8 - (int)(num2));
                            -- 		bool flag2;
                            -- 		flag2 = (array [num3] & 1uL) == 1uL;
                            -- 		array [num3] = array [num3] >> 1;
                            -- 		if (flag) {
                            -- 			array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 		}
                            -- 		flag = flag2;
                            -- 		num2 = (ushort)((int)(num2) + 1);
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := false;
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := SmartResize(unsigned(to_signed(1, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num2) <= 8) {
                            -- 	ushort num3;
                            -- 	num3 = (ushort)(8 - (int)(num2));
                            -- 	bool flag2;
                            -- 	flag2 = (array [num3] & 1uL) == 1uL;
                            -- 	array [num3] = array [num3] >> 1;
                            -- 	if (flag) {
                            -- 		array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_6\;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_5\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741 = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\IsNull\ := false;
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.array\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\.
                        -- The while loop's condition:
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\ := signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32)) <= to_signed(8, 32);
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	ushort num3;
                            -- 	num3 = (ushort)(8 - (int)(num2));
                            -- 	bool flag2;
                            -- 	flag2 = (array [num3] & 1uL) == 1uL;
                            -- 	array [num3] = array [num3] >> 1;
                            -- 	if (flag) {
                            -- 		array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ushort)(8 - (int)(num2));
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\ := SmartResize(unsigned(to_signed(8, 32) - signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32))), 16);
                            \Quire Quire::op_RightShift(Quire,Int32).0.num3\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\);
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = (array [num3] & 1uL) == 1uL;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\ := \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) and to_unsigned(1, 64);
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_8\;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.775
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_7\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.num\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_7\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\) = to_unsigned(1, 64);
                        \Quire Quire::op_RightShift(Quire,Int32).0.flag2\ := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\;
                        -- The following section was transformed from the .NET statement below:
                        -- array [num3] = array [num3] >> 1;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\ := SmartResize(shift_right(\Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)), to_integer(unsigned(SmartResize(to_signed(1, 32), 6) and "111111"))), 64);
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	array [num3] = array [num3] | 0x8000000000000000uL;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_RightShift(Quire,Int32).0._State_10\ and ends in state \Quire Quire::op_RightShift(Quire,Int32).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_RightShift(Quire,Int32).0._State_9\.

                        if (\Quire Quire::op_RightShift(Quire,Int32).0.flag\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_10\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5588
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_9\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = flag2;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := \Quire Quire::op_RightShift(Quire,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_9\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_10\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num3] = array [num3] | 0x8000000000000000uL;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num3] = array [num3] | 0x8000000000000000uL;
                        -- 
                        -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\ := \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) or "1000000000000000000000000000000000000000000000000000000000000000";
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_10\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\ := \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_RightShift(Quire,Int32).0.array\ := \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.return\ <= \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\;
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine start
    \Quire Quire::op_LeftShift(Quire,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0._State\: \Quire Quire::op_LeftShift(Quire,Int32).0._States\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.flag\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
                \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := to_signed(0, 32);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_LeftShift(Quire,Int32).0._State\ is 
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= false;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\ => 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.left\ := \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- right = right & 65535;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\ := \Quire Quire::op_LeftShift(Quire,Int32).0.right\ and to_signed(65535, 32);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (left.Segments, array, 8);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := \Quire Quire::op_LeftShift(Quire,Int32).0.left\.\Segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(right)) {
                        -- 	bool flag;
                        -- 	flag = false;
                        -- 	ushort num2;
                        -- 	num2 = 0;
                        -- 	while ((int)(num2) < 8) {
                        -- 		bool flag2;
                        -- 		flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                        -- 		array [num2] = array [num2] << 1;
                        -- 		if (flag) {
                        -- 			array [num2] = (ulong)(array [num2] | 1uL);
                        -- 		}
                        -- 		flag = flag2;
                        -- 		num2 = (ushort)((int)(num2) + 1);
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\.
                        -- The while loop's condition:
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\ := signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num\), 32)) < (\Quire Quire::op_LeftShift(Quire,Int32).0.right\);
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag;
                            -- 	flag = false;
                            -- 	ushort num2;
                            -- 	num2 = 0;
                            -- 	while ((int)(num2) < 8) {
                            -- 		bool flag2;
                            -- 		flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 		array [num2] = array [num2] << 1;
                            -- 		if (flag) {
                            -- 			array [num2] = (ulong)(array [num2] | 1uL);
                            -- 		}
                            -- 		flag = flag2;
                            -- 		num2 = (ushort)((int)(num2) + 1);
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := false;
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num2) < 8) {
                            -- 	bool flag2;
                            -- 	flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 	array [num2] = array [num2] << 1;
                            -- 	if (flag) {
                            -- 		array [num2] = (ulong)(array [num2] | 1uL);
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\IsNull\ := false;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.array\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\ := signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num2\), 32)) < to_signed(8, 32);
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag2;
                            -- 	flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 	array [num2] = array [num2] << 1;
                            -- 	if (flag) {
                            -- 		array [num2] = (ulong)(array [num2] | 1uL);
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\ := \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) and "1000000000000000000000000000000000000000000000000000000000000000";
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\) = "1000000000000000000000000000000000000000000000000000000000000000";
                            \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\ := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [num2] = array [num2] << 1;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\ := SmartResize(shift_left(\Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)), to_integer(unsigned(SmartResize(to_signed(1, 32), 6)))), 64);
                            \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	array [num2] = (ulong)(array [num2] | 1uL);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\ and ends in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\.

                            if (\Quire Quire::op_LeftShift(Quire,Int32).0.flag\) then 
                                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\;
                            end if;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8351
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = flag2;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num2] = (ulong)(array [num2] | 1uL);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num2] = (ulong)(array [num2] | 1uL);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\ := \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) or to_unsigned(1, 64);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\ := \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.return\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine end


    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine start
    \UInt64 Quire::op_Explicit(Quire).0._StateMachine\: process (\Clock\) 
        Variable \UInt64 Quire::op_Explicit(Quire).0._State\: \UInt64 Quire::op_Explicit(Quire).0._States\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
        Variable \UInt64 Quire::op_Explicit(Quire).0.x\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= false;
                \UInt64 Quire::op_Explicit(Quire).0.return\ <= to_unsigned(0, 64);
                \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
            else 
                case \UInt64 Quire::op_Explicit(Quire).0._State\ is 
                    when \UInt64 Quire::op_Explicit(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\UInt64 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt64 Quire::op_Explicit(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\UInt64 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= true;
                        else 
                            \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= false;
                            \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\ <= \UInt64 Quire::op_Explicit(Quire).0.x\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt64 Quire::op_Explicit(Quire).0._State_2\ => 
                        \UInt64 Quire::op_Explicit(Quire).0.x\ := \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return x.Segments [0];
                        -- 
                        \UInt64 Quire::op_Explicit(Quire).0.return\ <= \UInt64 Quire::op_Explicit(Quire).0.x\.\Segments\(to_integer(to_signed(0, 32)));
                        \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine start
    \UInt32 Quire::op_Explicit(Quire).0._StateMachine\: process (\Clock\) 
        Variable \UInt32 Quire::op_Explicit(Quire).0._State\: \UInt32 Quire::op_Explicit(Quire).0._States\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
        Variable \UInt32 Quire::op_Explicit(Quire).0.x\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= false;
                \UInt32 Quire::op_Explicit(Quire).0.return\ <= to_unsigned(0, 32);
                \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
            else 
                case \UInt32 Quire::op_Explicit(Quire).0._State\ is 
                    when \UInt32 Quire::op_Explicit(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\UInt32 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt32 Quire::op_Explicit(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\UInt32 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= true;
                        else 
                            \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= false;
                            \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\ <= \UInt32 Quire::op_Explicit(Quire).0.x\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt32 Quire::op_Explicit(Quire).0._State_2\ => 
                        \UInt32 Quire::op_Explicit(Quire).0.x\ := \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)x.Segments [0];
                        -- 
                        \UInt32 Quire::op_Explicit(Quire).0.return\ <= SmartResize(\UInt32 Quire::op_Explicit(Quire).0.x\.\Segments\(to_integer(to_signed(0, 32))), 32);
                        \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(Int32).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\;
    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= \Posit32::.ctor(Int32).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) start
    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ := 0;
                            \Quire Posit32::op_Explicit(Posit32).0._Started\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Quire Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\ <= \Quire Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Posit32::op_Explicit(Posit32).0._Started\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Quire Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\ <= \Quire Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\;
    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= \Posit32::.ctor(UInt32,Boolean).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::FusedSum(Posit32[],Quire).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\ <= \Posit32::FusedSum(Posit32[],Quire).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.return\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(Quire).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\;
    \Posit32::.ctor(Quire).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.q.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\ <= \Posit32::.ctor(Quire).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\ <= \Posit32::.ctor(Quire).0.this.parameter.Out\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\ <= \Posit32::.ctor(Quire).0.q.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Quire Quire::op_RightShift(Quire,Int32).0._Started\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\;
    \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\;
    \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0._Finished\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.return\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \UInt64 Quire::op_Explicit(Quire).0._Started\ <= \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\;
    \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\ <= \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\ <= \UInt64 Quire::op_Explicit(Quire).0._Finished\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\ <= \UInt64 Quire::op_Explicit(Quire).0.return\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\ <= \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Quire Quire::op_OnesComplement(Quire).0._Started\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\;
    \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= \Quire Quire::op_OnesComplement(Quire).0._Finished\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\ <= \Quire Quire::op_OnesComplement(Quire).0.return\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\ <= \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Quire Quire::op_Addition(Quire,UInt32).0._Started\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\;
    \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\;
    \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0._Finished\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.return\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32) start
    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \UInt32 Quire::op_Explicit(Quire).0._Started\ <= \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\;
    \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\ <= \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\ <= \UInt32 Quire::op_Explicit(Quire).0._Finished\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\ <= \UInt32 Quire::op_Explicit(Quire).0.return\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\ <= \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\;
    \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 (#0):
    \Posit32::.ctor(UInt32).0._Started\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\;
    \Posit32::.ctor(UInt32).0.this.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32).0.value.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\ <= \Posit32::.ctor(UInt32).0._Finished\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\ <= \Posit32::.ctor(UInt32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32) start
    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 (#0):
    \Posit32::EncodeRegimeBits(Int32).0._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\;
    \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit32::EncodeRegimeBits(Int32).0._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\ <= \Posit32::EncodeRegimeBits(Int32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte) start
    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 0;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 (#0):
    \Posit32::GetTwosComplement(UInt32).0._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\;
    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= \Posit32::GetTwosComplement(UInt32).0._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 (#0):
    \Posit32::SetZero(UInt32,UInt16).0._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\;
    \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\;
    \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\ <= \Posit32::SetZero(UInt32,UInt16).0._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\ <= \Posit32::SetZero(UInt32,UInt16).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue() start
    -- Signal connections for System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 (#0):
    \Posit32::GetRegimeKValue().0._Started\ <= \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Started.0\;
    \Posit32::GetRegimeKValue().0.this.parameter.In\ <= \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
    \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue()._Finished.0\ <= \Posit32::GetRegimeKValue().0._Finished\;
    \Posit32::CalculateScaleFactor().0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue() start
    -- Signal connections for System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().0 (#0):
    \Posit32::GetExponentValue().0._Started\ <= \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Started.0\;
    \Posit32::GetExponentValue().0.this.parameter.In\ <= \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().this.parameter.Out.0\;
    \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue()._Finished.0\ <= \Posit32::GetExponentValue().0._Finished\;
    \Posit32::CalculateScaleFactor().0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue() end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::ExponentSize() start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 (#0):
    \Posit32::ExponentSize().0._Started\ <= \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\;
    \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\;
    \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\ <= \Posit32::ExponentSize().0._Finished\;
    \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::ExponentSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize() start
    \Hast::InternalInvocationProxy().Posit32::FractionSize()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit32::FractionSize().0._Started\ <= true;
                            \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit32::FractionSize().0._Started\ <= true;
                            \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Posit32::FractionSize().0._Started\ <= true;
                            \Posit32::FractionSize().0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 (#0):
    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\;
    \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
    \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
    \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= \Posit32::SetOne(UInt32,UInt16).0._Finished\;
    \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16) start
    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) start
    -- Signal connections for Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 (#0):
    \Boolean Quire::op_Equality(Quire,Quire).0._Started\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\;
    \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\;
    \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0._Finished\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.return\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsNaN() start
    -- Signal connections for Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 (#0):
    \Posit32::IsNaN().0._Started\ <= \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Started.0\;
    \Posit32::IsNaN().0.this.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().this.parameter.Out.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN()._Finished.0\ <= \Posit32::IsNaN().0._Finished\;
    \Posit32::FusedSum(Posit32[],Quire).0.Posit32::IsNaN().return.0\ <= \Posit32::IsNaN().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsNaN() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) start
    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.return\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.return\;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit() start
    -- Signal connections for Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::FractionWithHiddenBit().0._Started\ <= \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\;
    \Posit32::FractionWithHiddenBit().0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\;
    \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\ <= \Posit32::FractionWithHiddenBit().0._Finished\;
    \Quire Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\ <= \Posit32::FractionWithHiddenBit().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16) start
    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor() start
    -- Signal connections for Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::CalculateScaleFactor().0._Started\ <= \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Started.0\;
    \Posit32::CalculateScaleFactor().0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().this.parameter.Out.0\;
    \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor()._Finished.0\ <= \Posit32::CalculateScaleFactor().0._Finished\;
    \Quire Posit32::op_Explicit(Posit32).0.Posit32::CalculateScaleFactor().return.0\ <= \Posit32::CalculateScaleFactor().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ else (others => '0');
    \ReadEnable\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1*}]-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com

    -- Hast_IP's simple interface makes it suitable to plug it into any hardware implementation. The meaning and usage of the
    -- ports are as below:
    -- * MemberId: Each transformed .NET hardware entry point member (i.e. methods that are configured to be available to be
    --             called from the host PC) has a unique zero-based numeric ID. When selecting which one to execute this ID
    --             should be used.
    -- * Started: Indicates whether the execution of a given hardware entry point member is started. Used in the following way:
    --     1. Started is set to TRUE by the consuming framework, after which the execution of the given member starts
    --        internally. The Finished port will be initially set to FALSE.
    --     2. Once the execution is finished, the Finished port will be set to TRUE.
    --     3. The consuming framework sets Started to FALSE, after which Finished will also be set to FALSE.
    -- * Finished: Indicates whether the execution of a given hardware entry point member is complete. See the documentation of
    --             the Started port above on how it is used.
    -- * Reset: Synchronous reset.
    -- * Clock: The main clock.
    -- * DataIn: Data read out from the memory (usually on-board DDR RAM, but depends on the framework) should be assigned to
    --           this port by the framework. The width of this port is always 32b, independent of the hardware platform (if the
    --           bus to the memory is wider then caching needs to be implemented in the framework to make use of it). Inputs of
    --           the algorithm implemented in Hast_IP all come through this port.
    -- * DataOut: Data to be written to the memory is assigned to this port. The width of this port is always 32b, independent
    --            of the hardware platform (if the bus to the memory is wider then caching needs to be implemented in the
    --            framework to make use of it). Outputs of the algorithm implemented in Hast_IP all go through this port.
    -- * CellIndex: Zero-based index of the SimpleMemory memory cell currently being read or written. Transformed code in
    --              Hastlayer can access memory in a simplified fashion by addressing 32b "cells", the accessible physical
    --              memory space being divided up in such individually addressable cells.
    -- * ReadEnable: Indicates whether a memory read operation is initiated. The process of a memory read is as following:
    --     1. ReadEnable is FALSE by default. It's set to TRUE when a memory read is started. CellIndex is set to the index of
    --        the memory cell to be read out.
    --     2. Waiting for ReadsDone to be TRUE.
    --     3. Once ReadsDone is TRUE, data from DataIn will be read out and ReadEnable set to FALSE.
    -- * WriteEnable: Indicates whether a memory write operation is initiated. The process of a memory write is as following:
    --     1. WriteEnable is FALSE by default. It's set to TRUE when a memory write is started. CellIndex is set to the index
    --        of the memory cell to be written and the output data is assigned to DataOut.
    --     2. Waiting for WritesDone to be TRUE.
    --     3. Once WritesDone is TRUE, WriteEnable is set to FALSE.
    -- * ReadsDone: Indicates whether a memory read operation is completed.
    -- * WritesDone: Indicates whether a memory write operation is completed.

end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions, properties) in .NET a state machine was generated. Each state machine's name
    --   corresponds to the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic
    --   operations (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states
    --   can take more than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- When put on variables and signals this attribute instructs Vivado not to merge them, thus allowing us to define multi-cycle paths properly.
    attribute dont_touch: string;


    -- Custom inter-dependent type declarations start
    type \Lombiq.Arithmetics.Posit32\ is record 
        \IsNull\: boolean;
        \PositBits\: unsigned(31 downto 0);
    end record;
    type \Lombiq.Arithmetics.Posit32_Array\ is array (integer range <>) of \Lombiq.Arithmetics.Posit32\;
    type \unsigned64_Array\ is array (integer range <>) of unsigned(63 downto 0);
    type \Lombiq.Arithmetics.Quire\ is record 
        \IsNull\: boolean;
        \Size\: unsigned(15 downto 0);
        \SegmentCount\: unsigned(15 downto 0);
        \Segments\: \unsigned64_Array\(0 to 7);
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._States\ is (
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\, 
        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\);
    -- Signals:
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\: boolean := false;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32,Boolean).0._States\ is (
        \Posit32::.ctor(UInt32,Boolean).0._State_0\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_1\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32,Boolean).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(Quire).0._States\ is (
        \Posit32::.ctor(Quire).0._State_0\, 
        \Posit32::.ctor(Quire).0._State_1\, 
        \Posit32::.ctor(Quire).0._State_2\, 
        \Posit32::.ctor(Quire).0._State_3\, 
        \Posit32::.ctor(Quire).0._State_4\, 
        \Posit32::.ctor(Quire).0._State_5\, 
        \Posit32::.ctor(Quire).0._State_6\, 
        \Posit32::.ctor(Quire).0._State_7\, 
        \Posit32::.ctor(Quire).0._State_8\, 
        \Posit32::.ctor(Quire).0._State_9\, 
        \Posit32::.ctor(Quire).0._State_10\, 
        \Posit32::.ctor(Quire).0._State_11\, 
        \Posit32::.ctor(Quire).0._State_12\, 
        \Posit32::.ctor(Quire).0._State_13\, 
        \Posit32::.ctor(Quire).0._State_14\, 
        \Posit32::.ctor(Quire).0._State_15\, 
        \Posit32::.ctor(Quire).0._State_16\, 
        \Posit32::.ctor(Quire).0._State_17\, 
        \Posit32::.ctor(Quire).0._State_18\, 
        \Posit32::.ctor(Quire).0._State_19\, 
        \Posit32::.ctor(Quire).0._State_20\, 
        \Posit32::.ctor(Quire).0._State_21\, 
        \Posit32::.ctor(Quire).0._State_22\, 
        \Posit32::.ctor(Quire).0._State_23\, 
        \Posit32::.ctor(Quire).0._State_24\);
    -- Signals:
    Signal \Posit32::.ctor(Quire).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Quire).0.q.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0._Started\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Quire).0.q.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\: unsigned(63 downto 0) := to_unsigned(0, 64);
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32).0._States\ is (
        \Posit32::.ctor(UInt32).0._State_0\, 
        \Posit32::.ctor(UInt32).0._State_1\, 
        \Posit32::.ctor(UInt32).0._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(Int32).0._States\ is (
        \Posit32::.ctor(Int32).0._State_0\, 
        \Posit32::.ctor(Int32).0._State_1\, 
        \Posit32::.ctor(Int32).0._State_2\, 
        \Posit32::.ctor(Int32).0._State_3\);
    -- Signals:
    Signal \Posit32::.ctor(Int32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ is (
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_52\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\);
    -- Signals:
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Posit32::FusedSum(Posit32[],Quire).0._States\ is (
        \Posit32::FusedSum(Posit32[],Quire).0._State_0\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_1\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_2\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_3\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_4\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_5\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_6\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_7\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_8\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_9\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_10\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_11\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_12\, 
        \Posit32::FusedSum(Posit32[],Quire).0._State_13\);
    -- Signals:
    Signal \Posit32::FusedSum(Posit32[],Quire).0._Finished\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0._Started\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
    Signal \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Quire Posit32::op_Explicit(Posit32).0._States\ is (
        \Quire Posit32::op_Explicit(Posit32).0._State_0\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_1\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_2\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_3\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_4\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_5\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_6\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_7\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_8\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_9\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_10\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_11\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_12\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_13\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_14\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_15\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_16\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_17\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_18\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_19\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_20\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_21\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_22\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_23\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_24\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_25\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_26\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_27\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_28\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_29\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_30\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_31\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_32\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_33\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_34\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_35\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_36\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_37\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_38\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_39\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_40\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_41\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_42\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_43\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_44\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_45\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_46\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_47\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_48\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_49\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_50\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_51\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_52\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_53\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_54\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_55\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_56\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_57\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_58\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_59\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_60\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_61\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_62\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_63\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_64\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_65\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_66\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_67\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_68\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_69\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_70\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_71\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_72\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_73\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_74\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_75\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_76\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_77\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_78\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_79\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_80\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_81\, 
        \Quire Posit32::op_Explicit(Posit32).0._State_82\);
    -- Signals:
    Signal \Quire Posit32::op_Explicit(Posit32).0._Finished\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0._Started\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\: boolean := false;
    Signal \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 declarations start
    -- State machine states:
    type \Quire::.ctor(UInt64[],UInt16).0._States\ is (
        \Quire::.ctor(UInt64[],UInt16).0._State_0\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_1\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_2\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_3\, 
        \Quire::.ctor(UInt64[],UInt16).0._State_4\);
    -- Signals:
    Signal \Quire::.ctor(UInt64[],UInt16).0._Finished\: boolean := false;
    Signal \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire::.ctor(UInt64[],UInt16).0._Started\: boolean := false;
    Signal \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Quire::.ctor(UInt32,UInt16).0._States\ is (
        \Quire::.ctor(UInt32,UInt16).0._State_0\, 
        \Quire::.ctor(UInt32,UInt16).0._State_1\, 
        \Quire::.ctor(UInt32,UInt16).0._State_2\, 
        \Quire::.ctor(UInt32,UInt16).0._State_3\, 
        \Quire::.ctor(UInt32,UInt16).0._State_4\, 
        \Quire::.ctor(UInt32,UInt16).0._State_5\, 
        \Quire::.ctor(UInt32,UInt16).0._State_6\, 
        \Quire::.ctor(UInt32,UInt16).0._State_7\, 
        \Quire::.ctor(UInt32,UInt16).0._State_8\);
    -- Signals:
    Signal \Quire::.ctor(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Quire Quire::op_Addition(Quire,Quire).0._States\ is (
        \Quire Quire::op_Addition(Quire,Quire).0._State_0\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_1\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_2\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_3\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_4\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_5\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_6\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_7\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_8\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_9\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_10\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_11\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_12\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_13\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_14\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_15\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_16\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_17\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_18\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_19\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_20\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_21\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_22\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_23\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_24\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_25\, 
        \Quire Quire::op_Addition(Quire,Quire).0._State_26\);
    -- Signals:
    Signal \Quire Quire::op_Addition(Quire,Quire).0._Finished\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0._Started\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_Addition(Quire,UInt32).0._States\ is (
        \Quire Quire::op_Addition(Quire,UInt32).0._State_0\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_1\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_2\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_3\, 
        \Quire Quire::op_Addition(Quire,UInt32).0._State_4\);
    -- Signals:
    Signal \Quire Quire::op_Addition(Quire,UInt32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0._Started\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\: boolean := false;
    Signal \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Quire Quire::op_OnesComplement(Quire).0._States\ is (
        \Quire Quire::op_OnesComplement(Quire).0._State_0\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_1\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_2\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_3\, 
        \Quire Quire::op_OnesComplement(Quire).0._State_4\);
    -- Signals:
    Signal \Quire Quire::op_OnesComplement(Quire).0._Finished\: boolean := false;
    Signal \Quire Quire::op_OnesComplement(Quire).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_OnesComplement(Quire).0._Started\: boolean := false;
    Signal \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \Boolean Quire::op_Equality(Quire,Quire).0._States\ is (
        \Boolean Quire::op_Equality(Quire,Quire).0._State_0\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_1\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_2\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_3\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_4\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_5\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_6\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_7\, 
        \Boolean Quire::op_Equality(Quire,Quire).0._State_8\);
    -- Signals:
    Signal \Boolean Quire::op_Equality(Quire,Quire).0._Finished\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.return\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0._Started\: boolean := false;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_RightShift(Quire,Int32).0._States\ is (
        \Quire Quire::op_RightShift(Quire,Int32).0._State_0\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_1\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_2\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_3\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_4\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_5\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_6\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_7\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_8\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_9\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_10\, 
        \Quire Quire::op_RightShift(Quire,Int32).0._State_11\);
    -- Signals:
    Signal \Quire Quire::op_RightShift(Quire,Int32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0._Started\: boolean := false;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations start
    -- State machine states:
    type \Quire Quire::op_LeftShift(Quire,Int32).0._States\ is (
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\, 
        \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\);
    -- Signals:
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.return\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0._Started\: boolean := false;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.Quire\;
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
    Signal \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 declarations end


    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \UInt64 Quire::op_Explicit(Quire).0._States\ is (
        \UInt64 Quire::op_Explicit(Quire).0._State_0\, 
        \UInt64 Quire::op_Explicit(Quire).0._State_1\, 
        \UInt64 Quire::op_Explicit(Quire).0._State_2\);
    -- Signals:
    Signal \UInt64 Quire::op_Explicit(Quire).0._Finished\: boolean := false;
    Signal \UInt64 Quire::op_Explicit(Quire).0.return\: unsigned(63 downto 0) := to_unsigned(0, 64);
    Signal \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \UInt64 Quire::op_Explicit(Quire).0._Started\: boolean := false;
    Signal \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations start
    -- State machine states:
    type \UInt32 Quire::op_Explicit(Quire).0._States\ is (
        \UInt32 Quire::op_Explicit(Quire).0._State_0\, 
        \UInt32 Quire::op_Explicit(Quire).0._State_1\, 
        \UInt32 Quire::op_Explicit(Quire).0._State_2\);
    -- Signals:
    Signal \UInt32 Quire::op_Explicit(Quire).0._Finished\: boolean := false;
    Signal \UInt32 Quire::op_Explicit(Quire).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\: \Lombiq.Arithmetics.Quire\;
    Signal \UInt32 Quire::op_Explicit(Quire).0._Started\: boolean := false;
    Signal \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\: \Lombiq.Arithmetics.Quire\;
    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._States\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\: \Lombiq.Arithmetics.Posit32\;
        attribute dont_touch of \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\: Variable is "true";
        attribute dont_touch of \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\ := (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 64);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 64);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\ := false;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\ := (others => '0');
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
            else 
                case \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ is 
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ = true) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ = true) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new Posit32[160];
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Quire quire;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32 objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98 = new Posit32 (0);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\.\IsNull\ := false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- quire = Posit32.op_Explicit (objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objectde41e31d213f26bcb14dc4059ca0ea22b32147dbfb27f3d69d5ff482204eea98\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num / 160u;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_6\ => 
                        -- Waiting for the result to appear in \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ / to_unsigned(160, 32);
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_7\ => 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((long)(num - num / 160u * 160u) != 0L) {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_8\ => 
                        -- Waiting for the result to appear in \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(9, 32)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ / to_unsigned(160, 32);
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_9\ => 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1\ * to_unsigned(160, 32), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\ := signed(SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\ - \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.2\, 64));
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.3\) /= to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.

                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.4\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\ => 
                        -- State after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num3) < (long)(num2)) {
                        -- 	int num4;
                        -- 	num4 = 0;
                        -- 	while (num4 < 160) {
                        -- 		Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                        -- 		if (((long)(num3 * 160 + num4) < (long)(num))) {
                        -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- 		} else {
                        -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- 		}
                        -- 		array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                        -- 		num4 = num4 + 1;
                        -- 	}
                        -- 	quire = Posit32.FusedSum (array, quire);
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\ => 
                        -- True branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (uint)((long)(num2) + 1L);
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\), 64)) + to_signed(1, 64)), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.5\);
                        -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_10\.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_12\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\ => 
                        -- Repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.
                        -- The while loop's condition:
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\ := SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\), 64) < signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num2\), 64));
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num4;
                            -- 	num4 = 0;
                            -- 	while (num4 < 160) {
                            -- 		Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 		if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 		} else {
                            -- 			conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 		}
                            -- 		array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 		num4 = num4 + 1;
                            -- 	}
                            -- 	quire = Posit32.FusedSum (array, quire);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num4 < 160) {
                            -- 	Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 	if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 	} else {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 	}
                            -- 	array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_14\ => 
                        -- State after the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc = new Posit32 (quire);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\ => 
                        -- Repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\.
                        -- The while loop's condition:
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ < to_signed(160, 32);
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.7\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 	if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- 	} else {
                            -- 		conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- 	}
                            -- 	array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32 conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (((long)(num3 * 160 + num4) < (long)(num))) {
                            -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                            -- } else {
                            -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                            -- }
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ * to_signed(160, 32), 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_16\ => 
                        -- State after the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- quire = Posit32.FusedSum (array, quire);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.8\ + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\, 64);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\ := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.9\) < signed(SmartResize((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num\), 64));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\.
                        --     * The false branch starts in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\ and ends in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\.
                        --     * Execution after either branch will continue in the following state: \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\.

                        if ((\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.10\)) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\;
                        else 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.616
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\ => 
                        -- State after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- array [num4] = (conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de);
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\(to_integer(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\)) := (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\);
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num4 + 1;
                        -- 
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ + to_signed(1, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.14\;
                        -- Returning to the repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\ if the loop wasn't exited with a state change.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_19\ => 
                        -- True branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (memory.ReadUInt32 (1 + num3 * 160 + num4), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\ := SmartResize(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ * to_signed(160, 32), 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ := to_signed(1, 32) + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.11\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.12\ + \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num4\;
                        -- Begin SimpleMemory read.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.13\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_21\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= ConvertStdLogicVectorToUInt32(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.dataIn.1\);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_22\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_23\ => 
                        -- False branch of the if-else started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de = new Posit32 (0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\IsNull\ := false;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.conditional94b9b3e820e16b464845c81b40c912b932f547f4b5b14b3e575c556c5c62b2de\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_17\.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_24\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.array\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + 1;
                            -- 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ + to_signed(1, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.num3\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.15\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_11\ if the loop wasn't exited with a state change.
                            if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_25\) then 
                                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire)
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ = \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.quire\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 (0, objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc.PositBits);
                            -- 
                            -- Begin SimpleMemory write.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.objecte5d64413f908c4801ae1d97bed6220dfab866e5fa3ea4e0d55745abc26bd9afc\.\PositBits\);
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_27\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State\ := \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine start
    \Posit32::.ctor(UInt32,Boolean).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32,Boolean).0._State\: \Posit32::.ctor(UInt32,Boolean).0._States\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\: boolean := false;
        Variable \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                \Posit32::.ctor(UInt32,Boolean).0.bits\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := false;
                \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32,Boolean).0._State\ is 
                    when \Posit32::.ctor(UInt32,Boolean).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32,Boolean).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_2\ => 
                        \Posit32::.ctor(UInt32,Boolean).0.this\ := \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.bits\ := \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6 = bits;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\ := \Posit32::.ctor(UInt32,Boolean).0.bits\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = (conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6);
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.this\.\PositBits\ := (\Posit32::.ctor(UInt32,Boolean).0.conditional07306ef17ce6eacdbdd521687c7db8bbabd2dc9ca02b65fce7cdbd581ebb7be6\);
                        \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 state machine start
    \Posit32::.ctor(Quire).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Quire).0._State\: \Posit32::.ctor(Quire).0._States\ := \Posit32::.ctor(Quire).0._State_0\;
        Variable \Posit32::.ctor(Quire).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Quire).0.q\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.signBit\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.num2\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.1\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.return.2\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.3\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.4\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.return.6\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.7\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.8\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::.ctor(Quire).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.9\: boolean := false;
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Quire).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.9\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::.ctor(Quire).0.return.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Quire).0.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Quire).0._Finished\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_0\;
                \Posit32::.ctor(Quire).0.signBit\ := false;
                \Posit32::.ctor(Quire).0.num\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.num2\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.return.1\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.binaryOperationResult.0\ := false;
                \Posit32::.ctor(Quire).0.return.5\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.binaryOperationResult.1\ := false;
                \Posit32::.ctor(Quire).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.return.8\ := to_unsigned(0, 64);
                \Posit32::.ctor(Quire).0.num3\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.4\ := false;
                \Posit32::.ctor(Quire).0.num4\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.num5\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.6\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.9\ := false;
                \Posit32::.ctor(Quire).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit32::.ctor(Quire).0.binaryOperationResult.11\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.return.10\ := to_unsigned(0, 32);
                \Posit32::.ctor(Quire).0.return.11\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Quire).0._State\ is 
                    when \Posit32::.ctor(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Quire).0._Started\ = true) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Quire).0._Started\ = true) then 
                            \Posit32::.ctor(Quire).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Quire).0._Finished\ <= false;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Quire).0.this.parameter.Out\ <= \Posit32::.ctor(Quire).0.this\;
                        \Posit32::.ctor(Quire).0.q.parameter.Out\ <= \Posit32::.ctor(Quire).0.q\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_2\ => 
                        \Posit32::.ctor(Quire).0.this\ := \Posit32::.ctor(Quire).0.this.parameter.In\;
                        \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.q.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::.ctor(Quire).0.this\.\PositBits\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = false;
                        -- 
                        \Posit32::.ctor(Quire).0.signBit\ := false;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 511;
                        -- 
                        \Posit32::.ctor(Quire).0.num\ := to_signed(511, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- ulong num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.0\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.0\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.1\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.0\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (num2 >= 9223372036854775808uL) {
                            -- 	q = Quire.op_OnesComplement (q);
                            -- 	q = Quire.op_Addition (q, 1u);
                            -- 	signBit = true;
                            -- }
                            -- 
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Posit32::.ctor(Quire).0.binaryOperationResult.0\ := \Posit32::.ctor(Quire).0.num2\ >= "1000000000000000000000000000000000000000000000000000000000000000";

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_6\ and ends in state \Posit32::.ctor(Quire).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_5\.

                            if (\Posit32::.ctor(Quire).0.binaryOperationResult.0\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2999
                    when \Posit32::.ctor(Quire).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	q = Quire.op_OnesComplement (q);
                        -- 	q = Quire.op_Addition (q, 1u);
                        -- 	signBit = true;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- q = Quire.op_OnesComplement (q);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.2\ := \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- q = Quire.op_Addition (q, 1u);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.3\ := \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- signBit = true;
                            -- 
                            \Posit32::.ctor(Quire).0.signBit\ := true;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_4\.
                            if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_8\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.4\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.4\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.5\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.4\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2 < 9223372036854775808uL) {
                            -- 	q = Quire.op_LeftShift (q, 1);
                            -- 	num = num - 1;
                            -- 	num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_11\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\.
                        -- The while loop's condition:
                        -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                        \Posit32::.ctor(Quire).0.binaryOperationResult.1\ := \Posit32::.ctor(Quire).0.num2\ < "1000000000000000000000000000000000000000000000000000000000000000";
                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	q = Quire.op_LeftShift (q, 1);
                            -- 	num = num - 1;
                            -- 	num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- q = Quire.op_LeftShift (q, 1);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_13\;
                        else 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32::.ctor(Quire).0._State_12\ => 
                        -- State after the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num - 240;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.3\ := \Posit32::.ctor(Quire).0.num\ - to_signed(240, 32);
                        \Posit32::.ctor(Quire).0.num3\ := \Posit32::.ctor(Quire).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0) {
                        -- 	@this.PositBits = 0u;
                        -- 	return;
                        -- }
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.4\ := \Posit32::.ctor(Quire).0.num\ = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_17\ and ends in state \Posit32::.ctor(Quire).0._State_17\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_16\.

                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.4\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_17\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5903
                    when \Posit32::.ctor(Quire).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.6\ := \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num - 1;
                            -- 
                            \Posit32::.ctor(Quire).0.binaryOperationResult.2\ := \Posit32::.ctor(Quire).0.num\ - to_signed(1, 32);
                            \Posit32::.ctor(Quire).0.num\ := \Posit32::.ctor(Quire).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = Quire.op_Explicit (Quire.op_RightShift (q, 448));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(448, 32);
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::.ctor(Quire).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.7\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.7\;
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.8\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.7\ := \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            \Posit32::.ctor(Quire).0.num2\ := \Posit32::.ctor(Quire).0.return.8\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::.ctor(Quire).0._State_10\ if the loop wasn't exited with a state change.
                            if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_15\) then 
                                \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_16\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num3 / 4;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.5\ := \Posit32::.ctor(Quire).0.num3\ / to_signed(4, 32);
                        \Posit32::.ctor(Quire).0.num4\ := \Posit32::.ctor(Quire).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (uint)(num3 - num3 / 4 * 4);
                        -- 
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0.7044
                    when \Posit32::.ctor(Quire).0._State_17\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	@this.PositBits = 0u;
                        -- 	return;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 0u;
                        -- 
                        \Posit32::.ctor(Quire).0.this\.\PositBits\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- return;
                        -- 
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_12\.
                        if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_17\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_18\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(Quire).0.binaryOperationResult.6\ := \Posit32::.ctor(Quire).0.num3\ / to_signed(4, 32);
                        \Posit32::.ctor(Quire).0.binaryOperationResult.7\ := SmartResize(\Posit32::.ctor(Quire).0.binaryOperationResult.6\ * to_signed(4, 32), 32);
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.8265
                    when \Posit32::.ctor(Quire).0._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(Quire).0.binaryOperationResult.8\ := unsigned(\Posit32::.ctor(Quire).0.num3\ - \Posit32::.ctor(Quire).0.binaryOperationResult.7\);
                        \Posit32::.ctor(Quire).0.num5\ := (\Posit32::.ctor(Quire).0.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((long)(num5) < 0L) {
                        -- 	num4 = num4 - 1;
                        -- 	num5 = (uint)((long)(num5) + 4L);
                        -- }
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.9\ := signed(SmartResize((\Posit32::.ctor(Quire).0.num5\), 64)) < to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Quire).0._State_21\ and ends in state \Posit32::.ctor(Quire).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Quire).0._State_20\.

                        if (\Posit32::.ctor(Quire).0.binaryOperationResult.9\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_21\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.616
                    when \Posit32::.ctor(Quire).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Quire).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = Posit32.AssemblePositBitsWithRounding (signBit, num4, num5, Quire.op_Explicit (Quire.op_RightShift (q, 480)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.q\;
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(480, 32);
                        \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= true;
                        \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Quire).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num4 = num4 - 1;
                        -- 	num5 = (uint)((long)(num5) + 4L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = num4 - 1;
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.10\ := \Posit32::.ctor(Quire).0.num4\ - to_signed(1, 32);
                        \Posit32::.ctor(Quire).0.num4\ := \Posit32::.ctor(Quire).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (uint)((long)(num5) + 4L);
                        -- 
                        \Posit32::.ctor(Quire).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(Quire).0.num5\), 64)) + to_signed(4, 64)), 32);
                        \Posit32::.ctor(Quire).0.num5\ := (\Posit32::.ctor(Quire).0.binaryOperationResult.11\);
                        -- Going to the state after the if-else which was started in state \Posit32::.ctor(Quire).0._State_19\.
                        if (\Posit32::.ctor(Quire).0._State\ = \Posit32::.ctor(Quire).0._State_21\) then 
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7161
                    when \Posit32::.ctor(Quire).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ = \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.9\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\;
                            \Posit32::.ctor(Quire).0.q\ := \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.9\;
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire)
                        if (\Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ = \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.10\ := \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\;
                            \Posit32::.ctor(Quire).0.return.9\ := \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.signBit\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.num4\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.num5\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::.ctor(Quire).0.return.10\;
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Quire).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Quire).0.return.11\ := \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            \Posit32::.ctor(Quire).0.this\.\PositBits\ := \Posit32::.ctor(Quire).0.return.11\;
                            \Posit32::.ctor(Quire).0._State\ := \Posit32::.ctor(Quire).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine start
    \Posit32::.ctor(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32).0._State\: \Posit32::.ctor(UInt32).0._States\ := \Posit32::.ctor(UInt32).0._State_0\;
        Variable \Posit32::.ctor(UInt32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32).0._Finished\ <= false;
                \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                \Posit32::.ctor(UInt32).0.value\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32).0._State\ is 
                    when \Posit32::.ctor(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_2\ => 
                        \Posit32::.ctor(UInt32).0.this\ := \Posit32::.ctor(UInt32).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32).0.value\ := \Posit32::.ctor(UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = 0u;
                        -- 
                        \Posit32::.ctor(UInt32).0.this\.\PositBits\ := to_unsigned(0, 32);
                        \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine start
    \Posit32::.ctor(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Int32).0._State\: \Posit32::.ctor(Int32).0._States\ := \Posit32::.ctor(Int32).0._State_0\;
        Variable \Posit32::.ctor(Int32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).0.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\: \Lombiq.Arithmetics.Posit32\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Int32).0._Finished\ <= false;
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                \Posit32::.ctor(Int32).0.value\ := to_signed(0, 32);
                \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Int32).0._State\ is 
                    when \Posit32::.ctor(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Int32).0._Finished\ <= false;
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Int32).0.this.parameter.Out\ <= \Posit32::.ctor(Int32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_2\ => 
                        \Posit32::.ctor(Int32).0.this\ := \Posit32::.ctor(Int32).0.this.parameter.In\;
                        \Posit32::.ctor(Int32).0.value\ := \Posit32::.ctor(Int32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2 = new Posit32 (0u);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\;
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).0.object333ff0d0dd85e50d2c95be675373bf374482e68f690fd047fd1bd29354833ec2\ := \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48 = 0u;
                            -- 
                            \Posit32::.ctor(Int32).0.conditional68968a9a6392defd6e5a3b182fa4434bc81f526716f6e55de1b9cb4711133f48\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = 0u;
                            -- 
                            \Posit32::.ctor(Int32).0.this\.\PositBits\ := to_unsigned(0, 32);
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine start
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.35\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.36\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.37\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.38\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.39\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.40\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.41\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.42\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.43\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.44\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.45\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.46\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.47\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.48\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.49\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.50\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.51\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.52\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.53\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.54\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.55\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.56\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.57\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.58\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.59\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.60\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.61\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.62\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.63\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.64\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.35\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.36\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.37\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.38\ := to_signed(0, 64);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.39\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.40\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.41\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.42\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.43\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.44\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := to_unsigned(0, 16);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.45\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.46\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.47\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.48\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.49\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.50\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.51\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.52\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.53\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.54\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.55\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.56\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.6\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.57\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.58\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.59\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.60\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.61\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.62\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.63\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.64\ := to_unsigned(0, 32);
            else 
                case \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ is 
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\ => 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = regimeKValue;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da > 0) {
                        -- 	uint num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (uint)((1 << regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da + 1) - 1);
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 	uint bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	byte return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	byte b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = 0;
                        -- 	while ((long)(bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) != 0L) {
                        -- 		bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da >> 1;
                        -- 		b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (byte)((int)(b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) + 1);
                        -- 	}
                        -- 	return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 	return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da << 32 - (int)(return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) - 1;
                        -- 	goto Exit_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\ => 
                        -- State for the label Exit_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da.
                        -- The following section was transformed from the .NET statement below:
                        -- num = return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = 31;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = 1;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b << 32 - (int)(startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := to_signed(32, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\), 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = (bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b >> 31) & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = 1073741824u >> -regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\ := -\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := shift_right(to_unsigned(1073741824, 32), to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.0\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- Exit_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da:
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (uint)((1 << regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da + 1) - 1);
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 	uint bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	byte return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	byte b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = 0;
                        -- 	while ((long)(bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) != 0L) {
                        -- 		bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da >> 1;
                        -- 		b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (byte)((int)(b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) + 1);
                        -- 	}
                        -- 	return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 	return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da << 32 - (int)(return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) - 1;
                        -- 	goto Exit_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (uint)((1 << regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da + 1) - 1);
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ + to_signed(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := unsigned((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\) - to_signed(1, 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := SmartResize(unsigned(to_signed(0, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) != 0L) {
                        -- 	bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da >> 1;
                        -- 	b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (byte)((int)(b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\.
                        -- The while loop's condition:
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\), 64)) /= to_signed(0, 64);
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da >> 1;
                            -- 	b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (byte)((int)(b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da >> 1;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = (byte)((int)(b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) + 1);
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\);
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8704
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\ => 
                        -- State after the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\;
                        -- The following section was transformed from the .NET statement below:
                        -- return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da = num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da << 32 - (int)(return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da) - 1;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(32, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_7433aa75d94b12689bfd37b82bd6efe2336049442f0a6f7004902fab118a3d86_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\), 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ - to_signed(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- goto Exit_877cc8a4458b184cbefcdd364edb21dd8da2ca93f5d0907ebe0e479c950d39da;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\ => 
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\) and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b << 1;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) < (int)(startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) && bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b >> 31 == num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) {
                        -- 	bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b << 1;
                        -- 	b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = (byte)((int)(b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) + 1);
                        -- 	num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.7111
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\.
                        -- The while loop's condition:
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\) < signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.startingPosition_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\), 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\ => 
                        -- State after the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\;
                        -- The following section was transformed from the .NET statement below:
                        -- b = return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (int)(28 - (int)(b));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := to_signed(28, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\), 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num2 >= 0)) {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                        -- } else {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ and \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\;
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b << 1;
                            -- 	b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = (byte)((int)(b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) + 1);
                            -- 	num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b << 1;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = (byte)((int)(b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b) + 1);
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b = num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b + 1;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ + to_signed(1, 32);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2_1a2fe290ae47b1ef7ded540ce3403c2e5603c310223a0b07c1ac70a272d6301b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ if the loop wasn't exited with a state change.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\;
                            end if;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num2 < 0) {
                        -- 	uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 	if ((num2 > 28)) {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 	} else {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 	}
                        -- 	exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 	if (exponentBits < 2147483648u) {
                        -- 		uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 		if (signBit) {
                        -- 			;
                        -- 			// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 			uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 			bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 			uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 			return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 			// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		} else {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 		}
                        -- 		return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	}
                        -- 	uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 	if ((exponentBits != 2147483648u)) {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 	} else {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 	}
                        -- 	num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 	uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 	if (signBit) {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 		bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = num;
                        -- 		uint return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 		return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = (uint)((long)(~bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	} else {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 	}
                        -- 	return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits << num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9 = (exponentBits >> -num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\ := -\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.1\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional080c1e8270378fd06e215f3c8f2add99c4865c1fbe8dd647a36c0c7e2edafab9\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = fractionBits;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := SmartResize(unsigned(to_signed(0, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49) != 0L) {
                        -- 	bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 >> 1;
                        -- 	b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = (byte)((int)(b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 	if ((num2 > 28)) {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 	} else {
                        -- 		conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 	}
                        -- 	exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 	if (exponentBits < 2147483648u) {
                        -- 		uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 		if (signBit) {
                        -- 			;
                        -- 			// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 			uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 			bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 			uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 			return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 			// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		} else {
                        -- 			conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 		}
                        -- 		return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	}
                        -- 	uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 	if ((exponentBits != 2147483648u)) {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 	} else {
                        -- 		conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 	}
                        -- 	num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 	uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 	if (signBit) {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 		bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = num;
                        -- 		uint return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 		return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = (uint)((long)(~bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	} else {
                        -- 		conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 	}
                        -- 	return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num2 > 28)) {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- } else {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ > to_signed(28, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = (conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (exponentBits < 2147483648u) {
                        -- 	uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	if (signBit) {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 		uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	} else {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 	}
                        -- 	return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ < "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits >> 32 + num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9774
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791 = (exponentBits << 32 + num2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional8ec324176b3f3fcd58fd5cfa6806fcab9222414090d26d94c66a65f1e77ad791\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((exponentBits != 2147483648u)) {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- } else {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.36\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ /= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.36\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 	if (signBit) {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 		uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 		return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	} else {
                        -- 		conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 	}
                        -- 	return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 	uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- } else {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 	uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 	return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e = (uint)((long)(~bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\ := not(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.35\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.2\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.35\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_29d01fc597480c9a8978df84b3fa377f862967419a63789112fc92c8bcb8358e\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3 = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalc44e6e18dba54d497a9ebfd5cd45c62d920ed273ec5aec35f89d9d27a8e797d3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = num;
                        -- 	uint return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = (uint)((long)(~bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- } else {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + 1L));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.37\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.37\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3 = ((uint)((long)(num) + ((long)(num) & 1L)));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.38\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) and to_signed(1, 64);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.39\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.38\)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalfaf425f73af9abdd07507acc85c797211aab0cbc36083f9065056c957f27c6b3\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.39\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5632
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = num;
                        -- 	uint return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 	return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = (uint)((long)(~bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f = (uint)((long)(~bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.3\ := not(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.40\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.3\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.40\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_c365944f32d1bd43cad8b7e282704038c75bff2f7f5617940490de000fbf3f9f\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0 = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalb43e86d5d828dd5119f9f88af0ba7c790398b5cca8ee395bf1a45e5780b616e0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\.
                        -- The while loop's condition:
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.41\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\), 64)) /= to_signed(0, 64);
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.41\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 >> 1;
                            -- 	b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = (byte)((int)(b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 >> 1;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.42\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.42\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = (byte)((int)(b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49) + 1);
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.43\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.43\);
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8704
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\ => 
                        -- State after the while loop which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49 = b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((int)(return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49) - 1);
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.44\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_3938d622f1c7059e43ce720914f8dac78e0c43b14e9f57ead44226443ac08a49\), 32)) - to_signed(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.44\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc = fractionBits;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc = (ushort)num3;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc = bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc & (uint)(~(1 << (int)index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc));
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.45\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.index_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\, 32)), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.4\ := not((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.45\));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\;
                        -- Clock cycles needed to complete this state (approximation): 0.9955
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.46\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ and unsigned((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.4\));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.46\;
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_1f023f1605903ad9d771877041978dfe685eea174a0d8f4cd7264316130e8abc\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = (int)((int)(28 - num3) - (int)(b));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.47\ := to_signed(28, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.48\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.47\) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\), 32));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.48\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num4 >= 0)) {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                        -- } else {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\;
                        -- Clock cycles needed to complete this state (approximation): 0.7912
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.49\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.49\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.52\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.52\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num4 < 0) {
                        -- 	uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 	if ((32 + num4 < 0)) {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 	} else {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 	}
                        -- 	fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 	if (fractionBits >= 2147483648u) {
                        -- 		uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 		if ((fractionBits != 2147483648u)) {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 		} else {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 		}
                        -- 		num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 	}
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.53\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.53\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits << num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.50\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.50\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5244
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2 = (fractionBits >> -num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.5\ := -\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.51\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.5\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalbf654792f1ef201c91607ce88a255151da71234b0142c97b5e2a3594fec8b3f2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.51\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.963
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 	bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = num;
                        -- 	uint return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 	return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = (uint)((long)(~bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- } else {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_52\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 	if ((32 + num4 < 0)) {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 	} else {
                        -- 		conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 	}
                        -- 	fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 	if (fractionBits >= 2147483648u) {
                        -- 		uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 		if ((fractionBits != 2147483648u)) {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 		} else {
                        -- 			conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 		}
                        -- 		num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((32 + num4 < 0)) {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- } else {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- }
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.54\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.55\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.54\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.55\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = (conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (fractionBits >= 2147483648u) {
                        -- 	uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 	if ((fractionBits != 2147483648u)) {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 	} else {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 	}
                        -- 	num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.60\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ >= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.60\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits >> -(32 - num4));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.56\ := to_signed(32, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.6\ := -(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.56\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\;
                        -- Clock cycles needed to complete this state (approximation): 0.6382
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.57\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.6\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.57\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6511
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3 = (fractionBits << 32 + num4);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.58\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.59\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.58\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional0557e32b11ba8656de63af77389f74397db38458b6838b7ec71d9300b43b97b3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.59\);
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8507
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 	if ((fractionBits != 2147483648u)) {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 	} else {
                        -- 		conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 	}
                        -- 	num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((fractionBits != 2147483648u)) {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- } else {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- }
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.61\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ /= "10000000000000000000000000000000";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\.

                        if ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.61\)) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + (conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88);
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.63\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.63\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_47\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = 1;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := unsigned(to_signed(1, 32));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_50\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88 = ((uint)((long)(num) & 1L));
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.62\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\), 64)) and to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalf785b0afe4ece3e3594cd02f6b5f1982f069e1dcecb8938b5a56e565b0c79e88\ := ((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.62\));
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_48\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_51\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_52\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 	bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = num;
                        -- 	uint return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 	return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = (uint)((long)(~bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7 = (uint)((long)(~bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.7\ := not(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.bits_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.64\ := SmartResize(unsigned(signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.unaryOperationResult.7\), 64)) + to_signed(1, 64)), 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.64\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return_00ec61b3725c1170f9b7ab9dd5d6e78d0afdb6e5e0b14db5ab1e1f4e5ebb4fd7\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_53\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditional387696ad28480d9c3a30bb715ea7c994c6d6532ae1063b717c140922f7bfd34f\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_54\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 state machine start
    \Posit32::FusedSum(Posit32[],Quire).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FusedSum(Posit32[],Quire).0._State\: \Posit32::FusedSum(Posit32[],Quire).0._States\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.posits\: \Lombiq.Arithmetics.Posit32_Array\(0 to 159);
        Variable \Posit32::FusedSum(Posit32[],Quire).0.startingValue\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.1\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.2\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.return.3\: \Lombiq.Arithmetics.Quire\;
        Variable \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
                \Posit32::FusedSum(Posit32[],Quire).0.return.1\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.num\ := to_signed(0, 32);
                \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\ := false;
                \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.2\ := to_signed(0, 32);
            else 
                case \Posit32::FusedSum(Posit32[],Quire).0._State\ is 
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._Started\ = true) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._Started\ = true) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= true;
                        else 
                            \Posit32::FusedSum(Posit32[],Quire).0._Finished\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits\;
                        \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_2\ => 
                        \Posit32::FusedSum(Posit32[],Quire).0.posits\ := \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\;
                        \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Quire quire;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Quire objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011 = new Quire (1u, 512);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\IsNull\ := false;
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\Size\ := to_unsigned(0, 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\;
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(512, 32)), 16);
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- quire = Quire.op_LeftShift (objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011, 511);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(511, 32);
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.0\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.objectcca0dec009ae8ed2326a07122a465f3ec1a2db6344ea5f25f4320f84fc89c011\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.quire\ := \Posit32::FusedSum(Posit32[],Quire).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Quire.op_Equality (startingValue, quire)) {
                            -- 	return quire;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.1\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.quire\ := \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FusedSum(Posit32[],Quire).0._State_7\ and ends in state \Posit32::FusedSum(Posit32[],Quire).0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FusedSum(Posit32[],Quire).0._State_6\.

                            if (\Posit32::FusedSum(Posit32[],Quire).0.return.1\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_7\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_6\ => 
                        -- State after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.num\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num < 160) {
                        -- 	;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                        -- 	Lombiq.Arithmetics.Posit32 this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                        -- 	this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = posits [num];
                        -- 	bool return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                        -- 	return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4.PositBits == 2147483648u;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                        -- 	if (return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4) {
                        -- 		return quire;
                        -- 	}
                        -- 	startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_7\ => 
                        -- True branch of the if-else started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return quire;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return quire;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_5\.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_7\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\.
                        -- The while loop's condition:
                        \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\ := \Posit32::FusedSum(Posit32[],Quire).0.num\ < to_signed(160, 32);
                        if (\Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	;
                            -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                            -- 	Lombiq.Arithmetics.Posit32 this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                            -- 	this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = posits [num];
                            -- 	bool return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                            -- 	return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4.PositBits == 2147483648u;
                            -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                            -- 	if (return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4) {
                            -- 		return quire;
                            -- 	}
                            -- 	startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ;
                            -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Lombiq.Arithmetics.Posit32 this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = posits [num];
                            -- 
                            \Posit32::FusedSum(Posit32[],Quire).0.this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\ := \Posit32::FusedSum(Posit32[],Quire).0.posits\(to_integer(\Posit32::FusedSum(Posit32[],Quire).0.num\));
                            -- The following section was transformed from the .NET statement below:
                            -- bool return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4 = this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4.PositBits == 2147483648u;
                            -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                            -- 
                            -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                            \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\ := \Posit32::FusedSum(Posit32[],Quire).0.this_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\.\PositBits\ = "10000000000000000000000000000000";
                            \Posit32::FusedSum(Posit32[],Quire).0.return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\ := \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4) {
                            -- 	return quire;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FusedSum(Posit32[],Quire).0._State_11\ and ends in state \Posit32::FusedSum(Posit32[],Quire).0._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FusedSum(Posit32[],Quire).0._State_10\.

                            if (\Posit32::FusedSum(Posit32[],Quire).0.return_5a35665db2c694b12f0378313997a8c2bfbceb9e55e0f30abbc5b3e06d2ec2d4\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_11\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_10\;
                            end if;
                        else 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5393
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_9\ => 
                        -- State after the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return startingValue;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- startingValue = Quire.op_Addition (startingValue, Posit32.op_Explicit (posits [num]));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits\(to_integer(\Posit32::FusedSum(Posit32[],Quire).0.num\));
                        \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FusedSum(Posit32[],Quire).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return quire;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return quire;
                        -- 
                        \Posit32::FusedSum(Posit32[],Quire).0.return\ <= \Posit32::FusedSum(Posit32[],Quire).0.quire\;
                        \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_8\.
                        if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_11\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.2\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.return.2\;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= true;
                            \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FusedSum(Posit32[],Quire).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.3\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.return.2\ := \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\;
                            \Posit32::FusedSum(Posit32[],Quire).0.startingValue\ := \Posit32::FusedSum(Posit32[],Quire).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.2\ := \Posit32::FusedSum(Posit32[],Quire).0.num\ + to_signed(1, 32);
                            \Posit32::FusedSum(Posit32[],Quire).0.num\ := \Posit32::FusedSum(Posit32[],Quire).0.binaryOperationResult.2\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32::FusedSum(Posit32[],Quire).0._State_6\ if the loop wasn't exited with a state change.
                            if (\Posit32::FusedSum(Posit32[],Quire).0._State\ = \Posit32::FusedSum(Posit32[],Quire).0._State_13\) then 
                                \Posit32::FusedSum(Posit32[],Quire).0._State\ := \Posit32::FusedSum(Posit32[],Quire).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine start
    \Quire Posit32::op_Explicit(Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Posit32::op_Explicit(Posit32).0._State\: \Quire Posit32::op_Explicit(Posit32).0._States\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.x\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.0\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.18\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.19\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.20\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.23\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.25\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.26\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.quire\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.29\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.30\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.31\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.32\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.35\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.36\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.37\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.38\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.39\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.40\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.41\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.42\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.43\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.44\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.45\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.46\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Quire Posit32::op_Explicit(Posit32).0.regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.47\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.48\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.49\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.50\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.51\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.52\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.53\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.54\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.55\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.56\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.57\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.58\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.59\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.60\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.61\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.62\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.63\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.64\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.65\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.66\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.67\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.68\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.69\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.70\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.71\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.72\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.73\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.74\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.75\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.76\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.77\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.78\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.79\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.80\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.81\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.82\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.83\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.84\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.85\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.86\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.87\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.88\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.89\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.90\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.91\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.92\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.93\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.94\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.95\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.96\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.97\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.98\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.99\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.100\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.101\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.102\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.103\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.104\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.105\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.106\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.107\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.108\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.109\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.110\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.111\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.112\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.113\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.114\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.115\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.116\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.117\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.1\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.118\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.119\: boolean := false;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.2\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Posit32::op_Explicit(Posit32).0.return.3\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
                \Quire Posit32::op_Explicit(Posit32).0.return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Posit32::op_Explicit(Posit32).0.return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.0\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.15\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.16\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.18\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.19\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.20\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.1\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.22\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.23\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.24\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.25\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.26\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.29\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.30\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.2\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.31\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.32\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.35\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.36\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.37\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.38\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.39\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.40\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.41\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.42\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.43\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.44\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.45\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.46\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.47\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.48\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.3\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.49\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.50\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.51\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.52\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.53\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.54\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.55\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.56\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.57\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.58\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.59\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.60\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.61\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.62\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.4\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.63\ := to_signed(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.64\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.65\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.66\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.5\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.67\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.68\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.69\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.6\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.70\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.71\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.72\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.73\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.74\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.75\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.76\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.77\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.78\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.79\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.80\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.81\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.82\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.83\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.84\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.85\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.86\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.87\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.88\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.89\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.90\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.91\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.92\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.7\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.93\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.94\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.95\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.96\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.97\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.98\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.99\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.100\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.101\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.102\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.103\ := to_unsigned(0, 8);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.104\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.105\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.106\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.107\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.108\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.109\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.110\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.111\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.112\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.113\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.114\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.115\ := to_signed(0, 16);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.116\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.117\ := to_signed(0, 32);
                \Quire Posit32::op_Explicit(Posit32).0.return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\ := false;
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.118\ := to_signed(0, 64);
                \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.119\ := false;
            else 
                case \Quire Posit32::op_Explicit(Posit32).0._State\ is 
                    when \Quire Posit32::op_Explicit(Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= true;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_2\ => 
                        \Quire Posit32::op_Explicit(Posit32).0.x\ := \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825 = x;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\ := \Quire Posit32::op_Explicit(Posit32).0.x\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825 = this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825.PositBits == 2147483648u;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := \Quire Posit32::op_Explicit(Posit32).0.this_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\.\PositBits\ = "10000000000000000000000000000000";
                        \Quire Posit32::op_Explicit(Posit32).0.return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825) {
                        -- 	Quire objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36;
                        -- 	objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36 = new Quire (1u, 512);
                        -- 	return Quire.op_LeftShift (objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36, 511);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_4\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_3\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_2cf6f4dc9cc2c5c30dc9a398865472e185402e2a019e7ac16cc5146e4f812825\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Quire Posit32::op_Explicit(Posit32).0._State_3\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = x;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.x\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (long)((this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) {
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_8\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_8\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_9\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_7\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_8\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_4\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Quire objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36;
                        -- 	objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36 = new Quire (1u, 512);
                        -- 	return Quire.op_LeftShift (objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36, 511);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Quire objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36 = new Quire (1u, 512);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\.\IsNull\ := false;
                        \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\.\Size\ := to_unsigned(0, 16);
                        \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\;
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(512, 32)), 16);
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\ := \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Quire.op_LeftShift (objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36, 511);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= to_signed(511, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.0\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.objectced560230eaa29c09194274d79f0f04aeb95c7628d7ce6b644348e51440adb36\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.return\ <= \Quire Posit32::op_Explicit(Posit32).0.return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_1\;
                            -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_2\.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_6\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_7\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\);
                        -- The following section was transformed from the .NET statement below:
                        -- int num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.bits_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 31;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d >> 31) & 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\) and to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) < (int)(startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) && bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d >> 31 == num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) {
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << 1;
                        -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1);
                        -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Quire Posit32::op_Explicit(Posit32).0._State_8\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_3\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_8\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_9\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.0\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.0\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_3\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_9\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_10\ => 
                        -- Repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_7\.
                        -- The while loop's condition:
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ := (\Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\) < signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\ = \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Quire Posit32::op_Explicit(Posit32).0._State_11\ => 
                        -- State after the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 32 - ((int)(return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 2 + 2);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.15\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.16\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.15\ + to_signed(2, 32), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.17\ := to_signed(32, 32) - (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.16\);
                        \Quire Posit32::op_Explicit(Posit32).0.num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.17\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d > 0)) {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = ((uint)num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- } else {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 0u;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Quire Posit32::op_Explicit(Posit32).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ and \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\;
                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << 1;
                            -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1);
                            -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1);
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 32)) + to_signed(1, 32)), 8);
                            \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d + 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.14\ := \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ + to_signed(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.14\;
                            -- Returning to the repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_7\ if the loop wasn't exited with a state change.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_12\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_10\;
                            end if;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Quire Posit32::op_Explicit(Posit32).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.18\ := \Quire Posit32::op_Explicit(Posit32).0.num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_15\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_15\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_16\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_14\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.18\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_15\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Posit32::op_Explicit(Posit32).0._State_14\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.return_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (long)((this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.19\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.20\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.19\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.20\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) {
                        -- 	conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 	uint return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_18\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_18\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_19\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_17\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_21b5a692eb0046a4533a6168005ecc761e6f077932e1ccbe536f04342ca83a96_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_18\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_15\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = ((uint)num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = ((uint)num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (unsigned(\Quire Posit32::op_Explicit(Posit32).0.num_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_13\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_15\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_16\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 0u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_c19fcd84e7300e48def129d35eb60d7e89695194c445b7224655f2d93aee9a18_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_13\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_16\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_17\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (\Quire Posit32::op_Explicit(Posit32).0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d << (int)(32L - (long)(num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d)) >> (int)(32L - (long)(num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d));
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.22\ := SmartResize(to_signed(32, 64) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.23\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.num2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, to_integer(unsigned(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.22\), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.9142
                    when \Quire Posit32::op_Explicit(Posit32).0._State_18\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_14\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_18\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_19\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 	uint return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.this_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (uint)((long)(~bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.1\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.21\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.1\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.21\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalec88d618fdb8d955a353066f43af5ab5cc70c1913e02ecac14c3590c5ee9802e_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.return_0f83a95a96264a09c6a0ba9cb9c99ad3bd58dcf2757ca4c9081ded388086ca02_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_14\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_19\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.24\ := SmartResize(to_signed(32, 64) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Quire Posit32::op_Explicit(Posit32).0._State_21\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.25\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.23\, to_integer(unsigned(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.24\), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.25\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((long)(num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d) == 0L)) {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 1u;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 	uint bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	ushort index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (ushort)num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	uint return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d | (uint)(1 << (int)index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.26\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\), 64)) = to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_23\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_23\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_24\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_24\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_22\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.26\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_23\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9328
                    when \Quire Posit32::op_Explicit(Posit32).0._State_22\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- array [0] = return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.array\(to_integer(to_signed(0, 32))) := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.return_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, 64);
                        -- The following section was transformed from the .NET statement below:
                        -- Quire quire;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- quire = new Quire (array, 0);
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Posit32::op_Explicit(Posit32).0.quire\.\IsNull\ := false;
                        \Quire Posit32::op_Explicit(Posit32).0.quire\.\Size\ := to_unsigned(0, 16);
                        \Quire Posit32::op_Explicit(Posit32).0.quire\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Posit32::op_Explicit(Posit32).0.quire\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.array\;
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_23\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := to_unsigned(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_21\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_23\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_24\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 	uint bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	ushort index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (ushort)num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	uint return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 	return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d | (uint)(1 << (int)index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 	conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.bits_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = (ushort)num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.num_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d | (uint)(1 << (int)index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.27\ := unsigned(shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.index_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\, 32)), 5)))));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.28\ := \Quire Posit32::op_Explicit(Posit32).0.bits_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ or (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.27\);
                        \Quire Posit32::op_Explicit(Posit32).0.return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.28\;
                        -- The following section was transformed from the .NET statement below:
                        -- conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d = return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional228b1055e46d1363e308fb550cd6f22a83de28e2e3a141858be8dfd0e89f8fd2_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\ := \Quire Posit32::op_Explicit(Posit32).0.return_4ddc9c08deb685e334f47c2f9be93813800f005383f7490b26a659039cd2b9c5_310be957880a463aabf2b9e3fe034bc10c979fe352d91dac9b2227df64d3429d\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_21\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_24\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.663
                    when \Quire Posit32::op_Explicit(Posit32).0._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.array\ := \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- Lombiq.Arithmetics.Posit32 this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = x;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.x\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Lombiq.Arithmetics.Posit32 this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                            -- The following section was transformed from the .NET statement below:
                            -- bool return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (long)((this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits & 0x80000000u)) == 0L;
                            -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                            -- 
                            -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.29\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\.\PositBits\ and "10000000000000000000000000000000", 64));
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.30\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.29\)), 64)) = to_signed(0, 64);
                            \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.30\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) {
                            -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                            -- } else {
                            -- 	;
                            -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                            -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                            -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1L);
                            -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                            -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_27\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_27\.
                            --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_28\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_28\.
                            --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_26\.

                            if (\Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_27\;
                            else 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_28\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_26\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\);
                        -- The following section was transformed from the .NET statement below:
                        -- int num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.bits_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 31;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.32\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.32\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 >> 31) & 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.33\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.34\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.33\) and to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.34\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.35\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.35\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) < (int)(startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) && bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 >> 31 == num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) {
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 << 1;
                        -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1);
                        -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Quire Posit32::op_Explicit(Posit32).0._State_27\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_25\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_27\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_28\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                        -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.this_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.2\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.31\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.2\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.31\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_25\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_28\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_29\ => 
                        -- Repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_26\.
                        -- The while loop's condition:
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.36\ := (\Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\) < signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.37\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.38\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.37\ = \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Quire Posit32::op_Explicit(Posit32).0._State_30\ => 
                        -- State after the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                        -- The following section was transformed from the .NET statement below:
                        -- num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 32 - ((int)(return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 2 + 2);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.43\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.44\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.43\ + to_signed(2, 32), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.45\ := to_signed(32, 32) - (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.44\);
                        \Quire Posit32::op_Explicit(Posit32).0.num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.45\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 > 0)) {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = ((uint)num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02);
                        -- } else {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 0u;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_32\;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Quire Posit32::op_Explicit(Posit32).0._State_31\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.39\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.36\ and \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.38\;
                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.39\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 << 1;
                            -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1);
                            -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 << 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.40\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.40\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + 1);
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.41\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\), 32)) + to_signed(1, 32)), 8);
                            \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.41\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 + 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.42\ := \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ + to_signed(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.42\;
                            -- Returning to the repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_26\ if the loop wasn't exited with a state change.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_31\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_29\;
                            end if;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Quire Posit32::op_Explicit(Posit32).0._State_32\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.46\ := \Quire Posit32::op_Explicit(Posit32).0.num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_34\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_34\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_35\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_35\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_33\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.46\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_34\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Posit32::op_Explicit(Posit32).0._State_33\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02;
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- // Starting inlined block of the method System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\;
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = x;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.x\;
                        -- The following section was transformed from the .NET statement below:
                        -- short return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Starting inlined block of the method System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (long)((this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.47\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.48\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.47\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.48\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) {
                        -- 	conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	uint return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (uint)((long)(~bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_37\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_37\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_38\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_38\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_36\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_7c713771ddbe04c4c2ff20ebfa1dae4044757c440fe5b46ea759182bcfb4b09b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_37\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_34\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = ((uint)num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = ((uint)num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := (unsigned(\Quire Posit32::op_Explicit(Posit32).0.num_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_32\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_34\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_35\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02 = 0u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_32\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_35\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_36\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 31;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.50\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.50\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 >> 31) & 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.51\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.52\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.51\) and to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.52\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.53\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.53\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) < (int)(startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) && bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 >> 31 == num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) {
                        -- 	bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 << 1;
                        -- 	b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (byte)((int)(b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1);
                        -- 	num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_39\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Quire Posit32::op_Explicit(Posit32).0._State_37\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_33\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_37\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_38\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	uint return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (uint)((long)(~bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (uint)((long)(~bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.3\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.49\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.3\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.49\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional054ffdc2634715c514e630840f155e53d1c8ffe0be53ec06d4c21ba08ad2b716_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.return_6618db8f62e3464b32c8cc3e2209d7d35e6f677ff842c32f9130d90de0560ee2_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_33\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_38\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_39\ => 
                        -- Repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_36\.
                        -- The while loop's condition:
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.54\ := (\Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\) < signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.startingPosition_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.55\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.56\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.55\ = \Quire Posit32::op_Explicit(Posit32).0.num_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_41\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Quire Posit32::op_Explicit(Posit32).0._State_40\ => 
                        -- State after the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_36\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.return_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((((long)(num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) & 1073741824L) == 0L)) {
                        -- 	conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)(-(int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- } else {
                        -- 	conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)((int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) - 1));
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.61\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.num_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 64)) and to_signed(1073741824, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.62\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.61\) = to_signed(0, 64);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_43\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_43\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_44\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_44\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_42\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.62\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_43\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_44\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4551
                    when \Quire Posit32::op_Explicit(Posit32).0._State_41\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.57\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.54\ and \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.56\;
                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.57\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 << 1;
                            -- 	b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (byte)((int)(b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1);
                            -- 	num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 << 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.58\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Quire Posit32::op_Explicit(Posit32).0.bits_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.58\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (byte)((int)(b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) + 1);
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.59\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32)) + to_signed(1, 32)), 8);
                            \Quire Posit32::op_Explicit(Posit32).0.b_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.59\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 + 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.60\ := \Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ + to_signed(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.num2_99370110dae22db8631ca471eb437acc86c558e498739532bd9c0197bd7b376b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.60\;
                            -- Returning to the repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_36\ if the loop wasn't exited with a state change.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_41\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_39\;
                            end if;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Quire Posit32::op_Explicit(Posit32).0._State_42\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_40\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Ending inlined block of the method System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.return_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) != -31)) {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 	Lombiq.Arithmetics.Posit32 this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 	this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	bool return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 	return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = (long)((this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2) {
                        -- 		conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 		bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 		uint return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 		return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = (uint)((long)(~bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	}
                        -- 	num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28);
                        -- 	byte b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 	Lombiq.Arithmetics.Posit32 this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	byte return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	uint bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	uint conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bool return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (long)((this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 		conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 		uint return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (uint)((long)(~bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	}
                        -- 	bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 	byte b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	uint bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 31;
                        -- 	byte return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 1;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 	uint num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31) & 1u;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 	int num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 0;
                        -- 	while ((int)(num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) < (int)(startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) && bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31 == num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 		bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 		b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)((int)(b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1);
                        -- 		num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a + 1;
                        -- 	}
                        -- 	return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(32 - (int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) - 1);
                        -- 	if ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2 <= 32) {
                        -- 		int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		if ((32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2) > 2)) {
                        -- 			conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- 		} else {
                        -- 			conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- 		}
                        -- 		result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 	}
                        -- 	return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 	b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 	Lombiq.Arithmetics.Posit32 this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	uint bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bool return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (long)((this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 		conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 		bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 		uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 		return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	}
                        -- 	bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 	int num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	uint bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	byte startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 31;
                        -- 	byte return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	byte b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 1;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 	uint num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31) & 1u;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 	int num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0;
                        -- 	while ((int)(num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) < (int)(startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) && bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31 == num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 		bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 		b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1);
                        -- 		num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 + 1;
                        -- 	}
                        -- 	return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 32 - ((int)(return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 2 + 2);
                        -- 	uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	if ((num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 > 0)) {
                        -- 		conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = ((uint)num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 	} else {
                        -- 		conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0u;
                        -- 	}
                        -- 	return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 	num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 >> (int)return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 32 - (int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) >> 30;
                        -- 	uint conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	if (((int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) != 0)) {
                        -- 		conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	} else {
                        -- 		conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0u;
                        -- 	}
                        -- 	return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((short)((long)((int)(regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) * 4) + (long)(return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- } else {
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.64\ := SmartResize((\Quire Posit32::op_Explicit(Posit32).0.regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32) /= to_signed(-31, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_46\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_74\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_77\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_77\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_45\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.64\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_46\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_77\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Quire Posit32::op_Explicit(Posit32).0._State_43\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_40\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)(-(int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)(-(int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.4\ := -signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := (SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.4\), 8));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_40\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_43\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3119
                    when \Quire Posit32::op_Explicit(Posit32).0._State_44\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_40\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)((int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) - 1));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((sbyte)((int)(b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) - 1));
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.63\ := SmartResize(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32)) - to_signed(1, 32), 8);
                        \Quire Posit32::op_Explicit(Posit32).0.conditional882cd98d817375e03765080fbf2e91fcc69740961af08057feb5bee6e57e0737_832c1453bf6766412ab7d49a3bfbb4a30fb5f9d2e99fd33b1e1f82b95af141f7_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.63\));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_40\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_44\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Posit32::op_Explicit(Posit32).0._State_45\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (short)(conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28);
                        -- // Ending inlined block of the method System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := SmartResize((\Quire Posit32::op_Explicit(Posit32).0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- quire = Quire.op_LeftShift (quire, (int)(240L - (long)(return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02) + (long)(return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.116\ := to_signed(240, 64) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_8dfbaed5965e93c29818d159b1ad2555bb8b028790c39ebb33911ab61c042d02\), 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.117\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.116\ + SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 64), 32);
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                        \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\ <= (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.117\);
                        \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= true;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_78\;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Quire Posit32::op_Explicit(Posit32).0._State_46\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 	Lombiq.Arithmetics.Posit32 this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 	this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	bool return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 	return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = (long)((this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2) {
                        -- 		conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 		bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 		uint return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 		return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = (uint)((long)(~bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	}
                        -- 	num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28);
                        -- 	byte b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 	Lombiq.Arithmetics.Posit32 this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	byte return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	uint bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	uint conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bool return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (long)((this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 		conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 		uint return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (uint)((long)(~bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	}
                        -- 	bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 	byte b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	uint bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 31;
                        -- 	byte return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 1;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 	uint num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31) & 1u;
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 	int num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 0;
                        -- 	while ((int)(num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) < (int)(startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) && bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31 == num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 		bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 		b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)((int)(b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1);
                        -- 		num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a + 1;
                        -- 	}
                        -- 	return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	byte result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(32 - (int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) - 1);
                        -- 	if ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2 <= 32) {
                        -- 		int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 		if ((32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2) > 2)) {
                        -- 			conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- 		} else {
                        -- 			conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- 		}
                        -- 		result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 	}
                        -- 	return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 	b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 	Lombiq.Arithmetics.Posit32 this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	uint return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	uint bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	Lombiq.Arithmetics.Posit32 this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bool return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (long)((this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits & 0x80000000u)) == 0L;
                        -- 	// Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 	if (return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 		conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 	} else {
                        -- 		;
                        -- 		// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 		bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 		uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 		return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1L);
                        -- 		// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 		conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	}
                        -- 	bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 	int num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	uint bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	byte startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 31;
                        -- 	byte return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	byte b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 1;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 	uint num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31) & 1u;
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 	int num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0;
                        -- 	while ((int)(num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) < (int)(startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) && bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31 == num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 		bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 		b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1);
                        -- 		num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 + 1;
                        -- 	}
                        -- 	return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 	num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 32 - ((int)(return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 2 + 2);
                        -- 	uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	if ((num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 > 0)) {
                        -- 		conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = ((uint)num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 	} else {
                        -- 		conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0u;
                        -- 	}
                        -- 	return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 	num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 >> (int)return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 32 - (int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) >> 30;
                        -- 	uint conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	if (((int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) != 0)) {
                        -- 		conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	} else {
                        -- 		conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0u;
                        -- 	}
                        -- 	return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((short)((long)((int)(regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) * 4) + (long)(return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\ := \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2 = (long)((this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.65\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.66\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.65\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.66\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2) {
                        -- 	conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	uint return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = (uint)((long)(~bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_48\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_48\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_49\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_49\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_47\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_4d92f321cba6244b5bb71509cbad78bd467f0d9f83f5164197b9be70bc739dc2\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_48\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_47\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_46\.
                        -- The following section was transformed from the .NET statement below:
                        -- num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = (conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (long)((this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.68\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.69\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.68\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.69\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 	conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 	uint return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (uint)((long)(~bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_51\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_51\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_52\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_52\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_50\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_8ccfdac761d94cefabb354727c4eec638b4b892c15d704db2d4988c8e2e41cd8_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_51\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_48\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_46\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_46\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_48\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_47\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_49\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_46\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 	uint return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 	return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = (uint)((long)(~bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\ := \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814 = (uint)((long)(~bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.5\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.67\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.5\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.67\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional880d0f3a8d33b2428fb4e8a62e4174f93b0cc01cc9b8d6d16563b7d2d4e90992_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.return_c6f8839606b9f7c5e666e7f8d7c6eeb396a41e4838bd7ee0d04170e34ce7b814\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_46\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_49\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_47\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_50\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_47\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\);
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.bits_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 31;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.71\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.71\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31) & 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.72\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.73\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.72\) and to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.73\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.74\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.74\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) < (int)(startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) && bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a >> 31 == num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) {
                        -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                        -- 	b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)((int)(b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1);
                        -- 	num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_53\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Quire Posit32::op_Explicit(Posit32).0._State_51\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_47\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_47\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_51\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_50\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_52\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_47\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 	uint return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (uint)((long)(~bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.this_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (uint)((long)(~bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.6\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.70\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.6\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.70\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional85ca8d8893aa24483d9e74ed87417b722b6d33d6069def85ee5195c77759eab3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.return_3465d1fb5b2deaf339333582b5a596bf893ed003380b440bf76067c5451863a3_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_47\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_52\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_50\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_53\ => 
                        -- Repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_50\.
                        -- The while loop's condition:
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.75\ := (\Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\) < signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.startingPosition_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.76\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.77\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.76\ = \Quire Posit32::op_Explicit(Posit32).0.num_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_55\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Quire Posit32::op_Explicit(Posit32).0._State_54\ => 
                        -- State after the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_50\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.return_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(32 - (int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) - 1);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.82\ := to_signed(32, 32) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.83\ := SmartResize(unsigned(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.82\ - to_signed(1, 32)), 8);
                        \Quire Posit32::op_Explicit(Posit32).0.result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.83\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2 <= 32) {
                        -- 	int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	if ((32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2) > 2)) {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- 	} else {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- 	}
                        -- 	result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.84\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_56\;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Quire Posit32::op_Explicit(Posit32).0._State_55\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.78\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.75\ and \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.77\;
                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.78\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                            -- 	b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)((int)(b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1);
                            -- 	num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a << 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.79\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Quire Posit32::op_Explicit(Posit32).0.bits_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.79\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)((int)(b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 1);
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.80\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32)) + to_signed(1, 32)), 8);
                            \Quire Posit32::op_Explicit(Posit32).0.b_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.80\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a + 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.81\ := \Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ + to_signed(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.num2_f9d1c0948957a79ca7758767cdb551a2fd521596e0a020604db70bc0313c407b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.81\;
                            -- Returning to the repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_50\ if the loop wasn't exited with a state change.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_55\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_53\;
                            end if;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Quire Posit32::op_Explicit(Posit32).0._State_56\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.85\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.84\ <= to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_58\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_59\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_57\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.85\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_58\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Posit32::op_Explicit(Posit32).0._State_57\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := \Quire Posit32::op_Explicit(Posit32).0.result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.return_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\;
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.this_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- // Starting inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Lombiq.Arithmetics.Posit32 this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (long)((this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits & 0x80000000u)) == 0L;
                        -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.91\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\.\PositBits\ and "10000000000000000000000000000000", 64));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.92\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.91\)), 64)) = to_signed(0, 64);
                        \Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.92\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- } else {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_63\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_63\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_64\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_64\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_62\.

                        if (\Quire Posit32::op_Explicit(Posit32).0.return_092f045227f64eda72b3fc95be3c3637705914add72214a343e55185cfa65c10_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_63\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_64\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_58\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 	if ((32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2) > 2)) {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- 	} else {
                        -- 		conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- 	}
                        -- 	result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2) > 2)) {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- } else {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.86\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.87\ := to_signed(32, 32) - (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.86\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.88\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.87\ > to_signed(2, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_60\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_60\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_61\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_61\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_59\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.88\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_60\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_61\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \Quire Posit32::op_Explicit(Posit32).0._State_59\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_58\.
                        -- The following section was transformed from the .NET statement below:
                        -- result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = (byte)(conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.result_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := SmartResize(unsigned((\Quire Posit32::op_Explicit(Posit32).0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\)), 8);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_56\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_59\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_60\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_58\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = 2;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := to_signed(2, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_58\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_60\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_61\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_58\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a = ((byte)(32 - ((int)(b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a) + 2)));
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.89\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.90\ := SmartResize(unsigned(to_signed(32, 32) - (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.89\)), 8);
                        \Quire Posit32::op_Explicit(Posit32).0.conditional49bc984bd2c3ad06e30b23a2ff42c87c16bf015aaba8bc2ed3853f6adc988a15_fa5c7efa4c67d060a70b49e02aabb5ee02fd5c8b1d6e04e5196ceda62f23fe5a\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.90\)), 32));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_58\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_61\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \Quire Posit32::op_Explicit(Posit32).0._State_62\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_57\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := (\Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\);
                        -- The following section was transformed from the .NET statement below:
                        -- int num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- // Starting inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.bits_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 31;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := SmartResize(unsigned(to_signed(31, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- byte return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := SmartResize(unsigned(to_signed(1, 32)), 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.94\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.94\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31) & 1u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.95\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.96\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.95\) and to_unsigned(1, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.96\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.97\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.97\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) < (int)(startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) && bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 >> 31 == num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) {
                        -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                        -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1);
                        -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_65\;
                        -- Clock cycles needed to complete this state (approximation): 0.8332
                    when \Quire Posit32::op_Explicit(Posit32).0._State_63\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_57\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_57\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_63\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_62\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_64\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_57\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	;
                        -- 	// Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 	uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 	return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1L);
                        -- 	// Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 	conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4.PositBits;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.this_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (uint)((long)(~bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1L);
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.7\ := not(\Quire Posit32::op_Explicit(Posit32).0.bits_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.93\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.unaryOperationResult.7\), 64)) + to_signed(1, 64)), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.93\);
                        -- The following section was transformed from the .NET statement below:
                        -- conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional963d17004b6788ad55358cce58986fa179ec1b5dc039dfede93d706448099e92_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.return_c8598ebe73f9f5bfb88d0df855ee308f9c4caf4ef5760e9d645383f544733d31_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_57\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_64\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_62\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5346
                    when \Quire Posit32::op_Explicit(Posit32).0._State_65\ => 
                        -- Repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_62\.
                        -- The while loop's condition:
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.98\ := (\Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\) < signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.startingPosition_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.99\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.100\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.99\ = \Quire Posit32::op_Explicit(Posit32).0.num_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_67\;
                        -- Clock cycles needed to complete this state (approximation): 0.9897
                    when \Quire Posit32::op_Explicit(Posit32).0._State_66\ => 
                        -- State after the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_62\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- // Ending inlined block of the method System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 32 - ((int)(return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 2 + 2);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.105\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\), 32)) + to_signed(2, 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.106\ := SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.105\ + to_signed(2, 32), 32);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.107\ := to_signed(32, 32) - (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.106\);
                        \Quire Posit32::op_Explicit(Posit32).0.num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.107\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 > 0)) {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = ((uint)num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- } else {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0u;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_68\;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \Quire Posit32::op_Explicit(Posit32).0._State_67\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.101\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.98\ and \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.100\;
                        if (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.101\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                            -- 	b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1);
                            -- 	num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.102\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \Quire Posit32::op_Explicit(Posit32).0.bits_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.102\;
                            -- The following section was transformed from the .NET statement below:
                            -- b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = (byte)((int)(b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4) + 1);
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.103\ := SmartResize(unsigned(signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\), 32)) + to_signed(1, 32)), 8);
                            \Quire Posit32::op_Explicit(Posit32).0.b_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := (\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.103\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 + 1;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.104\ := \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ + to_signed(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.num2_aa1887a732f44ab7933da762327f79580f968b608eddfcba10dec20b0026fde4_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.104\;
                            -- Returning to the repeated state of the while loop which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_62\ if the loop wasn't exited with a state change.
                            if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_67\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_65\;
                            end if;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8985
                    when \Quire Posit32::op_Explicit(Posit32).0._State_68\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.108\ := \Quire Posit32::op_Explicit(Posit32).0.num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_70\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_70\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_71\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_71\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_69\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.108\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_70\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_71\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Posit32::op_Explicit(Posit32).0._State_69\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4;
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 >> (int)return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 << 32 - (int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) >> 30;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.109\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\, to_integer(unsigned(SmartResize(signed(\Quire Posit32::op_Explicit(Posit32).0.return_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.110\ := to_signed(32, 32) - signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32));
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_72\;
                        -- Clock cycles needed to complete this state (approximation): 0.9774
                    when \Quire Posit32::op_Explicit(Posit32).0._State_70\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = ((uint)num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = ((uint)num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4);
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := (unsigned(\Quire Posit32::op_Explicit(Posit32).0.num_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\));
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_68\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_70\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_69\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_71\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4 = 0u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionalf2eba7c459dd057c9270f346c2a9013399b4309fc21683746ef1be47061f03f1_94bef725a1b90b0f1b2e9d5058b7a34e74ecdb8cab8ec5897a685559b4937cd4\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_68\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_71\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_69\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_72\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.111\ := shift_left(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.109\, to_integer(unsigned(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.110\, 5))));
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.112\ := shift_right(\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.111\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                        \Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.112\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) != 0)) {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- } else {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0u;
                        -- }
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_73\;
                        -- Clock cycles needed to complete this state (approximation): 0.9522
                    when \Quire Posit32::op_Explicit(Posit32).0._State_73\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.113\ := signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.b_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32)) /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_75\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_75\.
                        --     * The false branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_76\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_76\.
                        --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_74\.

                        if ((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.113\)) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_75\;
                        else 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Quire Posit32::op_Explicit(Posit32).0._State_74\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_73\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- // Ending inlined block of the method System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = ((short)((long)((int)(regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28) * 4) + (long)(return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28)));
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.114\ := SmartResize(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.regimeKValue_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 32) * to_signed(4, 32), 64);
                        \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.115\ := SmartResize((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.114\) + signed(SmartResize((\Quire Posit32::op_Explicit(Posit32).0.return_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\), 64)), 16);
                        \Quire Posit32::op_Explicit(Posit32).0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.115\)), 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_42\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_74\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5119
                    when \Quire Posit32::op_Explicit(Posit32).0._State_75\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_73\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := \Quire Posit32::op_Explicit(Posit32).0.num_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_73\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_75\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_74\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_76\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_73\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0u;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditionala233560fe7dfff22c231bec46671f442fee11494dc774056e64d669ec36cdb00_b30c7cf04e18e8e1d9326fda65a98f3e6ce2cb9a087dd14bb74739b64c0a2a6c_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_73\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_76\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_74\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_77\ => 
                        -- False branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_42\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28 = 0;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.conditional1aa95b35288eb627929161a1ee637479589960934567100c958634e64afb13de_5547e2b2a08e312134cbdc7a0930a7319e6155fa1d1d0c7cedcf0662fda61e28\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_42\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_77\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_78\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.1\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- Lombiq.Arithmetics.Posit32 this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0 = x;
                            -- 
                            \Quire Posit32::op_Explicit(Posit32).0.this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\ := \Quire Posit32::op_Explicit(Posit32).0.x\;
                            -- The following section was transformed from the .NET statement below:
                            -- bool return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0 = (long)((this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0.PositBits & 0x80000000u)) == 0L;
                            -- // Ending inlined block of the method System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().
                            -- 
                            -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.118\ := signed(SmartResize(\Quire Posit32::op_Explicit(Posit32).0.this_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\.\PositBits\ and "10000000000000000000000000000000", 64));
                            \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.119\ := signed(SmartResize(((\Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.118\)), 64)) = to_signed(0, 64);
                            \Quire Posit32::op_Explicit(Posit32).0.return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\ := \Quire Posit32::op_Explicit(Posit32).0.binaryOperationResult.119\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0) {
                            -- 	return quire;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Quire Posit32::op_Explicit(Posit32).0._State_80\ and ends in state \Quire Posit32::op_Explicit(Posit32).0._State_80\.
                            --     * Execution after either branch will continue in the following state: \Quire Posit32::op_Explicit(Posit32).0._State_79\.

                            if (\Quire Posit32::op_Explicit(Posit32).0.return_5204dd194817ce0e22c54ac6e6fe7dc0a0e40352e5a5fed887c54294684dded0\) then 
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_80\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_79\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4203
                    when \Quire Posit32::op_Explicit(Posit32).0._State_79\ => 
                        -- State after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_78\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Quire.op_Addition (Quire.op_OnesComplement (quire), 1u);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                        \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= true;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_81\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_80\ => 
                        -- True branch of the if-else started in state \Quire Posit32::op_Explicit(Posit32).0._State_78\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return quire;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return quire;
                        -- 
                        \Quire Posit32::op_Explicit(Posit32).0.return\ <= \Quire Posit32::op_Explicit(Posit32).0.quire\;
                        \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Quire Posit32::op_Explicit(Posit32).0._State_78\.
                        if (\Quire Posit32::op_Explicit(Posit32).0._State\ = \Quire Posit32::op_Explicit(Posit32).0._State_80\) then 
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_79\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_81\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.2\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.quire\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\ <= \Quire Posit32::op_Explicit(Posit32).0.return.2\;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_82\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Posit32::op_Explicit(Posit32).0._State_82\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32)
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ = \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ <= false;
                            \Quire Posit32::op_Explicit(Posit32).0.return.3\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).return.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.return.2\ := \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\;
                            \Quire Posit32::op_Explicit(Posit32).0.return\ <= \Quire Posit32::op_Explicit(Posit32).0.return.3\;
                            \Quire Posit32::op_Explicit(Posit32).0._State\ := \Quire Posit32::op_Explicit(Posit32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 state machine start
    \Quire::.ctor(UInt64[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Quire::.ctor(UInt64[],UInt16).0._State\: \Quire::.ctor(UInt64[],UInt16).0._States\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
        Variable \Quire::.ctor(UInt64[],UInt16).0.this\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire::.ctor(UInt64[],UInt16).0.segments\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire::.ctor(UInt64[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt64[],UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= false;
                \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 64));
                \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
                \Quire::.ctor(UInt64[],UInt16).0.segments\ := (others => to_unsigned(0, 64));
                \Quire::.ctor(UInt64[],UInt16).0.size\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt64[],UInt16).0.num\ := to_signed(0, 32);
                \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\ := false;
                \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Quire::.ctor(UInt64[],UInt16).0._State\ is 
                    when \Quire::.ctor(UInt64[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire::.ctor(UInt64[],UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire::.ctor(UInt64[],UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= true;
                        else 
                            \Quire::.ctor(UInt64[],UInt16).0._Finished\ <= false;
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\ <= \Quire::.ctor(UInt64[],UInt16).0.this\;
                        \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\ <= \Quire::.ctor(UInt64[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_2\ => 
                        \Quire::.ctor(UInt64[],UInt16).0.this\ := \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\;
                        \Quire::.ctor(UInt64[],UInt16).0.segments\ := \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\;
                        \Quire::.ctor(UInt64[],UInt16).0.size\ := \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = 8;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\SegmentCount\ := to_unsigned(8, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 0;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Size\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = new ulong[8];
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (segments, @this.Segments, 8);
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\ := \Quire::.ctor(UInt64[],UInt16).0.segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 8;
                        -- 
                        \Quire::.ctor(UInt64[],UInt16).0.num\ := to_signed(8, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < 8) {
                        -- 	@this.Segments [num] = 0uL;
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt64[],UInt16).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire::.ctor(UInt64[],UInt16).0._State_2\.
                        -- The while loop's condition:
                        \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\ := (\Quire::.ctor(UInt64[],UInt16).0.num\) < to_signed(8, 32);
                        if (\Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	@this.Segments [num] = 0uL;
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- @this.Segments [num] = 0uL;
                            -- 
                            \Quire::.ctor(UInt64[],UInt16).0.this\.\Segments\(to_integer(\Quire::.ctor(UInt64[],UInt16).0.num\)) := to_unsigned(0, 64);
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\ := \Quire::.ctor(UInt64[],UInt16).0.num\ + to_signed(1, 32);
                            \Quire::.ctor(UInt64[],UInt16).0.num\ := \Quire::.ctor(UInt64[],UInt16).0.binaryOperationResult.1\;
                        else 
                            \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Quire::.ctor(UInt64[],UInt16).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire::.ctor(UInt64[],UInt16).0._State_2\.
                        \Quire::.ctor(UInt64[],UInt16).0._State\ := \Quire::.ctor(UInt64[],UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 state machine start
    \Quire::.ctor(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Quire::.ctor(UInt32,UInt16).0._State\: \Quire::.ctor(UInt32,UInt16).0._States\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
        Variable \Quire::.ctor(UInt32,UInt16).0.this\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire::.ctor(UInt32,UInt16).0.firstSegment\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire::.ctor(UInt32,UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\: boolean := false;
        Variable \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire::.ctor(UInt32,UInt16).0._Finished\ <= false;
                \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
                \Quire::.ctor(UInt32,UInt16).0.firstSegment\ := to_unsigned(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.size\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := false;
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \Quire::.ctor(UInt32,UInt16).0.num\ := to_signed(0, 32);
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\ := false;
                \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\ := to_signed(0, 32);
            else 
                case \Quire::.ctor(UInt32,UInt16).0._State\ is 
                    when \Quire::.ctor(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \Quire::.ctor(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._Finished\ <= false;
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\ <= \Quire::.ctor(UInt32,UInt16).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_2\ => 
                        \Quire::.ctor(UInt32,UInt16).0.this\ := \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\;
                        \Quire::.ctor(UInt32,UInt16).0.firstSegment\ := \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\;
                        \Quire::.ctor(UInt32,UInt16).0.size\ := \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Size\ := \Quire::.ctor(UInt32,UInt16).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b = (int)size;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ := signed(SmartResize(\Quire::.ctor(UInt32,UInt16).0.size\, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b - remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b / 32 * 32 != 0)) {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- } else {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- }
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ / to_signed(32, 32);
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := SmartResize(\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.861
                    when \Quire::.ctor(UInt32,UInt16).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := \Quire::.ctor(UInt32,UInt16).0.remainderOperand0c439d9dfdc1e321f9179f8d0530a346aae5aa4d433af564a6e961f787b90b5b\ - \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire::.ctor(UInt32,UInt16).0._State_5\ and ends in state \Quire::.ctor(UInt32,UInt16).0._State_5\.
                        --     * The false branch starts in state \Quire::.ctor(UInt32,UInt16).0._State_6\ and ends in state \Quire::.ctor(UInt32,UInt16).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \Quire::.ctor(UInt32,UInt16).0._State_4\.

                        if ((\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.3\)) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_5\;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5903
                    when \Quire::.ctor(UInt32,UInt16).0._State_4\ => 
                        -- State after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(((int)(size) >> 6) + (conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517));
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := shift_right(signed(SmartResize((\Quire::.ctor(UInt32,UInt16).0.size\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5) and "11111")));
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := SmartResize(unsigned((\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.4\) + (\Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\)), 16);
                        \Quire::.ctor(UInt32,UInt16).0.this\.\SegmentCount\ := (\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = new ulong[8];
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments [0] = 1u;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\(to_integer(to_signed(0, 32))) := SmartResize(to_unsigned(1, 32), 64);
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.num\ := to_signed(1, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(@this.SegmentCount)) {
                        -- 	@this.Segments [num] = 0uL;
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.64
                    when \Quire::.ctor(UInt32,UInt16).0._State_5\ => 
                        -- True branch of the if-else started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 1;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        if (\Quire::.ctor(UInt32,UInt16).0._State\ = \Quire::.ctor(UInt32,UInt16).0._State_5\) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517 = 0;
                        -- 
                        \Quire::.ctor(UInt32,UInt16).0.conditional508ca86de85a5da84bb49b246fc4b145e1352a0547a47e41f17ab54c68695517\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire::.ctor(UInt32,UInt16).0._State_3\.
                        if (\Quire::.ctor(UInt32,UInt16).0._State\ = \Quire::.ctor(UInt32,UInt16).0._State_6\) then 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire::.ctor(UInt32,UInt16).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Quire::.ctor(UInt32,UInt16).0._State_4\.
                        -- The while loop's condition:
                        \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\ := (\Quire::.ctor(UInt32,UInt16).0.num\) < signed(SmartResize((\Quire::.ctor(UInt32,UInt16).0.this\.\SegmentCount\), 32));
                        if (\Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	@this.Segments [num] = 0uL;
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- @this.Segments [num] = 0uL;
                            -- 
                            \Quire::.ctor(UInt32,UInt16).0.this\.\Segments\(to_integer(\Quire::.ctor(UInt32,UInt16).0.num\)) := to_unsigned(0, 64);
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\ := \Quire::.ctor(UInt32,UInt16).0.num\ + to_signed(1, 32);
                            \Quire::.ctor(UInt32,UInt16).0.num\ := \Quire::.ctor(UInt32,UInt16).0.binaryOperationResult.7\;
                        else 
                            \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \Quire::.ctor(UInt32,UInt16).0._State_8\ => 
                        -- State after the while loop which was started in state \Quire::.ctor(UInt32,UInt16).0._State_4\.
                        \Quire::.ctor(UInt32,UInt16).0._State\ := \Quire::.ctor(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine start
    \Quire Quire::op_Addition(Quire,Quire).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_Addition(Quire,Quire).0._State\: \Quire Quire::op_Addition(Quire,Quire).0._States\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.right\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag2\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.flag3\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\: boolean := false;
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_Addition(Quire,Quire).0.flag\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.num3\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.flag2\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.flag3\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.b\ := to_unsigned(0, 8);
                \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\ := to_unsigned(0, 8);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\ := to_unsigned(0, 64);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ := to_signed(0, 32);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\ := false;
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\ := to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_Addition(Quire,Quire).0._State\ is 
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._Finished\ <= false;
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\ <= \Quire Quire::op_Addition(Quire,Quire).0.left\;
                        \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\ <= \Quire Quire::op_Addition(Quire,Quire).0.right\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_2\ => 
                        \Quire Quire::op_Addition(Quire,Quire).0.left\ := \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\;
                        \Quire Quire::op_Addition(Quire,Quire).0.right\ := \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(left.SegmentCount) == 0 || (int)(right.SegmentCount) == 0) {
                        -- 	return left;
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.0\ or \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.1\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_4\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_4\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_3\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.2\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_3\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = false;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.flag\ := false;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num3\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num3) < (int)((int)(left.SegmentCount) << 6)) {
                        -- 	bool flag2;
                        -- 	flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 	bool flag3;
                        -- 	flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 	byte b;
                        -- 	int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                        -- 	if (flag2) {
                        -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- 	} else {
                        -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- 	}
                        -- 	int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                        -- 	if (flag3) {
                        -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- 	} else {
                        -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- 	}
                        -- 	int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                        -- 	if (flag) {
                        -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- 	} else {
                        -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- 	}
                        -- 	b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                        -- 	if (((int)(b) & 1) == 1) {
                        -- 		array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- 	}
                        -- 	flag = (int)(b) >> 1 == 1;
                        -- 	num2 = (ushort)((int)(num2) + 1);
                        -- 	if ((int)(num2) >> 6 == 1) {
                        -- 		num2 = 0;
                        -- 		num = (ushort)((int)(num) + 1);
                        -- 	}
                        -- 	num3 = (ushort)((int)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_4\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return left;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.return\ <= \Quire Quire::op_Addition(Quire,Quire).0.left\;
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_2\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_4\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\ := shift_left(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.left\.\SegmentCount\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5))));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num3\), 32)) < (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.3\);
                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag2;
                            -- 	flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 	bool flag3;
                            -- 	flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 	byte b;
                            -- 	int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                            -- 	if (flag2) {
                            -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                            -- 	} else {
                            -- 		conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                            -- 	}
                            -- 	int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                            -- 	if (flag3) {
                            -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                            -- 	} else {
                            -- 		conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                            -- 	}
                            -- 	int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                            -- 	if (flag) {
                            -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                            -- 	} else {
                            -- 		conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                            -- 	}
                            -- 	b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                            -- 	if (((int)(b) & 1) == 1) {
                            -- 		array [num] = array [num] + (ulong)(1L << (int)num2);
                            -- 	}
                            -- 	flag = (int)(b) >> 1 == 1;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- 	if ((int)(num2) >> 6 == 1) {
                            -- 		num2 = 0;
                            -- 		num = (ushort)((int)(num) + 1);
                            -- 	}
                            -- 	num3 = (ushort)((int)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = ((left.Segments [num] >> (int)num2) & 1uL) == 1uL;
                            -- 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_7\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4003
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_6\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5 = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\IsNull\ := false;
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\;
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.array\;
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\ := SmartResize(shift_right(\Quire Quire::op_Addition(Quire,Quire).0.left\.\Segments\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6) and "111111"))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.5\) and to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.9145
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.6\) = to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag2\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = ((right.Segments [num] >> (int)num2) & 1uL) == 1uL;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\ := SmartResize(shift_right(\Quire Quire::op_Addition(Quire,Quire).0.right\.\Segments\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6) and "111111"))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.8\) and to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.9145
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.9\) = to_unsigned(1, 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag3\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- } else {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_12\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_12\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_13\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_11\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag2\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_12\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2817
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_11\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- } else {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_15\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_15\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_16\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_14\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag3\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_15\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_12\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_12\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_13\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_10\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_13\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_14\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- } else {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_18\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_18\.
                        --     * The false branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_19\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_17\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.flag\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_18\;
                        else 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_15\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_15\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_16\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_11\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_16\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_17\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)((conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8) + (conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23) + (conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696));
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ := (\Quire Quire::op_Addition(Quire,Quire).0.conditional3298b3b5288372ecd7585b7d11dd95500a8cc3df2a585935c3cb451d2c81b1d8\) + (\Quire Quire::op_Addition(Quire,Quire).0.conditional11d902bbebd7adf27d38fde6ece75b86840c80c45250e8b4634533434d476b23\);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\ := SmartResize(unsigned(\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.11\ + (\Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\)), 8);
                        \Quire Quire::op_Addition(Quire,Quire).0.b\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.12\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(b) & 1) == 1) {
                        -- 	array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\ := signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.b\), 32)) and to_signed(1, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.7912
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_18\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_18\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_19\ => 
                        -- False branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.conditionale38b385949ca23e8026f3a3656220e6beb041d4478169396edc67a25ed16f696\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_14\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_19\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.13\) = to_signed(1, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_22\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_21\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.14\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_22\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_21\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (int)(b) >> 1 == 1;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ := shift_right(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.b\), 32)), to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.17\ = to_signed(1, 32);
                        \Quire Quire::op_Addition(Quire,Quire).0.flag\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.18\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.19\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num2) >> 6 == 1) {
                        -- 	num2 = 0;
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0.8515
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_22\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num] = array [num] + (ulong)(1L << (int)num2);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\ := SmartResize(unsigned(shift_left(to_signed(1, 64), to_integer(unsigned(SmartResize(signed(SmartResize(\Quire Quire::op_Addition(Quire,Quire).0.num2\, 32)), 6))))), 64);
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\ := \Quire Quire::op_Addition(Quire,Quire).0.array\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)) + (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.15\);
                        \Quire Quire::op_Addition(Quire,Quire).0.array\(to_integer(\Quire Quire::op_Addition(Quire,Quire).0.num\)) := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.16\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_20\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_22\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9498
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_23\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ := shift_right(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num2\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5) and "11111")));
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\ := \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.20\ = to_signed(1, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_Addition(Quire,Quire).0._State_25\ and ends in state \Quire Quire::op_Addition(Quire,Quire).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_Addition(Quire,Quire).0._State_24\.

                        if (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.21\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_25\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5777
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_24\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (ushort)((int)(num3) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num3\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.23\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_24\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_25\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_Addition(Quire,Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_Addition(Quire,Quire).0.num\ := (\Quire Quire::op_Addition(Quire,Quire).0.binaryOperationResult.22\);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_Addition(Quire,Quire).0._State_23\.
                        if (\Quire Quire::op_Addition(Quire,Quire).0._State\ = \Quire Quire::op_Addition(Quire,Quire).0._State_25\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_Addition(Quire,Quire).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\ := \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.array\ := \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5;
                            -- 
                            \Quire Quire::op_Addition(Quire,Quire).0.return\ <= \Quire Quire::op_Addition(Quire,Quire).0.object2310ed2c746501f4e42709355ae1fdf78f18ff487c2ead2d94612c1aef65ace5\;
                            \Quire Quire::op_Addition(Quire,Quire).0._State\ := \Quire Quire::op_Addition(Quire,Quire).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 state machine start
    \Quire Quire::op_Addition(Quire,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_Addition(Quire,UInt32).0._State\: \Quire Quire::op_Addition(Quire,UInt32).0._States\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_Addition(Quire,UInt32).0.return.0\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
                \Quire Quire::op_Addition(Quire,UInt32).0.right\ := to_unsigned(0, 32);
                \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_Addition(Quire,UInt32).0._State\ is 
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0._Started\ = true) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_Addition(Quire,UInt32).0._Finished\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_2\ => 
                        \Quire Quire::op_Addition(Quire,UInt32).0.left\ := \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\;
                        \Quire Quire::op_Addition(Quire,UInt32).0.right\ := \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0 = new Quire (1u, (ushort)((int)(left.SegmentCount) << 6));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\IsNull\ := false;
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        \Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\ := SmartResize(unsigned(shift_left(signed(SmartResize((\Quire Quire::op_Addition(Quire,UInt32).0.left\.\SegmentCount\), 32)), to_integer(unsigned(SmartResize(to_signed(6, 32), 5))))), 16);
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\;
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= (\Quire Quire::op_Addition(Quire,UInt32).0.binaryOperationResult.0\);
                        \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.125
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16)
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Quire.op_Addition (left, object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= true;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_Addition(Quire,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire)
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ <= false;
                            \Quire Quire::op_Addition(Quire,UInt32).0.return.0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.left\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.object2b25f3fa9b50e7492d78b34e15a583b8300db89f75b5c7cb2910bbab85a19ff0\ := \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.return\ <= \Quire Quire::op_Addition(Quire,UInt32).0.return.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0._State\ := \Quire Quire::op_Addition(Quire,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 state machine start
    \Quire Quire::op_OnesComplement(Quire).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_OnesComplement(Quire).0._State\: \Quire Quire::op_OnesComplement(Quire).0._States\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
        Variable \Quire Quire::op_OnesComplement(Quire).0.q\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_OnesComplement(Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= false;
                \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
                \Quire Quire::op_OnesComplement(Quire).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\ := false;
                \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\ := to_unsigned(0, 64);
                \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_OnesComplement(Quire).0._State\ is 
                    when \Quire Quire::op_OnesComplement(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_OnesComplement(Quire).0._Started\ = true) then 
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_OnesComplement(Quire).0._Started\ = true) then 
                            \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_OnesComplement(Quire).0._Finished\ <= false;
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\ <= \Quire Quire::op_OnesComplement(Quire).0.q\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_2\ => 
                        \Quire Quire::op_OnesComplement(Quire).0.q\ := \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_OnesComplement(Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(q.SegmentCount)) {
                        -- 	q.Segments [num] = ~q.Segments [num];
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_OnesComplement(Quire).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_OnesComplement(Quire).0._State_2\.
                        -- The while loop's condition:
                        \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.num\), 32)) < signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.q\.\SegmentCount\), 32));
                        if (\Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	q.Segments [num] = ~q.Segments [num];
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- q.Segments [num] = ~q.Segments [num];
                            -- 
                            \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\ := not(\Quire Quire::op_OnesComplement(Quire).0.q\.\Segments\(to_integer(\Quire Quire::op_OnesComplement(Quire).0.num\)));
                            \Quire Quire::op_OnesComplement(Quire).0.q\.\Segments\(to_integer(\Quire Quire::op_OnesComplement(Quire).0.num\)) := \Quire Quire::op_OnesComplement(Quire).0.unaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (ushort)((int)(num) + 1);
                            -- 
                            \Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_OnesComplement(Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                            \Quire Quire::op_OnesComplement(Quire).0.num\ := (\Quire Quire::op_OnesComplement(Quire).0.binaryOperationResult.1\);
                        else 
                            \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7457
                    when \Quire Quire::op_OnesComplement(Quire).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_OnesComplement(Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return q;
                        -- 
                        \Quire Quire::op_OnesComplement(Quire).0.return\ <= \Quire Quire::op_OnesComplement(Quire).0.q\;
                        \Quire Quire::op_OnesComplement(Quire).0._State\ := \Quire Quire::op_OnesComplement(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine start
    \Boolean Quire::op_Equality(Quire,Quire).0._StateMachine\: process (\Clock\) 
        Variable \Boolean Quire::op_Equality(Quire,Quire).0._State\: \Boolean Quire::op_Equality(Quire,Quire).0._States\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.right\: \Lombiq.Arithmetics.Quire\;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\: boolean := false;
        Variable \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= false;
                \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.num\ := to_unsigned(0, 16);
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\ := false;
                \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \Boolean Quire::op_Equality(Quire,Quire).0._State\ is 
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._Started\ = true) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._Started\ = true) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= true;
                        else 
                            \Boolean Quire::op_Equality(Quire,Quire).0._Finished\ <= false;
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\ <= \Boolean Quire::op_Equality(Quire,Quire).0.left\;
                        \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\ <= \Boolean Quire::op_Equality(Quire,Quire).0.right\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_2\ => 
                        \Boolean Quire::op_Equality(Quire,Quire).0.left\ := \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\;
                        \Boolean Quire::op_Equality(Quire,Quire).0.right\ := \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(left.SegmentCount) != (int)(right.SegmentCount)) {
                        -- 	return false;
                        -- }
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\ := signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.left\.\SegmentCount\), 32)) /= signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.right\.\SegmentCount\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Boolean Quire::op_Equality(Quire,Quire).0._State_4\ and ends in state \Boolean Quire::op_Equality(Quire,Quire).0._State_4\.
                        --     * Execution after either branch will continue in the following state: \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.

                        if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.0\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_3\ => 
                        -- State after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(left.SegmentCount)) {
                        -- 	if (left.Segments [num] != right.Segments [num]) {
                        -- 		return false;
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_4\ => 
                        -- True branch of the if-else started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_2\.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_4\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.
                        -- The while loop's condition:
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\ := signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.num\), 32)) < signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.left\.\SegmentCount\), 32));
                        if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	if (left.Segments [num] != right.Segments [num]) {
                            -- 		return false;
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (left.Segments [num] != right.Segments [num]) {
                            -- 	return false;
                            -- }
                            -- 
                            \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\ := \Boolean Quire::op_Equality(Quire,Quire).0.left\.\Segments\(to_integer(\Boolean Quire::op_Equality(Quire,Quire).0.num\)) /= \Boolean Quire::op_Equality(Quire,Quire).0.right\.\Segments\(to_integer(\Boolean Quire::op_Equality(Quire,Quire).0.num\));

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Boolean Quire::op_Equality(Quire,Quire).0._State_8\ and ends in state \Boolean Quire::op_Equality(Quire,Quire).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Boolean Quire::op_Equality(Quire,Quire).0._State_7\.

                            if (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.2\) then 
                                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_8\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_7\;
                            end if;
                        else 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.557
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_6\ => 
                        -- State after the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return true;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= true;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_7\ => 
                        -- State after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\Boolean Quire::op_Equality(Quire,Quire).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Boolean Quire::op_Equality(Quire,Quire).0.num\ := (\Boolean Quire::op_Equality(Quire,Quire).0.binaryOperationResult.3\);
                        -- Returning to the repeated state of the while loop which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_7\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Boolean Quire::op_Equality(Quire,Quire).0._State_8\ => 
                        -- True branch of the if-else started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Boolean Quire::op_Equality(Quire,Quire).0.return\ <= false;
                        \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean Quire::op_Equality(Quire,Quire).0._State_5\.
                        if (\Boolean Quire::op_Equality(Quire,Quire).0._State\ = \Boolean Quire::op_Equality(Quire,Quire).0._State_8\) then 
                            \Boolean Quire::op_Equality(Quire,Quire).0._State\ := \Boolean Quire::op_Equality(Quire,Quire).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine start
    \Quire Quire::op_RightShift(Quire,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_RightShift(Quire,Int32).0._State\: \Quire Quire::op_RightShift(Quire,Int32).0._States\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.flag\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.flag2\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\: boolean := false;
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
                \Quire Quire::op_RightShift(Quire,Int32).0.right\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\ := to_signed(0, 32);
                \Quire Quire::op_RightShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_RightShift(Quire,Int32).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.num3\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.flag2\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\ := false;
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\ := to_unsigned(0, 64);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\ := to_unsigned(0, 16);
                \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_RightShift(Quire,Int32).0._State\ is 
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._Finished\ <= false;
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\ <= \Quire Quire::op_RightShift(Quire,Int32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_2\ => 
                        \Quire Quire::op_RightShift(Quire,Int32).0.left\ := \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.right\ := \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- right = right & ((1 << (int)(left.SegmentCount) * 6) - 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.left\.\SegmentCount\), 32)) * to_signed(6, 32), 32);
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\ := shift_left(to_signed(1, 32), to_integer(unsigned(SmartResize(\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.0\, 5))));
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.9452
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.1\) - to_signed(1, 32);
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\ := \Quire Quire::op_RightShift(Quire,Int32).0.right\ and (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.2\);
                        \Quire Quire::op_RightShift(Quire,Int32).0.right\ := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (left.Segments, array, 8);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\ := \Quire Quire::op_RightShift(Quire,Int32).0.left\.\Segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(right)) {
                        -- 	bool flag;
                        -- 	flag = false;
                        -- 	ushort num2;
                        -- 	num2 = 1;
                        -- 	while ((int)(num2) <= 8) {
                        -- 		ushort num3;
                        -- 		num3 = (ushort)(8 - (int)(num2));
                        -- 		bool flag2;
                        -- 		flag2 = (array [num3] & 1uL) == 1uL;
                        -- 		array [num3] = array [num3] >> 1;
                        -- 		if (flag) {
                        -- 			array [num3] = array [num3] | 0x8000000000000000uL;
                        -- 		}
                        -- 		flag = flag2;
                        -- 		num2 = (ushort)((int)(num2) + 1);
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_4\;
                        -- Clock cycles needed to complete this state (approximation): 0.4649
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\ := signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num\), 32)) < (\Quire Quire::op_RightShift(Quire,Int32).0.right\);
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag;
                            -- 	flag = false;
                            -- 	ushort num2;
                            -- 	num2 = 1;
                            -- 	while ((int)(num2) <= 8) {
                            -- 		ushort num3;
                            -- 		num3 = (ushort)(8 - (int)(num2));
                            -- 		bool flag2;
                            -- 		flag2 = (array [num3] & 1uL) == 1uL;
                            -- 		array [num3] = array [num3] >> 1;
                            -- 		if (flag) {
                            -- 			array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 		}
                            -- 		flag = flag2;
                            -- 		num2 = (ushort)((int)(num2) + 1);
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := false;
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := SmartResize(unsigned(to_signed(1, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num2) <= 8) {
                            -- 	ushort num3;
                            -- 	num3 = (ushort)(8 - (int)(num2));
                            -- 	bool flag2;
                            -- 	flag2 = (array [num3] & 1uL) == 1uL;
                            -- 	array [num3] = array [num3] >> 1;
                            -- 	if (flag) {
                            -- 		array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_6\;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_5\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741 = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\IsNull\ := false;
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.array\;
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\.
                        -- The while loop's condition:
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\ := signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32)) <= to_signed(8, 32);
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.5\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	ushort num3;
                            -- 	num3 = (ushort)(8 - (int)(num2));
                            -- 	bool flag2;
                            -- 	flag2 = (array [num3] & 1uL) == 1uL;
                            -- 	array [num3] = array [num3] >> 1;
                            -- 	if (flag) {
                            -- 		array [num3] = array [num3] | 0x8000000000000000uL;
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ushort)(8 - (int)(num2));
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\ := SmartResize(unsigned(to_signed(8, 32) - signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32))), 16);
                            \Quire Quire::op_RightShift(Quire,Int32).0.num3\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.6\);
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = (array [num3] & 1uL) == 1uL;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\ := \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) and to_unsigned(1, 64);
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_8\;
                        else 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.775
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_7\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.num\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.12\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_7\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.7\) = to_unsigned(1, 64);
                        \Quire Quire::op_RightShift(Quire,Int32).0.flag2\ := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.8\;
                        -- The following section was transformed from the .NET statement below:
                        -- array [num3] = array [num3] >> 1;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\ := SmartResize(shift_right(\Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)), to_integer(unsigned(SmartResize(to_signed(1, 32), 6) and "111111"))), 64);
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	array [num3] = array [num3] | 0x8000000000000000uL;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Quire Quire::op_RightShift(Quire,Int32).0._State_10\ and ends in state \Quire Quire::op_RightShift(Quire,Int32).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \Quire Quire::op_RightShift(Quire,Int32).0._State_9\.

                        if (\Quire Quire::op_RightShift(Quire,Int32).0.flag\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_10\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5588
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_9\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = flag2;
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.flag\ := \Quire Quire::op_RightShift(Quire,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_RightShift(Quire,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_RightShift(Quire,Int32).0.num2\ := (\Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.11\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_4\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_9\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_10\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num3] = array [num3] | 0x8000000000000000uL;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num3] = array [num3] | 0x8000000000000000uL;
                        -- 
                        -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                        \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\ := \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) or "1000000000000000000000000000000000000000000000000000000000000000";
                        \Quire Quire::op_RightShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_RightShift(Quire,Int32).0.num3\)) := \Quire Quire::op_RightShift(Quire,Int32).0.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_RightShift(Quire,Int32).0._State_8\.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0._State\ = \Quire Quire::op_RightShift(Quire,Int32).0._State_10\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Quire Quire::op_RightShift(Quire,Int32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\ := \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_RightShift(Quire,Int32).0.array\ := \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741;
                            -- 
                            \Quire Quire::op_RightShift(Quire,Int32).0.return\ <= \Quire Quire::op_RightShift(Quire,Int32).0.object18decd06acfdc532dbc361144ffb51e3014947f2ebd90ced7e855611257f9741\;
                            \Quire Quire::op_RightShift(Quire,Int32).0._State\ := \Quire Quire::op_RightShift(Quire,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine end


    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine start
    \Quire Quire::op_LeftShift(Quire,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0._State\: \Quire Quire::op_LeftShift(Quire,Int32).0._States\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.left\: \Lombiq.Arithmetics.Quire\;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.array\: \unsigned64_Array\(0 to 7) := (others => to_unsigned(0, 64));
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.flag\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 64));
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
                \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := to_signed(0, 32);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\ := false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 64);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 16);
            else 
                case \Quire Quire::op_LeftShift(Quire,Int32).0._State\ is 
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._Started\ = true) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= true;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Finished\ <= false;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\ => 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.left\ := \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- right = right & 65535;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\ := \Quire Quire::op_LeftShift(Quire,Int32).0.right\ and to_signed(65535, 32);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.right\ := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- ulong[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new ulong[8];
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := (others => to_unsigned(0, 64));
                        -- The following section was transformed from the .NET statement below:
                        -- Array.Copy (left.Segments, array, 8);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := \Quire Quire::op_LeftShift(Quire,Int32).0.left\.\Segments\(0 to 7);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num) < (int)(right)) {
                        -- 	bool flag;
                        -- 	flag = false;
                        -- 	ushort num2;
                        -- 	num2 = 0;
                        -- 	while ((int)(num2) < 8) {
                        -- 		bool flag2;
                        -- 		flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                        -- 		array [num2] = array [num2] << 1;
                        -- 		if (flag) {
                        -- 			array [num2] = (ulong)(array [num2] | 1uL);
                        -- 		}
                        -- 		flag = flag2;
                        -- 		num2 = (ushort)((int)(num2) + 1);
                        -- 	}
                        -- 	num = (ushort)((int)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\.
                        -- The while loop's condition:
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\ := signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num\), 32)) < (\Quire Quire::op_LeftShift(Quire,Int32).0.right\);
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag;
                            -- 	flag = false;
                            -- 	ushort num2;
                            -- 	num2 = 0;
                            -- 	while ((int)(num2) < 8) {
                            -- 		bool flag2;
                            -- 		flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 		array [num2] = array [num2] << 1;
                            -- 		if (flag) {
                            -- 			array [num2] = (ulong)(array [num2] | 1uL);
                            -- 		}
                            -- 		flag = flag2;
                            -- 		num2 = (ushort)((int)(num2) + 1);
                            -- 	}
                            -- 	num = (ushort)((int)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := false;
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num2) < 8) {
                            -- 	bool flag2;
                            -- 	flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 	array [num2] = array [num2] << 1;
                            -- 	if (flag) {
                            -- 		array [num2] = (ulong)(array [num2] | 1uL);
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_4\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- Quire object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c = new Quire (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\IsNull\ := false;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\Size\ := to_unsigned(0, 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\SegmentCount\ := to_unsigned(0, 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\.\Segments\ := (others => to_unsigned(0, 64));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.array\;
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\ <= SmartResize(unsigned(to_signed(0, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= true;
                        \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\.
                        -- The while loop's condition:
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\ := signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num2\), 32)) < to_signed(8, 32);
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bool flag2;
                            -- 	flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 	array [num2] = array [num2] << 1;
                            -- 	if (flag) {
                            -- 		array [num2] = (ulong)(array [num2] | 1uL);
                            -- 	}
                            -- 	flag = flag2;
                            -- 	num2 = (ushort)((int)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bool flag2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = (array [num2] & 0x8000000000000000uL) == 9223372036854775808uL;
                            -- 
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\ := \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) and "1000000000000000000000000000000000000000000000000000000000000000";
                            -- Since the integer literal 9223372036854775808 was out of the VHDL integer range it was substituted with a binary literal (1000000000000000000000000000000000000000000000000000000000000000).
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.3\) = "1000000000000000000000000000000000000000000000000000000000000000";
                            \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\ := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [num2] = array [num2] << 1;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\ := SmartResize(shift_left(\Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)), to_integer(unsigned(SmartResize(to_signed(1, 32), 6)))), 64);
                            \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) := \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	array [num2] = (ulong)(array [num2] | 1uL);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\ and ends in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\.

                            if (\Quire Quire::op_LeftShift(Quire,Int32).0.flag\) then 
                                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\;
                            end if;
                        else 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8351
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\ => 
                        -- State after the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)((int)(num) + 1);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.8\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_2\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_6\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\ => 
                        -- State after the if-else which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag = flag2;
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.flag\ := \Quire Quire::op_LeftShift(Quire,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (ushort)((int)(num2) + 1);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\Quire Quire::op_LeftShift(Quire,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.num2\ := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.7\);
                        -- Returning to the repeated state of the while loop which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_3\ if the loop wasn't exited with a state change.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\ => 
                        -- True branch of the if-else started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [num2] = (ulong)(array [num2] | 1uL);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [num2] = (ulong)(array [num2] | 1uL);
                        -- 
                        \Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\ := \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) or to_unsigned(1, 64);
                        \Quire Quire::op_LeftShift(Quire,Int32).0.array\(to_integer(\Quire Quire::op_LeftShift(Quire,Int32).0.num2\)) := (\Quire Quire::op_LeftShift(Quire,Int32).0.binaryOperationResult.6\);
                        -- Going to the state after the if-else which was started in state \Quire Quire::op_LeftShift(Quire,Int32).0._State_5\.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0._State\ = \Quire Quire::op_LeftShift(Quire,Int32).0._State_8\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1734
                    when \Quire Quire::op_LeftShift(Quire,Int32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16)
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ <= false;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\ := \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.array\ := \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c;
                            -- 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.return\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.object98816eb007a0736201128f478bf23a4b00f8ebcec108d604d3545922af91a83c\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._State\ := \Quire Quire::op_LeftShift(Quire,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0 state machine end


    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine start
    \UInt64 Quire::op_Explicit(Quire).0._StateMachine\: process (\Clock\) 
        Variable \UInt64 Quire::op_Explicit(Quire).0._State\: \UInt64 Quire::op_Explicit(Quire).0._States\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
        Variable \UInt64 Quire::op_Explicit(Quire).0.x\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= false;
                \UInt64 Quire::op_Explicit(Quire).0.return\ <= to_unsigned(0, 64);
                \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
            else 
                case \UInt64 Quire::op_Explicit(Quire).0._State\ is 
                    when \UInt64 Quire::op_Explicit(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\UInt64 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt64 Quire::op_Explicit(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\UInt64 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= true;
                        else 
                            \UInt64 Quire::op_Explicit(Quire).0._Finished\ <= false;
                            \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\ <= \UInt64 Quire::op_Explicit(Quire).0.x\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt64 Quire::op_Explicit(Quire).0._State_2\ => 
                        \UInt64 Quire::op_Explicit(Quire).0.x\ := \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return x.Segments [0];
                        -- 
                        \UInt64 Quire::op_Explicit(Quire).0.return\ <= \UInt64 Quire::op_Explicit(Quire).0.x\.\Segments\(to_integer(to_signed(0, 32)));
                        \UInt64 Quire::op_Explicit(Quire).0._State\ := \UInt64 Quire::op_Explicit(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine start
    \UInt32 Quire::op_Explicit(Quire).0._StateMachine\: process (\Clock\) 
        Variable \UInt32 Quire::op_Explicit(Quire).0._State\: \UInt32 Quire::op_Explicit(Quire).0._States\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
        Variable \UInt32 Quire::op_Explicit(Quire).0.x\: \Lombiq.Arithmetics.Quire\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= false;
                \UInt32 Quire::op_Explicit(Quire).0.return\ <= to_unsigned(0, 32);
                \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
            else 
                case \UInt32 Quire::op_Explicit(Quire).0._State\ is 
                    when \UInt32 Quire::op_Explicit(Quire).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\UInt32 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt32 Quire::op_Explicit(Quire).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\UInt32 Quire::op_Explicit(Quire).0._Started\ = true) then 
                            \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= true;
                        else 
                            \UInt32 Quire::op_Explicit(Quire).0._Finished\ <= false;
                            \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\ <= \UInt32 Quire::op_Explicit(Quire).0.x\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \UInt32 Quire::op_Explicit(Quire).0._State_2\ => 
                        \UInt32 Quire::op_Explicit(Quire).0.x\ := \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)x.Segments [0];
                        -- 
                        \UInt32 Quire::op_Explicit(Quire).0.return\ <= SmartResize(\UInt32 Quire::op_Explicit(Quire).0.x\.\Segments\(to_integer(to_signed(0, 32))), 32);
                        \UInt32 Quire::op_Explicit(Quire).0._State\ := \UInt32 Quire::op_Explicit(Quire).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire).0 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(Int32).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\;
    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= \Posit32::.ctor(Int32).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) start
    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ := 0;
                            \Quire Posit32::op_Explicit(Posit32).0._Started\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Quire Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32).return.0\ <= \Quire Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Posit32::op_Explicit(Posit32).0._Started\ <= true;
                            \Quire Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Quire Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32).return.0\ <= \Quire Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Posit32::op_Explicit(Posit32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\;
    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= \Posit32::.ctor(UInt32,Boolean).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::FusedSum(Posit32[],Quire).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Started.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.Out.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire)._Finished.0\ <= \Posit32::FusedSum(Posit32[],Quire).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).return.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.return\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).posits.parameter.In.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.posits.parameter.Out\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::FusedSum(Posit32[],Quire).startingValue.parameter.In.0\ <= \Posit32::FusedSum(Posit32[],Quire).0.startingValue.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::.ctor(Quire).0._Started\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Started.0\;
    \Posit32::.ctor(Quire).0.this.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.q.parameter.In\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.Out.0\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire)._Finished.0\ <= \Posit32::.ctor(Quire).0._Finished\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).this.parameter.In.0\ <= \Posit32::.ctor(Quire).0.this.parameter.Out\;
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.Posit32::.ctor(Quire).q.parameter.In.0\ <= \Posit32::.ctor(Quire).0.q.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Quire Quire::op_RightShift(Quire,Int32).0._Started\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Started.0\;
    \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.Out.0\;
    \Quire Quire::op_RightShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).right.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32)._Finished.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0._Finished\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).return.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.return\;
    \Posit32::.ctor(Quire).0.Quire Quire::op_RightShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_RightShift(Quire,Int32).0.left.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \UInt64 Quire::op_Explicit(Quire).0._Started\ <= \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Started.0\;
    \UInt64 Quire::op_Explicit(Quire).0.x.parameter.In\ <= \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire)._Finished.0\ <= \UInt64 Quire::op_Explicit(Quire).0._Finished\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).return.0\ <= \UInt64 Quire::op_Explicit(Quire).0.return\;
    \Posit32::.ctor(Quire).0.UInt64 Quire::op_Explicit(Quire).x.parameter.In.0\ <= \UInt64 Quire::op_Explicit(Quire).0.x.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt64 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire) start
    \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_OnesComplement(Quire).0._Started\ <= true;
                            \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_OnesComplement(Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_OnesComplement(Quire).0._Started\ <= false;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).return.0\ <= \Quire Quire::op_OnesComplement(Quire).0.return\;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\ <= \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_OnesComplement(Quire).0._Started\ <= true;
                            \Quire Quire::op_OnesComplement(Quire).0.q.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_OnesComplement(Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_OnesComplement(Quire).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).return.0\ <= \Quire Quire::op_OnesComplement(Quire).0.return\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire).q.parameter.In.0\ <= \Quire Quire::op_OnesComplement(Quire).0.q.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_OnesComplement(Quire).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_OnesComplement(Quire)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_OnesComplement(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32) start
    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,UInt32).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).return.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.return\;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,UInt32).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,UInt32).0.right.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,UInt32).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).return.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.return\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,UInt32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,UInt32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_Addition(Quire,UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32) start
    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::.ctor(Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= true;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.Out.0\;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.right.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_LeftShift(Quire,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= true;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).return.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.return\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32).left.parameter.In.0\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.left.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_LeftShift(Quire,Int32).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire Quire::op_LeftShift(Quire,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \UInt32 Quire::op_Explicit(Quire).0._Started\ <= \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Started.0\;
    \UInt32 Quire::op_Explicit(Quire).0.x.parameter.In\ <= \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire)._Finished.0\ <= \UInt32 Quire::op_Explicit(Quire).0._Finished\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).return.0\ <= \UInt32 Quire::op_Explicit(Quire).0.return\;
    \Posit32::.ctor(Quire).0.UInt32 Quire::op_Explicit(Quire).x.parameter.In.0\ <= \UInt32 Quire::op_Explicit(Quire).0.x.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Quire::op_Explicit(Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(Lombiq.Arithmetics.Quire).0 (#0):
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
    \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\;
    \Posit32::.ctor(Quire).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 (#0):
    \Posit32::.ctor(UInt32).0._Started\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\;
    \Posit32::.ctor(UInt32).0.this.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32).0.value.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\ <= \Posit32::.ctor(UInt32).0._Finished\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\ <= \Posit32::.ctor(UInt32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16) start
    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.firstSegment.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).firstSegment.parameter.Out.0\;
                            \Quire::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt32,UInt16).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) start
    -- Signal connections for Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0 (#0):
    \Boolean Quire::op_Equality(Quire,Quire).0._Started\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Started.0\;
    \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.Out.0\;
    \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.Out.0\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire)._Finished.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0._Finished\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).return.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.return\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).left.parameter.In.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.left.parameter.Out\;
    \Posit32::FusedSum(Posit32[],Quire).0.Boolean Quire::op_Equality(Quire,Quire).right.parameter.In.0\ <= \Boolean Quire::op_Equality(Quire,Quire).0.right.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Quire::op_Equality(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) start
    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::FusedSum(Lombiq.Arithmetics.Posit32[],Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\) then 
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\ <= \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := AfterFinished;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= false;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).return.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.return\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\;
                                    \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Posit32::FusedSum(Posit32[],Quire).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FusedSum(Posit32[],Quire).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,System.UInt32).0
                case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ := 0;
                            \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= true;
                            \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.Out.0\;
                            \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.In\ <= \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire Quire::op_Addition(Quire,Quire).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= true;
                                    \Quire Quire::op_Addition(Quire,Quire).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).return.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.return\;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).left.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.left.parameter.Out\;
                                    \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire).right.parameter.In.0\ <= \Quire Quire::op_Addition(Quire,Quire).0.right.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire Quire::op_Addition(Quire,Quire).Quire Quire::op_Addition(Quire,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,UInt32).0.Quire Quire::op_Addition(Quire,Quire)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16) start
    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Quire Posit32::op_Explicit(Posit32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_Addition(Lombiq.Arithmetics.Quire,Lombiq.Arithmetics.Quire).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_Addition(Quire,Quire).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_Addition(Quire,Quire).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_RightShift(Lombiq.Arithmetics.Quire,System.Int32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_RightShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_RightShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Quire Lombiq.Arithmetics.Quire::op_LeftShift(Lombiq.Arithmetics.Quire,System.Int32).0
                case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\) then 
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ := 0;
                            \Quire::.ctor(UInt64[],UInt16).0._Started\ <= true;
                            \Quire::.ctor(UInt64[],UInt16).0.this.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.Out.0\;
                            \Quire::.ctor(UInt64[],UInt16).0.size.parameter.In\ <= \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Quire::.ctor(UInt64[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := AfterFinished;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= true;
                                    \Quire::.ctor(UInt64[],UInt16).0._Started\ <= false;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).this.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.this.parameter.Out\;
                                    \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16).segments.parameter.In.0\ <= \Quire::.ctor(UInt64[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Quire::.ctor(UInt64[],UInt16).Quire Quire::op_LeftShift(Quire,Int32).0.runningState.0\ := WaitingForStarted;
                            \Quire Quire::op_LeftShift(Quire,Int32).0.Quire::.ctor(UInt64[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Quire::.ctor(System.UInt64[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32FusedCalculator::CalculateFusedSum(SimpleMemory)._Finished.0\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32FusedCalculator::CalculateFusedSum(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\ else (others => '0');
    \ReadEnable\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*Posit32FusedCalculator::CalculateFusedSum(SimpleMemory).0.binaryOperationResult.1*}]