-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com

    -- Hast_IP's simple interface makes it suitable to plug it into any hardware implementation. The meaning and usage of the
    -- ports are as below:
    -- * MemberId: Each transformed .NET hardware entry point member (i.e. methods that are configured to be available to be
    --             called from the host PC) has a unique zero-based numeric ID. When selecting which one to execute this ID
    --             should be used.
    -- * Started: Indicates whether the execution of a given hardware entry point member is started. Used in the following way:
    --     1. Started is set to TRUE by the consuming framework, after which the execution of the given member starts
    --        internally. The Finished port will be initially set to FALSE.
    --     2. Once the execution is finished, the Finished port will be set to TRUE.
    --     3. The consuming framework sets Started to FALSE, after which Finished will also be set to FALSE.
    -- * Finished: Indicates whether the execution of a given hardware entry point member is complete. See the documentation of
    --             the Started port above on how it is used.
    -- * Reset: Synchronous reset.
    -- * Clock: The main clock.
    -- * DataIn: Data read out from the memory (usually on-board DDR RAM, but depends on the framework) should be assigned to
    --           this port by the framework. The width of this port is always 32b, independent of the hardware platform (if the
    --           bus to the memory is wider then caching needs to be implemented in the framework to make use of it). Inputs of
    --           the algorithm implemented in Hast_IP all come through this port.
    -- * DataOut: Data to be written to the memory is assigned to this port. The width of this port is always 32b, independent
    --            of the hardware platform (if the bus to the memory is wider then caching needs to be implemented in the
    --            framework to make use of it). Outputs of the algorithm implemented in Hast_IP all go through this port.
    -- * CellIndex: Zero-based index of the SimpleMemory memory cell currently being read or written. Transformed code in
    --              Hastlayer can access memory in a simplified fashion by addressing 32b "cells", the accessible physical
    --              memory space being divided up in such individually addressable cells.
    -- * ReadEnable: Indicates whether a memory read operation is initiated. The process of a memory read is as following:
    --     1. ReadEnable is FALSE by default. It's set to TRUE when a memory read is started. CellIndex is set to the index of
    --        the memory cell to be read out.
    --     2. Waiting for ReadsDone to be TRUE.
    --     3. Once ReadsDone is TRUE, data from DataIn will be read out and ReadEnable set to FALSE.
    -- * WriteEnable: Indicates whether a memory write operation is initiated. The process of a memory write is as following:
    --     1. WriteEnable is FALSE by default. It's set to TRUE when a memory write is started. CellIndex is set to the index
    --        of the memory cell to be written and the output data is assigned to DataOut.
    --     2. Waiting for WritesDone to be TRUE.
    --     3. Once WritesDone is TRUE, WriteEnable is set to FALSE.
    -- * ReadsDone: Indicates whether a memory read operation is completed.
    -- * WritesDone: Indicates whether a memory write operation is completed.

end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions, properties) in .NET a state machine was generated. Each state machine's name
    --   corresponds to the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic
    --   operations (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states
    --   can take more than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- Enum declarations start
    type \Hast.Samples.SampleAssembly.SimdOperation\ is (
        \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Add\, 
        \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Subtract\, 
        \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Multiply\, 
        \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Divide\);
    -- Enum declarations end


    -- When put on variables and signals this attribute instructs Vivado not to merge them, thus allowing us to define multi-cycle paths properly.
    attribute dont_touch: string;


    -- Custom inter-dependent type declarations start
    type \unsigned8_Array\ is array (integer range <>) of unsigned(7 downto 0);
    type \signed32_Array\ is array (integer range <>) of signed(31 downto 0);
    type \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\ is record 
        \IsNull\: boolean;
        \R\: unsigned(7 downto 0);
        \G\: unsigned(7 downto 0);
        \B\: unsigned(7 downto 0);
    end record;
    type \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput_Array\ is array (integer range <>) of \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    type \unsigned32_Array\ is array (integer range <>) of unsigned(31 downto 0);
    type \Hast.Samples.SampleAssembly.NumberContainer\ is record 
        \IsNull\: boolean;
        \WasIncreased\: boolean;
        \Number\: unsigned(31 downto 0);
    end record;
    type \Hast.Samples.SampleAssembly.NumberContainer_Array\ is array (integer range <>) of \Hast.Samples.SampleAssembly.NumberContainer\;
    type \boolean_Array\ is array (integer range <>) of boolean;
    type \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\ is record 
        \IsNull\: boolean;
        \Index\: signed(31 downto 0);
        \Step\: signed(31 downto 0);
        \Factor\: signed(31 downto 0);
    end record;
    type \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\ is record 
        \IsNull\: boolean;
        \PixelBytes\: \unsigned8_Array\(0 to 3);
        \ContrastValue\: signed(31 downto 0);
    end record;
    type \Hast.Samples.SampleAssembly.MemoryContainer\ is record 
        \IsNull\: boolean;
    end record;
    type \Hast.Algorithms.Random.RandomXorshiftLfsr16\ is record 
        \IsNull\: boolean;
        \State\: unsigned(15 downto 0);
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._States\ is (
        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_0\, 
        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_1\, 
        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_2\, 
        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_3\, 
        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_4\);
    -- Signals:
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Finished\: boolean := false;
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\: boolean := false;
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\: boolean := false;
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Started\: boolean := false;
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Finished.0\: boolean := false;
    Signal \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \GenomeMatcher::FillTable(SimpleMemory).0._States\ is (
        \GenomeMatcher::FillTable(SimpleMemory).0._State_0\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_1\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_2\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_3\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_4\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_5\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_6\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_7\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_8\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_9\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_10\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_11\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_12\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_13\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_14\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_15\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_16\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_17\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_18\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_19\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_20\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_21\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_22\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_23\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_24\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_25\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_26\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_27\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_28\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_29\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_30\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_31\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_32\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_33\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_34\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_35\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_36\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_37\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_38\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_39\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_40\, 
        \GenomeMatcher::FillTable(SimpleMemory).0._State_41\);
    -- Signals:
    Signal \GenomeMatcher::FillTable(SimpleMemory).0._Finished\: boolean := false;
    Signal \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \GenomeMatcher::FillTable(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \GenomeMatcher::Traceback(SimpleMemory).0._States\ is (
        \GenomeMatcher::Traceback(SimpleMemory).0._State_0\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_1\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_2\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_3\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_4\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_5\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_6\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_7\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_8\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_9\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_10\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_11\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_12\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_13\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_14\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_15\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_16\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_17\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_18\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_19\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_20\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_21\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_22\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_23\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_24\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_25\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_26\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_27\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_28\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_29\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_30\, 
        \GenomeMatcher::Traceback(SimpleMemory).0._State_31\);
    -- Signals:
    Signal \GenomeMatcher::Traceback(SimpleMemory).0._Finished\: boolean := false;
    Signal \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \GenomeMatcher::Traceback(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).0 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).1 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).1 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).2 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).2 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).3 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).3 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).0 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).1 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).1 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).2 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).2 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).3 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).3 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).4 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).4 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).5 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).5 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).6 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).6 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).7 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).7 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).8 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).8 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).9 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).9 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).10 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).10 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).11 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).11 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).12 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).12 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).13 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).13 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).14 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).14 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).15 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).15 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).16 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).16 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).17 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).17 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).18 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).18 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).19 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).19 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).20 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).20 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).21 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).21 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).22 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).22 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).23 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).23 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).24 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).24 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).25 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).25 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).26 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).26 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).27 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).27 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).28 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).28 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).29 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).29 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).30 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).30 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).31 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).31 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).32 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).32 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).33 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).33 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).34 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).34 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).35 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).35 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).36 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).36 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).37 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._States\ is (
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_0\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_1\, 
        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_2\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.Out\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.In\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).37 declarations end


    -- System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._States\ is (
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_0\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_1\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_2\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_3\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_4\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_5\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_6\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_7\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_8\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_9\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_10\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_11\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_12\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_13\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_14\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_15\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_16\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_20\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_21\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_23\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_24\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_25\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_27\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_28\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_29\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_31\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_32\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_33\, 
        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_34\);
    -- Signals:
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Finished\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).stateObject.parameter.Out.0\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.0\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.1\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.2\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.3\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.4\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.5\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.6\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.7\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.8\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.9\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.10\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.11\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.12\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.13\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.14\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.15\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.16\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.17\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.18\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.19\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.20\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.21\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.22\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.23\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.24\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.25\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.26\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.27\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.28\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.29\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.30\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.31\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.32\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.33\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.34\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.35\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.36\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.37\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Started\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).stateObject.parameter.In.0\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Finished.0\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.0\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.1\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.2\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.3\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.4\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.5\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.6\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.7\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.8\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.9\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.10\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.11\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.12\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.13\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.14\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.15\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.16\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.17\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.18\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.19\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.20\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.21\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.22\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.23\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.24\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.25\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.26\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.27\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.28\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.29\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.30\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.31\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.32\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.33\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.34\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.35\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.36\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.37\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.0\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.1\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.2\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.3\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.4\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.5\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.6\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.7\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.8\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.9\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.10\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.11\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.12\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.13\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.14\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.15\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.16\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.17\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.18\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.19\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.20\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.21\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.22\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.23\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.24\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.25\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.26\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.27\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.28\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.29\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.30\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.31\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.32\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.33\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.34\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.35\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.36\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.37\: boolean := false;
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.1\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.2\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.3\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.4\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.5\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.6\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.7\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.8\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.9\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.10\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.11\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.12\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.13\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.14\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.15\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.16\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.17\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.18\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.19\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.20\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.21\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.22\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.23\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.24\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.25\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.26\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.27\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.28\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.29\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.30\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.31\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.32\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.33\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.34\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.35\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.36\: signed(31 downto 0) := to_signed(0, 32);
    Signal \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.37\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangeContrast(SimpleMemory).0._States\ is (
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_0\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_1\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_2\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_3\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_4\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_5\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_6\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_8\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_13\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_14\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_15\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_16\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_17\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_18\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_23\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_24\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_25\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_26\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_27\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_29\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_30\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_31\, 
        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_32\);
    -- Signals:
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.0\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.1\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.2\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.3\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.4\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.5\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.6\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.8\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.9\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.10\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.11\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.12\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.13\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.14\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.15\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.16\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.17\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.18\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.19\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.20\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.21\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.22\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.23\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.24\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.0\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.1\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.2\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.3\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.4\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.5\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.6\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.8\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.9\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.10\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.11\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.12\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.13\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.14\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.15\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.16\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.17\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.18\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.19\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.20\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.21\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.22\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.23\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.24\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.1\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.2\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.3\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.4\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.5\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.6\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.7\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.8\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.9\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.10\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.11\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.12\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.13\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.14\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.15\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.16\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.17\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.18\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.19\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.20\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.21\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.22\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.23\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.24\: boolean := false;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.0\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.1\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.2\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.3\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.4\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.5\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.6\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.8\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.9\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.10\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.11\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.12\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.13\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.14\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.15\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.16\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.17\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.18\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.19\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.20\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.21\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.22\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.23\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.24\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    -- System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).0 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).0 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).1 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).1 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).2 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).2 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).3 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).3 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).4 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).4 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).5 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).5 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).6 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).6 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).7 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).7 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).8 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).8 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).9 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).9 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).10 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).10 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).11 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).11 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).12 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).12 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).13 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).13 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).14 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).14 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).15 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).15 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).16 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).16 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).17 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).17 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).18 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).18 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).19 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).19 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).20 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).20 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).21 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).21 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).22 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).22 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).23 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).23 declarations end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).24 declarations start
    -- State machine states:
    type \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._States\ is (
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_0\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_1\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_2\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_3\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_4\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_5\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_6\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_7\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_9\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\, 
        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\);
    -- Signals:
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Finished\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Started\: boolean := false;
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).24 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).0 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).0 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).1 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).1 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).2 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).2 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).3 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).3 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).4 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).4 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).5 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).5 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).6 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).6 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).7 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).7 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).8 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).8 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).9 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).9 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).10 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).10 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).11 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).11 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).12 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).12 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).13 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).13 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).14 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).14 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).15 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).15 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).16 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).16 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).17 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).17 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).18 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).18 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).19 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).19 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).20 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).20 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).21 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).21 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).22 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).22 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).23 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).23 declarations end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).24 declarations start
    -- State machine states:
    type \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._States\ is (
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_0\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_1\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_2\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_3\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_4\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_5\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_6\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_7\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_8\, 
        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_9\);
    -- Signals:
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Finished\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.Out\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Started\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.In\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\: boolean := false;
    Signal \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).24 declarations end


    -- System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Loopback::Run(SimpleMemory).0._States\ is (
        \Loopback::Run(SimpleMemory).0._State_0\, 
        \Loopback::Run(SimpleMemory).0._State_1\, 
        \Loopback::Run(SimpleMemory).0._State_2\, 
        \Loopback::Run(SimpleMemory).0._State_3\, 
        \Loopback::Run(SimpleMemory).0._State_4\);
    -- Signals:
    Signal \Loopback::Run(SimpleMemory).0._Finished\: boolean := false;
    Signal \Loopback::Run(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Loopback::Run(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Loopback::Run(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \MemoryContainer::.ctor(SimpleMemory).0._States\ is (
        \MemoryContainer::.ctor(SimpleMemory).0._State_0\, 
        \MemoryContainer::.ctor(SimpleMemory).0._State_1\, 
        \MemoryContainer::.ctor(SimpleMemory).0._State_2\);
    -- Signals:
    Signal \MemoryContainer::.ctor(SimpleMemory).0._Finished\: boolean := false;
    Signal \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.Out\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \MemoryContainer::.ctor(SimpleMemory).0._Started\: boolean := false;
    Signal \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.In\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    -- System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput().0 declarations start
    -- State machine states:
    type \MemoryContainer::GetInput().0._States\ is (
        \MemoryContainer::GetInput().0._State_0\, 
        \MemoryContainer::GetInput().0._State_1\, 
        \MemoryContainer::GetInput().0._State_2\, 
        \MemoryContainer::GetInput().0._State_3\);
    -- Signals:
    Signal \MemoryContainer::GetInput().0._Finished\: boolean := false;
    Signal \MemoryContainer::GetInput().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MemoryContainer::GetInput().0.this.parameter.Out\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \MemoryContainer::GetInput().0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \MemoryContainer::GetInput().0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \MemoryContainer::GetInput().0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \MemoryContainer::GetInput().0._Started\: boolean := false;
    Signal \MemoryContainer::GetInput().0.this.parameter.In\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    -- System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput().0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \MemoryTest::Run(SimpleMemory).0._States\ is (
        \MemoryTest::Run(SimpleMemory).0._State_0\, 
        \MemoryTest::Run(SimpleMemory).0._State_1\, 
        \MemoryTest::Run(SimpleMemory).0._State_2\, 
        \MemoryTest::Run(SimpleMemory).0._State_3\, 
        \MemoryTest::Run(SimpleMemory).0._State_4\, 
        \MemoryTest::Run(SimpleMemory).0._State_5\, 
        \MemoryTest::Run(SimpleMemory).0._State_6\, 
        \MemoryTest::Run(SimpleMemory).0._State_7\, 
        \MemoryTest::Run(SimpleMemory).0._State_8\, 
        \MemoryTest::Run(SimpleMemory).0._State_9\);
    -- Signals:
    Signal \MemoryTest::Run(SimpleMemory).0._Finished\: boolean := false;
    Signal \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \MemoryTest::Run(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \MemoryTest::Run(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed declarations start
    -- Shared (global) variables:
    shared Variable \System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed declarations end


    -- System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask declarations start
    -- Shared (global) variables:
    shared Variable \System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask\: signed(63 downto 0) := to_signed(0, 64);
    -- System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).0 declarations start
    -- State machine states:
    type \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._States\ is (
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_0\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_1\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_3\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_4\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_5\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_6\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_7\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\);
    -- Signals:
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Finished\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Started\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).1 declarations start
    -- State machine states:
    type \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._States\ is (
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_0\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_1\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_3\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_4\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_5\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_6\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_7\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\);
    -- Signals:
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Finished\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Started\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).1 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).2 declarations start
    -- State machine states:
    type \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._States\ is (
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_0\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_1\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_3\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_4\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_5\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_6\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_7\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\, 
        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\);
    -- Signals:
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Finished\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Started\: boolean := false;
    Signal \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).2 declarations end


    -- System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._States\ is (
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_0\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_1\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_2\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_3\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_4\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_5\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_6\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_7\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_8\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_9\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_10\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_11\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_12\, 
        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_13\);
    -- Signals:
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Finished\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Started\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.0\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.1\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.2\: boolean := false;
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32).0 declarations start
    -- State machine states:
    type \NumberContainer::.ctor(UInt32).0._States\ is (
        \NumberContainer::.ctor(UInt32).0._State_0\, 
        \NumberContainer::.ctor(UInt32).0._State_1\, 
        \NumberContainer::.ctor(UInt32).0._State_2\);
    -- Signals:
    Signal \NumberContainer::.ctor(UInt32).0._Finished\: boolean := false;
    Signal \NumberContainer::.ctor(UInt32).0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::.ctor(UInt32).0._Started\: boolean := false;
    Signal \NumberContainer::.ctor(UInt32).0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::.ctor(UInt32).0.number.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32).0 declarations start
    -- State machine states:
    type \NumberContainer::IncreaseNumber(UInt32).0._States\ is (
        \NumberContainer::IncreaseNumber(UInt32).0._State_0\, 
        \NumberContainer::IncreaseNumber(UInt32).0._State_1\, 
        \NumberContainer::IncreaseNumber(UInt32).0._State_2\);
    -- Signals:
    Signal \NumberContainer::IncreaseNumber(UInt32).0._Finished\: boolean := false;
    Signal \NumberContainer::IncreaseNumber(UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumber(UInt32).0._Started\: boolean := false;
    Signal \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10().0 declarations start
    -- State machine states:
    type \NumberContainer::IncreaseNumberBy10().0._States\ is (
        \NumberContainer::IncreaseNumberBy10().0._State_0\, 
        \NumberContainer::IncreaseNumberBy10().0._State_1\, 
        \NumberContainer::IncreaseNumberBy10().0._State_2\, 
        \NumberContainer::IncreaseNumberBy10().0._State_3\);
    -- Signals:
    Signal \NumberContainer::IncreaseNumberBy10().0._Finished\: boolean := false;
    Signal \NumberContainer::IncreaseNumberBy10().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberBy10().0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\: boolean := false;
    Signal \NumberContainer::IncreaseNumberBy10().0._Started\: boolean := false;
    Signal \NumberContainer::IncreaseNumberBy10().0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\: boolean := false;
    Signal \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10().0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&).0 declarations start
    -- State machine states:
    type \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._States\ is (
        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_0\, 
        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_1\, 
        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_2\, 
        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_3\);
    -- Signals:
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Finished\: boolean := false;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.Out\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.Out\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\: boolean := false;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Started\: boolean := false;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\: boolean := false;
    Signal \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive().0 declarations start
    -- State machine states:
    type \NumberContainer::get_NumberPlusFive().0._States\ is (
        \NumberContainer::get_NumberPlusFive().0._State_0\, 
        \NumberContainer::get_NumberPlusFive().0._State_1\, 
        \NumberContainer::get_NumberPlusFive().0._State_2\);
    -- Signals:
    Signal \NumberContainer::get_NumberPlusFive().0._Finished\: boolean := false;
    Signal \NumberContainer::get_NumberPlusFive().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainer::get_NumberPlusFive().0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::get_NumberPlusFive().0._Started\: boolean := false;
    Signal \NumberContainer::get_NumberPlusFive().0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive().0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32).0 declarations start
    -- State machine states:
    type \NumberContainer::set_NumberPlusFive(UInt32).0._States\ is (
        \NumberContainer::set_NumberPlusFive(UInt32).0._State_0\, 
        \NumberContainer::set_NumberPlusFive(UInt32).0._State_1\, 
        \NumberContainer::set_NumberPlusFive(UInt32).0._State_2\);
    -- Signals:
    Signal \NumberContainer::set_NumberPlusFive(UInt32).0._Finished\: boolean := false;
    Signal \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::set_NumberPlusFive(UInt32).0._Started\: boolean := false;
    Signal \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainer::set_NumberPlusFive(UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer).0 declarations start
    -- State machine states:
    type \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._States\ is (
        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_0\, 
        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_1\, 
        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_2\, 
        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_3\);
    -- Signals:
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Finished\: boolean := false;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\: boolean := false;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Started\: boolean := false;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\: boolean := false;
    Signal \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \ObjectOrientedShowcase::Run(SimpleMemory).0._States\ is (
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_0\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_1\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_2\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_3\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_4\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_5\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_6\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_7\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_8\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_9\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_10\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_11\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_14\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_15\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_16\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_17\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_18\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_19\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_20\, 
        \ObjectOrientedShowcase::Run(SimpleMemory).0._State_21\);
    -- Signals:
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0._Finished\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.Out.0\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).number.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.Out.0\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0._Started\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.In.0\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.In.0\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.In.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.In.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer\;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.In.0\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Finished.0\: boolean := false;
    Signal \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]).0 declarations start
    -- State machine states:
    type \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._States\ is (
        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_0\, 
        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_1\, 
        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_2\, 
        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_3\, 
        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_4\);
    -- Signals:
    Signal \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Finished\: boolean := false;
    Signal \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.Out\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
    Signal \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Started\: boolean := false;
    Signal \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.In\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
    -- System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input declarations start
    -- Shared (global) variables:
    shared Variable \System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).0 declarations start
    -- State machine states:
    type \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._States\ is (
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_0\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_1\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_4\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\);
    -- Signals:
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Finished\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Started\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).1 declarations start
    -- State machine states:
    type \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._States\ is (
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_0\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_1\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_4\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\);
    -- Signals:
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Finished\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Started\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).1 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).2 declarations start
    -- State machine states:
    type \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._States\ is (
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_0\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_1\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_4\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\, 
        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\);
    -- Signals:
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Finished\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Started\: boolean := false;
    Signal \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).2 declarations end


    -- System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \ParallelAlgorithm::Run(SimpleMemory).0._States\ is (
        \ParallelAlgorithm::Run(SimpleMemory).0._State_0\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_1\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_2\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_3\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_4\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_5\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_6\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_7\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_8\, 
        \ParallelAlgorithm::Run(SimpleMemory).0._State_9\);
    -- Signals:
    Signal \ParallelAlgorithm::Run(SimpleMemory).0._Finished\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.1\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.2\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0._Started\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.0\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.1\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.2\: boolean := false;
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.1\: signed(31 downto 0) := to_signed(0, 32);
    Signal \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.2\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._States\ is (
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_0\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_1\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_2\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_4\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_5\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_6\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_7\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_8\, 
        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_9\);
    -- Signals:
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._States\ is (
        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_0\, 
        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_1\, 
        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_2\, 
        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_3\);
    -- Signals:
    Signal \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Finished\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Started\: boolean := false;
    Signal \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._States\ is (
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_0\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_1\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_2\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_4\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_5\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_7\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_8\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_9\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_10\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_11\, 
        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_12\);
    -- Signals:
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Finished\: boolean := false;
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Started\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._States\ is (
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_0\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_1\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_2\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_5\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_6\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_7\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_8\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_10\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_11\, 
        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_12\);
    -- Signals:
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Finished\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Started\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.0\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.1\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.2\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.0\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.1\: boolean := false;
    Signal \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.2\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).0 declarations start
    -- State machine states:
    type \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._States\ is (
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_0\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_1\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_3\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_4\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_5\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_6\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_7\);
    -- Signals:
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Finished\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Started\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).0 declarations end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).1 declarations start
    -- State machine states:
    type \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._States\ is (
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_0\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_1\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_3\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_4\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_5\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_6\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_7\);
    -- Signals:
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Finished\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Started\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).1 declarations end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).2 declarations start
    -- State machine states:
    type \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._States\ is (
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_0\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_1\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_3\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_4\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_5\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_6\, 
        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_7\);
    -- Signals:
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Finished\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Started\: boolean := false;
    Signal \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).2 declarations end


    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._States\ is (
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_0\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_1\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_2\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_3\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_4\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_5\, 
        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_6\);
    -- Signals:
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Started\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._States\ is (
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_0\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_1\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_2\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_3\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_4\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_5\, 
        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_6\);
    -- Signals:
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Started\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_7\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_8\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_9\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_10\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_7\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_8\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_9\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_10\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_7\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_8\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_9\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_10\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_7\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_8\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_9\, 
        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_10\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_7\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_7\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_7\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 declarations end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 declarations start
    -- State machine states:
    type \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._States\ is (
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_0\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_1\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_2\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_3\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_5\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\, 
        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_7\);
    -- Signals:
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Finished\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Started\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number.parameter.In\: signed(15 downto 0) := to_signed(0, 16);
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\: boolean := false;
    Signal \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 declarations end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \SimdCalculator::AddVectors(SimpleMemory).0._States\ is (
        \SimdCalculator::AddVectors(SimpleMemory).0._State_0\, 
        \SimdCalculator::AddVectors(SimpleMemory).0._State_1\, 
        \SimdCalculator::AddVectors(SimpleMemory).0._State_2\, 
        \SimdCalculator::AddVectors(SimpleMemory).0._State_3\);
    -- Signals:
    Signal \SimdCalculator::AddVectors(SimpleMemory).0._Finished\: boolean := false;
    Signal \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\: \Hast.Samples.SampleAssembly.SimdOperation\;
    Signal \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\: boolean := false;
    Signal \SimdCalculator::AddVectors(SimpleMemory).0._Started\: boolean := false;
    Signal \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \SimdCalculator::SubtractVectors(SimpleMemory).0._States\ is (
        \SimdCalculator::SubtractVectors(SimpleMemory).0._State_0\, 
        \SimdCalculator::SubtractVectors(SimpleMemory).0._State_1\, 
        \SimdCalculator::SubtractVectors(SimpleMemory).0._State_2\, 
        \SimdCalculator::SubtractVectors(SimpleMemory).0._State_3\);
    -- Signals:
    Signal \SimdCalculator::SubtractVectors(SimpleMemory).0._Finished\: boolean := false;
    Signal \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\: \Hast.Samples.SampleAssembly.SimdOperation\;
    Signal \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\: boolean := false;
    Signal \SimdCalculator::SubtractVectors(SimpleMemory).0._Started\: boolean := false;
    Signal \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \SimdCalculator::MultiplyVectors(SimpleMemory).0._States\ is (
        \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_0\, 
        \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_1\, 
        \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_2\, 
        \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_3\);
    -- Signals:
    Signal \SimdCalculator::MultiplyVectors(SimpleMemory).0._Finished\: boolean := false;
    Signal \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\: \Hast.Samples.SampleAssembly.SimdOperation\;
    Signal \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\: boolean := false;
    Signal \SimdCalculator::MultiplyVectors(SimpleMemory).0._Started\: boolean := false;
    Signal \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \SimdCalculator::DivideVectors(SimpleMemory).0._States\ is (
        \SimdCalculator::DivideVectors(SimpleMemory).0._State_0\, 
        \SimdCalculator::DivideVectors(SimpleMemory).0._State_1\, 
        \SimdCalculator::DivideVectors(SimpleMemory).0._State_2\, 
        \SimdCalculator::DivideVectors(SimpleMemory).0._State_3\);
    -- Signals:
    Signal \SimdCalculator::DivideVectors(SimpleMemory).0._Finished\: boolean := false;
    Signal \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\: \Hast.Samples.SampleAssembly.SimdOperation\;
    Signal \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\: boolean := false;
    Signal \SimdCalculator::DivideVectors(SimpleMemory).0._Started\: boolean := false;
    Signal \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\: boolean := false;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation).0 declarations start
    -- State machine states:
    type \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._States\ is (
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_0\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_1\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_2\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_5\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_6\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_8\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_9\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_11\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_12\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_14\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_15\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_16\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_17\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_18\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_19\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_20\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_21\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_22\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_23\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_24\, 
        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_25\);
    -- Signals:
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\: boolean := false;
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.27\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.29\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.30\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.31\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.32\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.33\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.34\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.35\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.36\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.37\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.38\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.39\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.40\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.41\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.42\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.43\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.44\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.45\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.46\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.47\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.48\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.49\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.50\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.51\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.52\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.53\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.54\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.55\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.56\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.57\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.58\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.59\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.60\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.61\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.62\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.63\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.64\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.65\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.66\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.67\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.68\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.69\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89\: signed(31 downto 0) := to_signed(0, 32);
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\: boolean := false;
    Signal \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\: \Hast.Samples.SampleAssembly.SimdOperation\;
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88\: Signal is "true";
    attribute dont_touch of \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89\: Signal is "true";
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation).0 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\: \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._States\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Finished\ <= false;
                \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\ <= false;
                \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\ <= false;
                \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_0\;
            else 
                case \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ is 
                    when \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Finished\ <= true;
                        else 
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Finished\ <= false;
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.FillTable (memory);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\ <= true;
                        \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        if (\GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\ = \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Finished.0\) then 
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- this.Traceback (memory);
                            -- 
                            -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\ <= true;
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        if (\GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\ = \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Finished.0\) then 
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\ <= false;
                            \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State\ := \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \GenomeMatcher::FillTable(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \GenomeMatcher::FillTable(SimpleMemory).0._State\: \GenomeMatcher::FillTable(SimpleMemory).0._States\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_0\;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.3\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.4\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.8\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.3\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.12\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.13\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.14\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.4\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.5\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.6\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.19\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.20\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.flag\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.21\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.num14\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.22\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.23\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.24\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.25\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.26\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.27\: boolean := false;
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.29\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.30\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \GenomeMatcher::FillTable(SimpleMemory).0._Finished\ <= false;
                \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_0\;
                \GenomeMatcher::FillTable(SimpleMemory).0.num\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.0\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.num2\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.1\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.num3\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num4\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num5\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num6\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.3\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.num7\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.4\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.num8\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.5\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.6\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num9\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num10\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num11\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num12\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.num13\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.8\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.2\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.10\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.3\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.12\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.13\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.14\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.16\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.4\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.17\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.5\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.18\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.6\ := (others => '0');
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.19\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.20\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.flag\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.21\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.num14\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.22\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.23\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.24\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.25\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.26\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.27\ := false;
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.28\ := to_signed(0, 32);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.29\ := to_unsigned(0, 16);
                \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.30\ := to_unsigned(0, 16);
            else 
                case \GenomeMatcher::FillTable(SimpleMemory).0._State\ is 
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._Finished\ <= true;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._Finished\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.num\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (ushort)memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.num2\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.1\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ushort)(2 + (int)(num));
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(unsigned(to_signed(2, 32) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32))), 16);
                            \GenomeMatcher::FillTable(SimpleMemory).0.num3\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (ushort)((int)(num3) + (int)(num2));
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num3\), 32)) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num2\), 32))), 16);
                            \GenomeMatcher::FillTable(SimpleMemory).0.num4\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num5;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = (ushort)((int)(num) * (int)(num2));
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32)) * signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num2\), 32))), 16);
                        \GenomeMatcher::FillTable(SimpleMemory).0.num5\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num6\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)(num6) < (int)(num2)) {
                        -- 	ushort num7;
                        -- 	num7 = 0;
                        -- 	while ((int)(num7) < (int)(num)) {
                        -- 		ushort num8;
                        -- 		num8 = (ushort)((int)(num4) + (int)(num7) + (int)(num6) * (int)(num));
                        -- 		ushort num9;
                        -- 		num9 = 0;
                        -- 		ushort num10;
                        -- 		num10 = 0;
                        -- 		ushort num11;
                        -- 		num11 = 0;
                        -- 		ushort num12;
                        -- 		num12 = 0;
                        -- 		ushort num13;
                        -- 		num13 = 0;
                        -- 		if ((int)(num6) != 0) {
                        -- 			num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                        -- 		}
                        -- 		if ((int)(num7) != 0) {
                        -- 			num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                        -- 		}
                        -- 		if ((int)(num7) != 0 && (int)(num6) != 0) {
                        -- 			num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                        -- 		}
                        -- 		if (memory.ReadUInt32 ((int)(2 + (int)(num7))) == memory.ReadUInt32 ((int)((int)(num3) + (int)(num6)))) {
                        -- 			num11 = (ushort)((int)(num11) + 1);
                        -- 		}
                        -- 		bool flag;
                        -- 		flag = (int)(num11) > (int)(num10);
                        -- 		ushort num14;
                        -- 		ushort conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963;
                        -- 		if (flag) {
                        -- 			conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                        -- 		} else {
                        -- 			conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                        -- 		}
                        -- 		num14 = (conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963);
                        -- 		if ((int)(num9) >= (int)(num14)) {
                        -- 			num12 = num9;
                        -- 			num13 = 0;
                        -- 		} else if (flag && (int)(num11) > (int)(num9)) {
                        -- 			num12 = num11;
                        -- 			int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                        -- 			if (((int)(num6) == 0 || (int)(num7) == 0)) {
                        -- 				conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- 			} else {
                        -- 				conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- 			}
                        -- 			num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                        -- 		} else {
                        -- 			num12 = num10;
                        -- 			num13 = 1;
                        -- 		}
                        -- 		memory.WriteUInt32 (num8, num12);
                        -- 		memory.WriteUInt32 ((int)((int)(num8) + (int)(num5)), num13);
                        -- 		num7 = (ushort)((int)(num7) + 1);
                        -- 	}
                        -- 	num6 = (ushort)((int)(num6) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.3\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) < signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num2\), 32));
                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.3\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	ushort num7;
                            -- 	num7 = 0;
                            -- 	while ((int)(num7) < (int)(num)) {
                            -- 		ushort num8;
                            -- 		num8 = (ushort)((int)(num4) + (int)(num7) + (int)(num6) * (int)(num));
                            -- 		ushort num9;
                            -- 		num9 = 0;
                            -- 		ushort num10;
                            -- 		num10 = 0;
                            -- 		ushort num11;
                            -- 		num11 = 0;
                            -- 		ushort num12;
                            -- 		num12 = 0;
                            -- 		ushort num13;
                            -- 		num13 = 0;
                            -- 		if ((int)(num6) != 0) {
                            -- 			num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                            -- 		}
                            -- 		if ((int)(num7) != 0) {
                            -- 			num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                            -- 		}
                            -- 		if ((int)(num7) != 0 && (int)(num6) != 0) {
                            -- 			num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                            -- 		}
                            -- 		if (memory.ReadUInt32 ((int)(2 + (int)(num7))) == memory.ReadUInt32 ((int)((int)(num3) + (int)(num6)))) {
                            -- 			num11 = (ushort)((int)(num11) + 1);
                            -- 		}
                            -- 		bool flag;
                            -- 		flag = (int)(num11) > (int)(num10);
                            -- 		ushort num14;
                            -- 		ushort conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963;
                            -- 		if (flag) {
                            -- 			conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                            -- 		} else {
                            -- 			conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                            -- 		}
                            -- 		num14 = (conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963);
                            -- 		if ((int)(num9) >= (int)(num14)) {
                            -- 			num12 = num9;
                            -- 			num13 = 0;
                            -- 		} else if (flag && (int)(num11) > (int)(num9)) {
                            -- 			num12 = num11;
                            -- 			int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                            -- 			if (((int)(num6) == 0 || (int)(num7) == 0)) {
                            -- 				conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                            -- 			} else {
                            -- 				conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                            -- 			}
                            -- 			num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                            -- 		} else {
                            -- 			num12 = num10;
                            -- 			num13 = 1;
                            -- 		}
                            -- 		memory.WriteUInt32 (num8, num12);
                            -- 		memory.WriteUInt32 ((int)((int)(num8) + (int)(num5)), num13);
                            -- 		num7 = (ushort)((int)(num7) + 1);
                            -- 	}
                            -- 	num6 = (ushort)((int)(num6) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num7;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num7 = 0;
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.num7\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num7) < (int)(num)) {
                            -- 	ushort num8;
                            -- 	num8 = (ushort)((int)(num4) + (int)(num7) + (int)(num6) * (int)(num));
                            -- 	ushort num9;
                            -- 	num9 = 0;
                            -- 	ushort num10;
                            -- 	num10 = 0;
                            -- 	ushort num11;
                            -- 	num11 = 0;
                            -- 	ushort num12;
                            -- 	num12 = 0;
                            -- 	ushort num13;
                            -- 	num13 = 0;
                            -- 	if ((int)(num6) != 0) {
                            -- 		num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                            -- 	}
                            -- 	if ((int)(num7) != 0) {
                            -- 		num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                            -- 	}
                            -- 	if ((int)(num7) != 0 && (int)(num6) != 0) {
                            -- 		num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                            -- 	}
                            -- 	if (memory.ReadUInt32 ((int)(2 + (int)(num7))) == memory.ReadUInt32 ((int)((int)(num3) + (int)(num6)))) {
                            -- 		num11 = (ushort)((int)(num11) + 1);
                            -- 	}
                            -- 	bool flag;
                            -- 	flag = (int)(num11) > (int)(num10);
                            -- 	ushort num14;
                            -- 	ushort conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963;
                            -- 	if (flag) {
                            -- 		conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                            -- 	} else {
                            -- 		conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                            -- 	}
                            -- 	num14 = (conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963);
                            -- 	if ((int)(num9) >= (int)(num14)) {
                            -- 		num12 = num9;
                            -- 		num13 = 0;
                            -- 	} else if (flag && (int)(num11) > (int)(num9)) {
                            -- 		num12 = num11;
                            -- 		int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                            -- 		if (((int)(num6) == 0 || (int)(num7) == 0)) {
                            -- 			conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                            -- 		} else {
                            -- 			conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                            -- 		}
                            -- 		num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                            -- 	} else {
                            -- 		num12 = num10;
                            -- 		num13 = 1;
                            -- 	}
                            -- 	memory.WriteUInt32 (num8, num12);
                            -- 	memory.WriteUInt32 ((int)((int)(num8) + (int)(num5)), num13);
                            -- 	num7 = (ushort)((int)(num7) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_9\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_6\.
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_7\.
                        -- The while loop's condition:
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.4\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32)) < signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32));
                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	ushort num8;
                            -- 	num8 = (ushort)((int)(num4) + (int)(num7) + (int)(num6) * (int)(num));
                            -- 	ushort num9;
                            -- 	num9 = 0;
                            -- 	ushort num10;
                            -- 	num10 = 0;
                            -- 	ushort num11;
                            -- 	num11 = 0;
                            -- 	ushort num12;
                            -- 	num12 = 0;
                            -- 	ushort num13;
                            -- 	num13 = 0;
                            -- 	if ((int)(num6) != 0) {
                            -- 		num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                            -- 	}
                            -- 	if ((int)(num7) != 0) {
                            -- 		num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                            -- 	}
                            -- 	if ((int)(num7) != 0 && (int)(num6) != 0) {
                            -- 		num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                            -- 	}
                            -- 	if (memory.ReadUInt32 ((int)(2 + (int)(num7))) == memory.ReadUInt32 ((int)((int)(num3) + (int)(num6)))) {
                            -- 		num11 = (ushort)((int)(num11) + 1);
                            -- 	}
                            -- 	bool flag;
                            -- 	flag = (int)(num11) > (int)(num10);
                            -- 	ushort num14;
                            -- 	ushort conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963;
                            -- 	if (flag) {
                            -- 		conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                            -- 	} else {
                            -- 		conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                            -- 	}
                            -- 	num14 = (conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963);
                            -- 	if ((int)(num9) >= (int)(num14)) {
                            -- 		num12 = num9;
                            -- 		num13 = 0;
                            -- 	} else if (flag && (int)(num11) > (int)(num9)) {
                            -- 		num12 = num11;
                            -- 		int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                            -- 		if (((int)(num6) == 0 || (int)(num7) == 0)) {
                            -- 			conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                            -- 		} else {
                            -- 			conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                            -- 		}
                            -- 		num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                            -- 	} else {
                            -- 		num12 = num10;
                            -- 		num13 = 1;
                            -- 	}
                            -- 	memory.WriteUInt32 (num8, num12);
                            -- 	memory.WriteUInt32 ((int)((int)(num8) + (int)(num5)), num13);
                            -- 	num7 = (ushort)((int)(num7) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num8;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num8 = (ushort)((int)(num4) + (int)(num7) + (int)(num6) * (int)(num));
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.5\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num4\), 32)) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32));
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_11\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_10\ => 
                        -- State after the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = (ushort)((int)(num6) + 1);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.30\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) + to_signed(1, 32)), 16);
                        \GenomeMatcher::FillTable(SimpleMemory).0.num6\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.30\);
                        -- Returning to the repeated state of the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_6\ if the loop wasn't exited with a state change.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_10\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.6\ := SmartResize(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) * signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32)), 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.7\ := SmartResize(unsigned(\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.5\ + \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.6\), 16);
                        \GenomeMatcher::FillTable(SimpleMemory).0.num8\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.7\);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num9 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num9\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num10 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num10\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num11\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num12\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num13 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num13\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num6) != 0) {
                        -- 	num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.8\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_14\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_15\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_13\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.8\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_14\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_13\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num7) != 0) {
                        -- 	num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.10\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32)) /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_17\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_18\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_16\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.10\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_17\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_14\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num9 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - (int)(num)));
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.9\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num8\), 32)) - signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32));
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.9\);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_15\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.num9\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.2\), 16);
                            -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_12\.
                            if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_15\) then 
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_16\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num7) != 0 && (int)(num6) != 0) {
                        -- 	num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.12\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32)) /= to_signed(0, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.13\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) /= to_signed(0, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.14\ := \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.12\ and \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.13\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_20\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_19\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.14\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_20\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_17\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num10 = (ushort)memory.ReadUInt32 ((int)((int)(num8) - 1));
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.11\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num8\), 32)) - to_signed(1, 32);
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.11\);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_18\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.3\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.num10\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.3\), 16);
                            -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_13\.
                            if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_18\) then 
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_16\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_19\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (memory.ReadUInt32 ((int)(2 + (int)(num7))) == memory.ReadUInt32 ((int)((int)(num3) + (int)(num6)))) {
                        -- 	num11 = (ushort)((int)(num11) + 1);
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.17\ := to_signed(2, 32) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32));
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.17\);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_20\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (ushort)memory.ReadUInt32 ((int)(num8) - (int)(num) - 1);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.15\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num8\), 32)) - signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num\), 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.16\ := \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.15\ - to_signed(1, 32);
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.16\;
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_21\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.4\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.num11\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.4\), 16);
                            -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_16\.
                            if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_21\) then 
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_19\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_22\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.5\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.18\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num3\), 32)) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32));
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_23\ => 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.18\);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_24\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::FillTable(SimpleMemory).0.dataIn.6\ := \DataIn\;
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.19\ := ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.5\) = ConvertStdLogicVectorToUInt32(\GenomeMatcher::FillTable(SimpleMemory).0.dataIn.6\);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_26\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_26\.
                            --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.

                            if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.19\) then 
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_26\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_25\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_25\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_24\.
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (int)(num11) > (int)(num10);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.21\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num11\), 32)) > signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num10\), 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0.flag\ := \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.21\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                        -- } else {
                        -- 	conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_28\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_28\.
                        --     * The false branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_29\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_29\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.flag\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_28\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_26\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_24\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = (ushort)((int)(num11) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (ushort)((int)(num11) + 1);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.20\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num11\), 32)) + to_signed(1, 32)), 16);
                        \GenomeMatcher::FillTable(SimpleMemory).0.num11\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.20\);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_24\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_26\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_27\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- num14 = (conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num14\ := (\GenomeMatcher::FillTable(SimpleMemory).0.conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963\);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num9) >= (int)(num14)) {
                        -- 	num12 = num9;
                        -- 	num13 = 0;
                        -- } else if (flag && (int)(num11) > (int)(num9)) {
                        -- 	num12 = num11;
                        -- 	int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                        -- 	if (((int)(num6) == 0 || (int)(num7) == 0)) {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- 	} else {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- 	}
                        -- 	num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                        -- } else {
                        -- 	num12 = num10;
                        -- 	num13 = 1;
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.22\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num9\), 32)) >= signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num14\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_31\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_31\.
                        --     * The false branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_33\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_30\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.22\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_31\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_28\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num11;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963\ := \GenomeMatcher::FillTable(SimpleMemory).0.num11\;
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_28\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_29\ => 
                        -- False branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963 = num10;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.conditional93a05f9b1b15e63ca7b8fd470612e827af7bea556ce6ef8b4cd87a61e7372963\ := \GenomeMatcher::FillTable(SimpleMemory).0.num10\;
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_25\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_29\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_30\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (num8, num12);
                        -- 
                        -- Begin SimpleMemory write.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= signed(SmartResize(\GenomeMatcher::FillTable(SimpleMemory).0.num8\, 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(SmartResize(\GenomeMatcher::FillTable(SimpleMemory).0.num12\, 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_39\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_31\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num12 = num9;
                        -- 	num13 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = num9;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num12\ := \GenomeMatcher::FillTable(SimpleMemory).0.num9\;
                        -- The following section was transformed from the .NET statement below:
                        -- num13 = 0;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num13\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_31\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_32\ => 
                        -- False branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag && (int)(num11) > (int)(num9)) {
                        -- 	num12 = num11;
                        -- 	int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                        -- 	if (((int)(num6) == 0 || (int)(num7) == 0)) {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- 	} else {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- 	}
                        -- 	num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                        -- } else {
                        -- 	num12 = num10;
                        -- 	num13 = 1;
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.23\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num11\), 32)) > signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num9\), 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.24\ := \GenomeMatcher::FillTable(SimpleMemory).0.flag\ and \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.23\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_35\.
                        --     * The false branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_38\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_38\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_33\.

                        if (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.24\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_34\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3991
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_33\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\.
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_27\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_33\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_34\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num12 = num11;
                        -- 	int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                        -- 	if (((int)(num6) == 0 || (int)(num7) == 0)) {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- 	} else {
                        -- 		conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- 	}
                        -- 	num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = num11;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num12\ := \GenomeMatcher::FillTable(SimpleMemory).0.num11\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(num6) == 0 || (int)(num7) == 0)) {
                        -- 	conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- } else {
                        -- 	conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- }
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.25\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num6\), 32)) = to_signed(0, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.26\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32)) = to_signed(0, 32);
                        \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.27\ := \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.25\ or \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.26\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_36\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_36\.
                        --     * The false branch starts in state \GenomeMatcher::FillTable(SimpleMemory).0._State_37\ and ends in state \GenomeMatcher::FillTable(SimpleMemory).0._State_37\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::FillTable(SimpleMemory).0._State_35\.

                        if ((\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.27\)) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_36\;
                        else 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_35\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- num13 = (ushort)(conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc);
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num13\ := SmartResize(unsigned((\GenomeMatcher::FillTable(SimpleMemory).0.conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc\)), 16);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_35\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_36\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 3;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc\ := to_signed(3, 32);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_36\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_37\ => 
                        -- False branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc = 2;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.conditionala95bb342f2365b611f973c7a0f502bc2d2906eeabacd1d8170e213bfd0e1e9fc\ := to_signed(2, 32);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_34\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_37\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_38\ => 
                        -- False branch of the if-else started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num12 = num10;
                        -- 	num13 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = num10;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num12\ := \GenomeMatcher::FillTable(SimpleMemory).0.num10\;
                        -- The following section was transformed from the .NET statement below:
                        -- num13 = 1;
                        -- 
                        \GenomeMatcher::FillTable(SimpleMemory).0.num13\ := SmartResize(unsigned(to_signed(1, 32)), 16);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_32\.
                        if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_38\) then 
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_39\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 ((int)((int)(num8) + (int)(num5)), num13);
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.28\ := signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num8\), 32)) + signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num5\), 32));
                            -- The last SimpleMemory write just finished, so need to start the next one in the next state.
                            \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_40\ => 
                        -- Begin SimpleMemory write.
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.28\);
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(SmartResize(\GenomeMatcher::FillTable(SimpleMemory).0.num13\, 32));
                        \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_41\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::FillTable(SimpleMemory).0._State_41\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num7 = (ushort)((int)(num7) + 1);
                            -- 
                            \GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.29\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::FillTable(SimpleMemory).0.num7\), 32)) + to_signed(1, 32)), 16);
                            \GenomeMatcher::FillTable(SimpleMemory).0.num7\ := (\GenomeMatcher::FillTable(SimpleMemory).0.binaryOperationResult.29\);
                            -- Returning to the repeated state of the while loop which was started in state \GenomeMatcher::FillTable(SimpleMemory).0._State_7\ if the loop wasn't exited with a state change.
                            if (\GenomeMatcher::FillTable(SimpleMemory).0._State\ = \GenomeMatcher::FillTable(SimpleMemory).0._State_41\) then 
                                \GenomeMatcher::FillTable(SimpleMemory).0._State\ := \GenomeMatcher::FillTable(SimpleMemory).0._State_9\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \GenomeMatcher::Traceback(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \GenomeMatcher::Traceback(SimpleMemory).0._State\: \GenomeMatcher::Traceback(SimpleMemory).0._States\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_0\;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num11\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.num12\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.5\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.6\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.7\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.8\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.9\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.11\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.12\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.13\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.3\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.16\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.17\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.18\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.19\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.20\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.21\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.22\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.23\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.24\: signed(15 downto 0) := to_signed(0, 16);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.25\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.4\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.26\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.27\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.28\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.29\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.30\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.31\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.32\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.33\: boolean := false;
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.number\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.34\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.5\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.35\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.36\: signed(31 downto 0) := to_signed(0, 32);
        Variable \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.37\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \GenomeMatcher::Traceback(SimpleMemory).0._Finished\ <= false;
                \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_0\;
                \GenomeMatcher::Traceback(SimpleMemory).0.num\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.0\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.num2\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.1\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.num3\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num4\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num5\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.num6\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.4\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num7\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.2\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.num8\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num9\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num10\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.5\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.6\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.7\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.8\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.9\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.10\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.12\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.13\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.14\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.3\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.16\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.17\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.18\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.19\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.20\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.21\ := to_unsigned(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.22\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.23\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.24\ := to_signed(0, 16);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.25\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.4\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.26\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.27\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.28\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.29\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.30\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.31\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.32\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.33\ := false;
                \GenomeMatcher::Traceback(SimpleMemory).0.number\ := to_unsigned(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.34\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.5\ := (others => '0');
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.35\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.36\ := to_signed(0, 32);
                \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.37\ := to_signed(0, 32);
            else 
                case \GenomeMatcher::Traceback(SimpleMemory).0._State\ is 
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._Started\ = true) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._Finished\ <= true;
                        else 
                            \GenomeMatcher::Traceback(SimpleMemory).0._Finished\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.num\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (ushort)memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.num2\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.1\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ushort)(2 + (int)(num));
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(unsigned(to_signed(2, 32) + signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num\), 32))), 16);
                            \GenomeMatcher::Traceback(SimpleMemory).0.num3\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (ushort)((int)(num3) + (int)(num2));
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num3\), 32)) + signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num2\), 32))), 16);
                            \GenomeMatcher::Traceback(SimpleMemory).0.num4\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- int num5;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = (int)((int)(num) * (int)(num2));
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num\), 32)) * signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num2\), 32)), 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num5\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = (ushort)((int)(num4) + (int)(num5) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.3\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num4\), 32)) + (\GenomeMatcher::Traceback(SimpleMemory).0.num5\);
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.4\ := SmartResize(unsigned(\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.3\ - to_signed(1, 32)), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num6\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.4\);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = (ushort)memory.ReadUInt32 (num6);
                        -- 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= signed(SmartResize(\GenomeMatcher::Traceback(SimpleMemory).0.num6\, 32));
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_8\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.num7\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.2\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num8;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num8 = 0;
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.num8\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num9;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = 0;
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.num9\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = 0;
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.num10\ := SmartResize(unsigned(to_signed(0, 32)), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- short num11;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num11 = (short)num;
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := signed(\GenomeMatcher::Traceback(SimpleMemory).0.num\);
                            -- The following section was transformed from the .NET statement below:
                            -- short num12;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num12 = (short)num2;
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := signed(\GenomeMatcher::Traceback(SimpleMemory).0.num2\);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num11) >= 0 && (int)(num12) >= 0 && (int)(num7) > 0) {
                            -- 	if ((int)(num11) == 0) {
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 	}
                            -- 	if ((int)(num12) == 0) {
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 	}
                            -- 	num10 = (ushort)memory.ReadUInt32 ((int)((int)(num6) + (int)(num5)));
                            -- 	switch (num10) {
                            -- 	case 2:
                            -- 		num8 = (ushort)((int)(num6) - (int)(num) - 1);
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	case 1:
                            -- 		num8 = (ushort)((int)(num6) - 1);
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		break;
                            -- 	case 0:
                            -- 		num8 = (ushort)((int)(num6) - (int)(num));
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	case 3:
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	}
                            -- 	if ((int)(num8) >= (int)(num4)) {
                            -- 		num9 = (ushort)memory.ReadUInt32 (num8);
                            -- 	}
                            -- 	if (((int)(num10) == 2 && ((int)(num7) == (int)((int)(num9) + 1) || (int)(num8) < (int)(num4))) || (int)(num10) == 3) {
                            -- 		uint number;
                            -- 		number = memory.ReadUInt32 ((int)(2 + (int)(num11)));
                            -- 		memory.WriteUInt32 ((int)((int)((int)(num4) + (int)(2 * num5)) + (int)(num11)), number);
                            -- 	}
                            -- 	num7 = num9;
                            -- 	num6 = num8;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_8\.
                        -- The while loop's condition:
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.5\ := SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) >= to_signed(0, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.6\ := SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) >= to_signed(0, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.7\ := \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.5\ and \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.6\;
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.8\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num7\), 32)) > to_signed(0, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0.9497
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_10\ => 
                        -- State after the while loop which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_8\.
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.9\ := \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.7\ and \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.8\;
                        if (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.9\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	if ((int)(num11) == 0) {
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 	}
                            -- 	if ((int)(num12) == 0) {
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 	}
                            -- 	num10 = (ushort)memory.ReadUInt32 ((int)((int)(num6) + (int)(num5)));
                            -- 	switch (num10) {
                            -- 	case 2:
                            -- 		num8 = (ushort)((int)(num6) - (int)(num) - 1);
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	case 1:
                            -- 		num8 = (ushort)((int)(num6) - 1);
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		break;
                            -- 	case 0:
                            -- 		num8 = (ushort)((int)(num6) - (int)(num));
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	case 3:
                            -- 		num11 = (short)((int)(num11) - 1);
                            -- 		num12 = (short)((int)(num12) - 1);
                            -- 		break;
                            -- 	}
                            -- 	if ((int)(num8) >= (int)(num4)) {
                            -- 		num9 = (ushort)memory.ReadUInt32 (num8);
                            -- 	}
                            -- 	if (((int)(num10) == 2 && ((int)(num7) == (int)((int)(num9) + 1) || (int)(num8) < (int)(num4))) || (int)(num10) == 3) {
                            -- 		uint number;
                            -- 		number = memory.ReadUInt32 ((int)(2 + (int)(num11)));
                            -- 		memory.WriteUInt32 ((int)((int)((int)(num4) + (int)(2 * num5)) + (int)(num11)), number);
                            -- 	}
                            -- 	num7 = num9;
                            -- 	num6 = num8;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(num11) == 0) {
                            -- 	num11 = (short)((int)(num11) - 1);
                            -- }
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.10\ := SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) = to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \GenomeMatcher::Traceback(SimpleMemory).0._State_13\ and ends in state \GenomeMatcher::Traceback(SimpleMemory).0._State_13\.
                            --     * Execution after either branch will continue in the following state: \GenomeMatcher::Traceback(SimpleMemory).0._State_12\.

                            if (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.10\) then 
                                \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_13\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_12\;
                            end if;
                        else 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3878
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_12\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num12) == 0) {
                        -- 	num12 = (short)((int)(num12) - 1);
                        -- }
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.12\ := SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::Traceback(SimpleMemory).0._State_15\ and ends in state \GenomeMatcher::Traceback(SimpleMemory).0._State_15\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::Traceback(SimpleMemory).0._State_14\.

                        if (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.12\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_15\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_13\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = (short)((int)(num11) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (short)((int)(num11) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.11\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.11\);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_11\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_13\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_14\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- num10 = (ushort)memory.ReadUInt32 ((int)((int)(num6) + (int)(num5)));
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.14\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num6\), 32)) + (\GenomeMatcher::Traceback(SimpleMemory).0.num5\);
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.14\);
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_15\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num12 = (short)((int)(num12) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = (short)((int)(num12) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.13\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.13\);
                        -- Going to the state after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_12\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_15\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_16\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.3\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.num10\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.3\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- switch (num10) {
                            -- case 2:
                            -- 	num8 = (ushort)((int)(num6) - (int)(num) - 1);
                            -- 	num11 = (short)((int)(num11) - 1);
                            -- 	num12 = (short)((int)(num12) - 1);
                            -- 	break;
                            -- case 1:
                            -- 	num8 = (ushort)((int)(num6) - 1);
                            -- 	num11 = (short)((int)(num11) - 1);
                            -- 	break;
                            -- case 0:
                            -- 	num8 = (ushort)((int)(num6) - (int)(num));
                            -- 	num12 = (short)((int)(num12) - 1);
                            -- 	break;
                            -- case 3:
                            -- 	num11 = (short)((int)(num11) - 1);
                            -- 	num12 = (short)((int)(num12) - 1);
                            -- 	break;
                            -- }
                            -- 
                            case \GenomeMatcher::Traceback(SimpleMemory).0.num10\ is 
                                when SmartResize(unsigned(to_signed(2, 32)), 16) => 
                                    \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_18\;
                                when SmartResize(unsigned(to_signed(1, 32)), 16) => 
                                    \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_20\;
                                when SmartResize(unsigned(to_signed(0, 32)), 16) => 
                                    \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_21\;
                                when SmartResize(unsigned(to_signed(3, 32)), 16) => 
                                    \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_22\;
                                when others => 
                                    null;
                            end case;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_17\ => 
                        -- State after the case statement which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((int)(num8) >= (int)(num4)) {
                        -- 	num9 = (ushort)memory.ReadUInt32 (num8);
                        -- }
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.25\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num8\), 32)) >= signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num4\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::Traceback(SimpleMemory).0._State_24\ and ends in state \GenomeMatcher::Traceback(SimpleMemory).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::Traceback(SimpleMemory).0._State_23\.

                        if (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.25\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_24\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_18\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = (ushort)((int)(num6) - (int)(num) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.15\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num6\), 32)) - signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num\), 32));
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.16\ := SmartResize(unsigned(\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.15\ - to_signed(1, 32)), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num8\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.16\);
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (short)((int)(num11) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.17\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.17\);
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = (short)((int)(num12) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.9789
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.18\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.18\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_16\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_19\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_20\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = (ushort)((int)(num6) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.19\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num6\), 32)) - to_signed(1, 32)), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num8\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.19\);
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (short)((int)(num11) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.20\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.20\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_16\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_20\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_21\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = (ushort)((int)(num6) - (int)(num));
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.21\ := SmartResize(unsigned(signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num6\), 32)) - signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num\), 32))), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num8\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.21\);
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = (short)((int)(num12) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.22\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.22\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_16\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_21\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_22\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (short)((int)(num11) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.23\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num11\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.23\);
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = (short)((int)(num12) - 1);
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.24\ := SmartResize(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num12\), 32) - to_signed(1, 32), 16);
                        \GenomeMatcher::Traceback(SimpleMemory).0.num12\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.24\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_16\.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_22\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_23\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (((int)(num10) == 2 && ((int)(num7) == (int)((int)(num9) + 1) || (int)(num8) < (int)(num4))) || (int)(num10) == 3) {
                        -- 	uint number;
                        -- 	number = memory.ReadUInt32 ((int)(2 + (int)(num11)));
                        -- 	memory.WriteUInt32 ((int)((int)((int)(num4) + (int)(2 * num5)) + (int)(num11)), number);
                        -- }
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.26\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num10\), 32)) = to_signed(2, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.27\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num9\), 32)) + to_signed(1, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.28\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num7\), 32)) = (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.27\);
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0.8543
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_24\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num9 = (ushort)memory.ReadUInt32 (num8);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num9 = (ushort)memory.ReadUInt32 (num8);
                        -- 
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= signed(SmartResize(\GenomeMatcher::Traceback(SimpleMemory).0.num8\, 32));
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_25\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.4\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.num9\ := SmartResize(ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.4\), 16);
                            -- Going to the state after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_17\.
                            if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_25\) then 
                                \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.29\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num8\), 32)) < signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num4\), 32));
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.30\ := \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.28\ or \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.29\;
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.31\ := \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.26\ and (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.30\);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.32\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num10\), 32)) = to_signed(3, 32);
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.33\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.31\) or \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.32\;

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \GenomeMatcher::Traceback(SimpleMemory).0._State_28\ and ends in state \GenomeMatcher::Traceback(SimpleMemory).0._State_31\.
                        --     * Execution after either branch will continue in the following state: \GenomeMatcher::Traceback(SimpleMemory).0._State_27\.

                        if (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.33\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_28\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9107
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_27\ => 
                        -- State after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num9;
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.num7\ := \GenomeMatcher::Traceback(SimpleMemory).0.num9\;
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = num8;
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.num6\ := \GenomeMatcher::Traceback(SimpleMemory).0.num8\;
                        -- Returning to the repeated state of the while loop which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_8\ if the loop wasn't exited with a state change.
                        if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_27\) then 
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_28\ => 
                        -- True branch of the if-else started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint number;
                        -- 	number = memory.ReadUInt32 ((int)(2 + (int)(num11)));
                        -- 	memory.WriteUInt32 ((int)((int)((int)(num4) + (int)(2 * num5)) + (int)(num11)), number);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint number;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- number = memory.ReadUInt32 ((int)(2 + (int)(num11)));
                        -- 
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.34\ := to_signed(2, 32) + SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32);
                        -- Begin SimpleMemory read.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.34\);
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_29\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \GenomeMatcher::Traceback(SimpleMemory).0.dataIn.5\ := \DataIn\;
                            \GenomeMatcher::Traceback(SimpleMemory).0.number\ := ConvertStdLogicVectorToUInt32(\GenomeMatcher::Traceback(SimpleMemory).0.dataIn.5\);
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 ((int)((int)((int)(num4) + (int)(2 * num5)) + (int)(num11)), number);
                            -- 
                            \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.35\ := SmartResize(to_signed(2, 32) * \GenomeMatcher::Traceback(SimpleMemory).0.num5\, 32);
                            \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.36\ := signed(SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num4\), 32)) + (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.35\);
                            \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_30\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.37\ := (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.36\) + SmartResize((\GenomeMatcher::Traceback(SimpleMemory).0.num11\), 32);
                        -- Begin SimpleMemory write.
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\ <= (\GenomeMatcher::Traceback(SimpleMemory).0.binaryOperationResult.37\);
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\GenomeMatcher::Traceback(SimpleMemory).0.number\);
                        \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \GenomeMatcher::Traceback(SimpleMemory).0._State_31\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- Going to the state after the if-else which was started in state \GenomeMatcher::Traceback(SimpleMemory).0._State_26\.
                            if (\GenomeMatcher::Traceback(SimpleMemory).0._State\ = \GenomeMatcher::Traceback(SimpleMemory).0._State_31\) then 
                                \GenomeMatcher::Traceback(SimpleMemory).0._State\ := \GenomeMatcher::Traceback(SimpleMemory).0._State_27\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).0 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).1 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).1 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).2 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).2 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).3 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).3._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object).3 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).0 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).1 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).1 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).2 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).2 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).3 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).3 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).4 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).4 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).5 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).5 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).6 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).6 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).7 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).7 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).8 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).8 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).9 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).9 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).10 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).10 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).11 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).11 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).12 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).12 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).13 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).13 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).14 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).14 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).15 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).15 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).16 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).16 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).17 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).17 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).18 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).18 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).19 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).19 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).20 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).20 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).21 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).21 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).22 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).22 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).23 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).23 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).24 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).24 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).25 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).25 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).26 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).26 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).27 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).27 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).28 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).28 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).29 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).29 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).30 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).30 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).31 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).31 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).32 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).32 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).33 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).33 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).34 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).34 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).35 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).35 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).36 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).36 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).37 state machine start
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\: \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._States\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_0\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Finished\ <= false;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.return\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_0\;
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.num\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\ is 
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.Out\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_2\ => 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = stateObject.Index + stateObject.Step;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.0\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\.\Index\ + \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\.\Step\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.num\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- return num * stateObject.Factor;
                        -- 
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.1\ := SmartResize(\HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.num\ * \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject\.\Factor\, 32);
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.return\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.binaryOperationResult.1\;
                        \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State\ := \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object).37 state machine end


    -- System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\: \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._States\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_0\;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.3\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\: \signed32_Array\(0 to 37) := (others => to_signed(0, 32));
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.8\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.12\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.17\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.19\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\: \Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+MapObject\;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\: integer range 0 to 37 := 0;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.27\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.29\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.30\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.31\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.32\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.33\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.34\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.35\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.36\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.37\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.38\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.22\: boolean := false;
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.27\: signed(31 downto 0) := to_signed(0, 32);
        attribute dont_touch of \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\: Variable is "true";
        attribute dont_touch of \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\: Variable is "true";
        attribute dont_touch of \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Finished\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\ <= false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_0\;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num\ := to_unsigned(0, 16);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.0\ := (others => '0');
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num2\ := to_unsigned(0, 16);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.1\ := (others => '0');
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num3\ := to_unsigned(0, 16);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.2\ := (others => '0');
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num4\ := to_unsigned(0, 16);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.3\ := (others => '0');
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor2\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num5\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num6\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.5\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.7\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.8\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num8\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.10\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.0\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.12\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.13\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.14\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.16\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.17\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.18\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.19\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\ := 0;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.20\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.1\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.2\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.3\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.4\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.5\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.6\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.7\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.8\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.9\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.10\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.11\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.12\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.13\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.14\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.15\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.16\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.17\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.18\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.19\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.20\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.21\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.22\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.23\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.24\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.25\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.26\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.27\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.28\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.29\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.30\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.31\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.32\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.33\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.34\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.35\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.36\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.37\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.38\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.21\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.22\ := false;
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.23\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.24\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.25\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.26\ := to_signed(0, 32);
                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.27\ := to_signed(0, 32);
            else 
                case \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ is 
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Started\ = true) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Finished\ <= true;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Finished\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num\ := SmartResize(ConvertStdLogicVectorToUInt32(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (ushort)memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num2\ := SmartResize(ConvertStdLogicVectorToUInt32(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.1\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ushort)memory.ReadUInt32 (2);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_6\ => 
                        -- Begin SimpleMemory read.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(2, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_7\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num3\ := SmartResize(ConvertStdLogicVectorToUInt32(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.2\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (ushort)memory.ReadUInt32 (3);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_8\ => 
                        -- Begin SimpleMemory read.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(3, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.3\ := \DataIn\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num4\ := SmartResize(ConvertStdLogicVectorToUInt32(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.dataIn.3\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- int factor;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- factor = (int)num4 / (int)num2;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_10\ => 
                        -- Waiting for the result to appear in \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_11\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\ := signed(SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num4\, 32)) / signed(SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num2\, 32));
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_11\ => 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- int factor2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- factor2 = (int)num3 / (int)num;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_12\ => 
                        -- Waiting for the result to appear in \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_13\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\ := signed(SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num3\, 32)) / signed(SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num\, 32));
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_13\ => 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor2\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = 1 + ((int)(num4) - 1) / 38;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.2\ := signed(SmartResize((\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num4\), 32)) - to_signed(1, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_14\ => 
                        -- Waiting for the result to appear in \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_15\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\ := (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.2\) / to_signed(38, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_15\ => 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.4\ := to_signed(1, 32) + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3\;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num5\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = 1 + ((int)(num3) - 1) / 38;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.5\ := signed(SmartResize((\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num3\), 32)) - to_signed(1, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_16\ => 
                        -- Waiting for the result to appear in \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\ >= to_signed(10, 32)) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\ := to_signed(0, 32);
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.3\ + to_signed(1, 32);
                        end if;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\ := (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.5\) / to_signed(38, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\ => 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.7\ := to_signed(1, 32) + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6\;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num6\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- Task<int>[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new Task<int>[38];
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- int num7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num7 < num5) {
                        -- 	int num8;
                        -- 	num8 = num7 * 38;
                        -- 	int num9;
                        -- 	num9 = 0;
                        -- 	while (num9 < 38) {
                        -- 		MapObject object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02;
                        -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02 = new MapObject { };
                        -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Index = num9;
                        -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Factor = factor;
                        -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Step = num8;
                        -- 		array [num9] = Task.Factory.StartNew (<>c.<>9__7_0 ?? (<>c.<>9__7_0 = <>c.<>9.<CreateMatrix>b__7_0), object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02);
                        -- 		num9 = num9 + 1;
                        -- 	}
                        -- 	Task.WhenAll (array).Wait ();
                        -- 	int num10;
                        -- 	num10 = 0;
                        -- 	while (num10 < 38) {
                        -- 		memory.WriteInt32 (4 + num8 + num10, array [num10].Result);
                        -- 		num10 = num10 + 1;
                        -- 	}
                        -- 	num7 = num7 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.8\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ < \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num5\;
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.8\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num8;
                            -- 	num8 = num7 * 38;
                            -- 	int num9;
                            -- 	num9 = 0;
                            -- 	while (num9 < 38) {
                            -- 		MapObject object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02;
                            -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02 = new MapObject { };
                            -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Index = num9;
                            -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Factor = factor;
                            -- 		object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Step = num8;
                            -- 		array [num9] = Task.Factory.StartNew (<>c.<>9__7_0 ?? (<>c.<>9__7_0 = <>c.<>9.<CreateMatrix>b__7_0), object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02);
                            -- 		num9 = num9 + 1;
                            -- 	}
                            -- 	Task.WhenAll (array).Wait ();
                            -- 	int num10;
                            -- 	num10 = 0;
                            -- 	while (num10 < 38) {
                            -- 		memory.WriteInt32 (4 + num8 + num10, array [num10].Result);
                            -- 		num10 = num10 + 1;
                            -- 	}
                            -- 	num7 = num7 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num8;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num8 = num7 * 38;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.9\ := SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ * to_signed(38, 32), 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num8\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num9;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = 0;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num9 < 38) {
                            -- 	MapObject object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02 = new MapObject { };
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Index = num9;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Factor = factor;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Step = num8;
                            -- 	array [num9] = Task.Factory.StartNew (<>c.<>9__7_0 ?? (<>c.<>9__7_0 = <>c.<>9.<CreateMatrix>b__7_0), object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02);
                            -- 	num9 = num9 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_20\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = 0;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num11 < num6) {
                        -- 	int num12;
                        -- 	num12 = num11 * 38;
                        -- 	int num13;
                        -- 	num13 = 0;
                        -- 	while (num13 < 38) {
                        -- 		MapObject objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a;
                        -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a = new MapObject { };
                        -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Index = num13;
                        -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Factor = factor2;
                        -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Step = num12;
                        -- 		array [num13] = Task.Factory.StartNew (<>c.<>9__7_1 ?? (<>c.<>9__7_1 = <>c.<>9.<CreateMatrix>b__7_1), objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a);
                        -- 		num13 = num13 + 1;
                        -- 	}
                        -- 	Task.WhenAll (array).Wait ();
                        -- 	int num14;
                        -- 	num14 = 0;
                        -- 	while ((int)(num12 + num14) < (int)(num)) {
                        -- 		memory.WriteInt32 (4 + (int)(num2) + num12 + num14, array [num14].Result);
                        -- 		num14 = num14 + 1;
                        -- 	}
                        -- 	num11 = num11 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_20\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.10\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\ < to_signed(38, 32);
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.10\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	MapObject object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02 = new MapObject { };
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Index = num9;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Factor = factor;
                            -- 	object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Step = num8;
                            -- 	array [num9] = Task.Factory.StartNew (<>c.<>9__7_0 ?? (<>c.<>9__7_0 = <>c.<>9.<CreateMatrix>b__7_0), object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02);
                            -- 	num9 = num9 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- MapObject object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02 = new MapObject { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\IsNull\ := false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Index\ := to_signed(0, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Step\ := to_signed(0, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Factor\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Index = num9;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Index\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\;
                            -- The following section was transformed from the .NET statement below:
                            -- object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Factor = factor;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Factor\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor\;
                            -- The following section was transformed from the .NET statement below:
                            -- object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02.Step = num8;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\.\Step\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num8\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [num9] = Task.Factory.StartNew (<>c.<>9__7_0 ?? (<>c.<>9__7_0 = <>c.<>9.<CreateMatrix>b__7_0), object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object)
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).stateObject.parameter.Out.0\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.object9cb32929b1c04ae1ab1be01ef9b108684f309330924a732e3ff9f30da0753e02\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\ <= true;
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = num9 + 1;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.11\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\ + to_signed(1, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num9\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.11\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_21\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object)
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Finished.0\) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.0\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).return.0\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(0) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = 0;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num10 < 38) {
                            -- 	memory.WriteInt32 (4 + num8 + num10, array [num10].Result);
                            -- 	num10 = num10 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_23\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.12\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\ < to_signed(38, 32);
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.12\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteInt32 (4 + num8 + num10, array [num10].Result);
                            -- 	num10 = num10 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (4 + num8 + num10, array [num10].Result);
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.13\ := to_signed(4, 32) + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num8\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.14\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.13\ + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\;
                            -- Begin SimpleMemory write.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.14\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(to_integer(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\)));
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_25\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_24\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + 1;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.16\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ + to_signed(1, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num7\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.16\;
                        -- Returning to the repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_17\ if the loop wasn't exited with a state change.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_24\) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_25\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = num10 + 1;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.15\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\ + to_signed(1, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num10\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.15\;
                            -- Returning to the repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_22\ if the loop wasn't exited with a state change.
                            if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_25\) then 
                                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.17\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ < \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num6\;
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.17\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num12;
                            -- 	num12 = num11 * 38;
                            -- 	int num13;
                            -- 	num13 = 0;
                            -- 	while (num13 < 38) {
                            -- 		MapObject objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a;
                            -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a = new MapObject { };
                            -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Index = num13;
                            -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Factor = factor2;
                            -- 		objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Step = num12;
                            -- 		array [num13] = Task.Factory.StartNew (<>c.<>9__7_1 ?? (<>c.<>9__7_1 = <>c.<>9.<CreateMatrix>b__7_1), objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a);
                            -- 		num13 = num13 + 1;
                            -- 	}
                            -- 	Task.WhenAll (array).Wait ();
                            -- 	int num14;
                            -- 	num14 = 0;
                            -- 	while ((int)(num12 + num14) < (int)(num)) {
                            -- 		memory.WriteInt32 (4 + (int)(num2) + num12 + num14, array [num14].Result);
                            -- 		num14 = num14 + 1;
                            -- 	}
                            -- 	num11 = num11 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num12;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num12 = num11 * 38;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.18\ := SmartResize(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ * to_signed(38, 32), 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.18\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num13;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num13 = 0;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num13 < 38) {
                            -- 	MapObject objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a = new MapObject { };
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Index = num13;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Factor = factor2;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Step = num12;
                            -- 	array [num13] = Task.Factory.StartNew (<>c.<>9__7_1 ?? (<>c.<>9__7_1 = <>c.<>9.<CreateMatrix>b__7_1), objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a);
                            -- 	num13 = num13 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_28\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_27\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_28\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.19\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\ < to_signed(38, 32);
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.19\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	MapObject objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a = new MapObject { };
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Index = num13;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Factor = factor2;
                            -- 	objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Step = num12;
                            -- 	array [num13] = Task.Factory.StartNew (<>c.<>9__7_1 ?? (<>c.<>9__7_1 = <>c.<>9.<CreateMatrix>b__7_1), objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a);
                            -- 	num13 = num13 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- MapObject objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a = new MapObject { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\IsNull\ := false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Index\ := to_signed(0, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Step\ := to_signed(0, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Factor\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Index = num13;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Index\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Factor = factor2;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Factor\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.factor2\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a.Step = num12;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\.\Step\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [num13] = Task.Factory.StartNew (<>c.<>9__7_1 ?? (<>c.<>9__7_1 = <>c.<>9.<CreateMatrix>b__7_1), objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object)
                            case \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\ is 
                                when 0 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.0\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\ <= true;
                                when 1 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.1\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\ <= true;
                                when 2 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.2\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\ <= true;
                                when 3 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.3\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\ <= true;
                                when 4 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.4\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\ <= true;
                                when 5 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.5\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\ <= true;
                                when 6 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.6\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\ <= true;
                                when 7 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.7\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\ <= true;
                                when 8 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.8\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\ <= true;
                                when 9 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.9\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\ <= true;
                                when 10 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.10\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\ <= true;
                                when 11 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.11\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\ <= true;
                                when 12 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.12\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\ <= true;
                                when 13 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.13\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\ <= true;
                                when 14 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.14\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\ <= true;
                                when 15 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.15\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\ <= true;
                                when 16 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.16\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\ <= true;
                                when 17 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.17\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\ <= true;
                                when 18 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.18\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\ <= true;
                                when 19 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.19\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\ <= true;
                                when 20 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.20\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\ <= true;
                                when 21 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.21\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\ <= true;
                                when 22 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.22\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\ <= true;
                                when 23 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.23\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\ <= true;
                                when 24 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.24\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\ <= true;
                                when 25 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.25\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\ <= true;
                                when 26 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.26\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\ <= true;
                                when 27 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.27\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\ <= true;
                                when 28 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.28\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\ <= true;
                                when 29 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.29\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\ <= true;
                                when 30 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.30\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\ <= true;
                                when 31 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.31\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\ <= true;
                                when 32 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.32\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\ <= true;
                                when 33 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.33\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\ <= true;
                                when 34 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.34\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\ <= true;
                                when 35 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.35\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\ <= true;
                                when 36 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.36\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\ <= true;
                                when 37 => 
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.37\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.objecte909f0931ca3a21d4cf74e868fe142ba1c48741a957fecc81389fde4501d762a\;
                                    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\ <= true;
                            end case;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- num13 = num13 + 1;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.20\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\ + to_signed(1, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num13\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.20\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_29\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object)
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.1\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.2\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.3\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.4\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.5\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.6\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.7\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.8\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.9\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.10\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.11\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.12\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.13\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.14\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.15\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.16\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.17\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.18\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.19\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.20\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.21\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.22\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.23\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.24\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.25\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.26\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.27\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.28\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.29\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.30\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.31\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.32\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.33\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.34\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.35\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.36\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.37\ and \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.0\) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\ <= false;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).invocationIndex\ := 0;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.1\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.0\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.2\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.1\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.3\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.2\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.4\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.3\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.5\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.4\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.6\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.5\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.7\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.6\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.8\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.7\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.9\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.8\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.10\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.9\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.11\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.10\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.12\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.11\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.13\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.12\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.14\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.13\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.15\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.14\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.16\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.15\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.17\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.16\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.18\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.17\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.19\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.18\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.20\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.19\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.21\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.20\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.22\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.21\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.23\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.22\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.24\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.23\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.25\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.24\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.26\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.25\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.27\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.26\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.28\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.27\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.29\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.28\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.30\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.29\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.31\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.30\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.32\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.31\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.33\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.32\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.34\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.33\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.35\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.34\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.36\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.35\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.37\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.36\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.38\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.37\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(0) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.1\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(1) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.2\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(2) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.3\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(3) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.4\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(4) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.5\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(5) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.6\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(6) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.7\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(7) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.8\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(8) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.9\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(9) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.10\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(10) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.11\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(11) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.12\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(12) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.13\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(13) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.14\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(14) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.15\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(15) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.16\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(16) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.17\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(17) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.18\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(18) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.19\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(19) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.20\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(20) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.21\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(21) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.22\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(22) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.23\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(23) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.24\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(24) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.25\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(25) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.26\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(26) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.27\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(27) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.28\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(28) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.29\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(29) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.30\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(30) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.31\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(31) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.32\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(32) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.33\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(33) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.34\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(34) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.35\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(35) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.36\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(36) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.37\;
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(37) := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.return.38\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num14;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num14 = 0;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)(num12 + num14) < (int)(num)) {
                            -- 	memory.WriteInt32 (4 + (int)(num2) + num12 + num14, array [num14].Result);
                            -- 	num14 = num14 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_31\ => 
                        -- Repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\.
                        -- The while loop's condition:
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.21\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\ + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.22\ := (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.21\) < signed(SmartResize((\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num\), 32));
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.22\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteInt32 (4 + (int)(num2) + num12 + num14, array [num14].Result);
                            -- 	num14 = num14 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (4 + (int)(num2) + num12 + num14, array [num14].Result);
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.23\ := to_signed(4, 32) + signed(SmartResize((\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num2\), 32));
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_33\;
                        else 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_32\ => 
                        -- State after the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num11 + 1;
                        -- 
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.27\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ + to_signed(1, 32);
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num11\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.27\;
                        -- Returning to the repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_19\ if the loop wasn't exited with a state change.
                        if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_32\) then 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_33\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.24\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.23\ + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num12\;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.25\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.24\ + \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\;
                        -- Begin SimpleMemory write.
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.25\;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.array\(to_integer(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\)));
                        \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_34\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_34\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num14 = num14 + 1;
                            -- 
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.26\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\ + to_signed(1, 32);
                            \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.num14\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.26\;
                            -- Returning to the repeated state of the while loop which was started in state \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_30\ if the loop wasn't exited with a state change.
                            if (\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ = \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_34\) then 
                                \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State\ := \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._State_31\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\: \ImageContrastModifier::ChangeContrast(SimpleMemory).0._States\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_0\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.1\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput_Array\(0 to 24);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.10\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.12\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.13\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.pixelBytes\: \unsigned8_Array\(0 to 3) := (others => to_unsigned(0, 8));
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\: integer range 0 to 24 := 0;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.0\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.1\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.2\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.3\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.4\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.5\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.6\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.8\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.9\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.10\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.11\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.12\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.13\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.14\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.15\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.16\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.17\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.18\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.19\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.20\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.21\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.22\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.23\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.24\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.18\: boolean := false;
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.cellIndex\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\: \unsigned8_Array\(0 to 2) := (others => to_unsigned(0, 8));
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
        attribute dont_touch of \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Finished\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\ <= false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_0\;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num\ := to_unsigned(0, 16);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.0\ := (others => '0');
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num2\ := to_unsigned(0, 16);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.1\ := (others => '0');
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.2\ := (others => '0');
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.0\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.1\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.8\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.10\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.11\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.12\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.13\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.pixelBytes\ := (others => to_unsigned(0, 8));
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.14\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.15\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.16\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\ := (others => '0');
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\ := 0;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.17\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.18\ := false;
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.cellIndex\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.19\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.20\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.21\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\ := (others => to_unsigned(0, 8));
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.22\ := to_signed(0, 32);
                \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.23\ := to_signed(0, 32);
            else 
                case \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ is 
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._Started\ = true) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._Started\ = true) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Finished\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (ushort)memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num\ := SmartResize(ConvertStdLogicVectorToUInt32(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- ushort num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (ushort)memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num2\ := SmartResize(ConvertStdLogicVectorToUInt32(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.1\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- int num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = memory.ReadInt32 (2);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_6\ => 
                        -- Begin SimpleMemory read.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(2, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ := ConvertStdLogicVectorToInt32(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- if (num3 > 100) {
                            -- 	num3 = 100;
                            -- } else if (num3 < -100) {
                            -- 	num3 = -100;
                            -- }
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.0\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ > to_signed(100, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\ and ends in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\.
                            --     * The false branch starts in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\ and ends in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\.
                            --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_8\.

                            if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.0\) then 
                                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\;
                            else 
                                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_8\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (100 + num3 * 1000) / 100;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.3\ := to_signed(100, 32) + \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.2\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = 100;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 100;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ := to_signed(100, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_9\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num3 < -100) {
                        -- 	num3 = -100;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.1\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ < to_signed(-100, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\ and ends in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\.

                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.1\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_7\.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = -100;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = -100;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ := to_signed(-100, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_10\.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_12\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_13\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_14\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\ := (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.3\) / to_signed(100, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_14\ => 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- Task<PixelProcessingTaskOutput>[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new Task<PixelProcessingTaskOutput>[25];
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = (int)((int)(num2) * (int)(num));
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.5\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num2\), 32)) * signed(SmartResize((\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num\), 32)), 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\ := (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = num4 / 25;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_15\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_16\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\ / to_signed(25, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_16\ => 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num4 - num4 / 25 * 25 != 0) {
                        -- 	num5 = num5 + 1;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_17\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_18\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\ / to_signed(25, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_18\ => 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.8\ := SmartResize(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7\ * to_signed(25, 32), 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.9\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num4\ - \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.8\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.10\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.9\ /= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\ and ends in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\.

                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.10\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = 0;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num6 < num5) {
                        -- 	int num7;
                        -- 	num7 = 0;
                        -- 	while (num7 < 25) {
                        -- 		byte[] pixelBytes;
                        -- 		pixelBytes = memory.Read4Bytes (num6 * 25 + num7 + 3);
                        -- 		PixelProcessingTaskInput objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf;
                        -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf = new PixelProcessingTaskInput { };
                        -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.ContrastValue = num3;
                        -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.PixelBytes = pixelBytes;
                        -- 		array [num7] = Task.Factory.StartNew ((Func<object, PixelProcessingTaskOutput>)this.<ChangeContrast>b__7_0, objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf);
                        -- 		num7 = num7 + 1;
                        -- 	}
                        -- 	Task.WhenAll (array).Wait ();
                        -- 	int num8;
                        -- 	num8 = 0;
                        -- 	while (num8 < 25) {
                        -- 		int cellIndex;
                        -- 		cellIndex = num6 * 25 + num8 + 3;
                        -- 		byte[] array2;
                        -- 		array2 = new byte[3];
                        -- 		array2 [0] = array [num8].Result.R;
                        -- 		array2 [1] = array [num8].Result.G;
                        -- 		array2 [2] = array [num8].Result.B;
                        -- 		memory.Write4Bytes (cellIndex, array2);
                        -- 		num8 = num8 + 1;
                        -- 	}
                        -- 	num6 = num6 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num5 = num5 + 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = num5 + 1;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.11\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\ + to_signed(1, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.11\;
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_19\.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_21\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\ => 
                        -- Repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\.
                        -- The while loop's condition:
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.12\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ < \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num5\;
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.12\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num7;
                            -- 	num7 = 0;
                            -- 	while (num7 < 25) {
                            -- 		byte[] pixelBytes;
                            -- 		pixelBytes = memory.Read4Bytes (num6 * 25 + num7 + 3);
                            -- 		PixelProcessingTaskInput objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf;
                            -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf = new PixelProcessingTaskInput { };
                            -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.ContrastValue = num3;
                            -- 		objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.PixelBytes = pixelBytes;
                            -- 		array [num7] = Task.Factory.StartNew ((Func<object, PixelProcessingTaskOutput>)this.<ChangeContrast>b__7_0, objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf);
                            -- 		num7 = num7 + 1;
                            -- 	}
                            -- 	Task.WhenAll (array).Wait ();
                            -- 	int num8;
                            -- 	num8 = 0;
                            -- 	while (num8 < 25) {
                            -- 		int cellIndex;
                            -- 		cellIndex = num6 * 25 + num8 + 3;
                            -- 		byte[] array2;
                            -- 		array2 = new byte[3];
                            -- 		array2 [0] = array [num8].Result.R;
                            -- 		array2 [1] = array [num8].Result.G;
                            -- 		array2 [2] = array [num8].Result.B;
                            -- 		memory.Write4Bytes (cellIndex, array2);
                            -- 		num8 = num8 + 1;
                            -- 	}
                            -- 	num6 = num6 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num7;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num7 = 0;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num7 < 25) {
                            -- 	byte[] pixelBytes;
                            -- 	pixelBytes = memory.Read4Bytes (num6 * 25 + num7 + 3);
                            -- 	PixelProcessingTaskInput objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf;
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf = new PixelProcessingTaskInput { };
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.ContrastValue = num3;
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.PixelBytes = pixelBytes;
                            -- 	array [num7] = Task.Factory.StartNew ((Func<object, PixelProcessingTaskOutput>)this.<ChangeContrast>b__7_0, objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf);
                            -- 	num7 = num7 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_24\;
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_23\ => 
                        -- State after the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_24\ => 
                        -- Repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\.
                        -- The while loop's condition:
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.13\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\ < to_signed(25, 32);
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.13\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	byte[] pixelBytes;
                            -- 	pixelBytes = memory.Read4Bytes (num6 * 25 + num7 + 3);
                            -- 	PixelProcessingTaskInput objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf;
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf = new PixelProcessingTaskInput { };
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.ContrastValue = num3;
                            -- 	objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.PixelBytes = pixelBytes;
                            -- 	array [num7] = Task.Factory.StartNew ((Func<object, PixelProcessingTaskOutput>)this.<ChangeContrast>b__7_0, objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf);
                            -- 	num7 = num7 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- byte[] pixelBytes;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- pixelBytes = memory.Read4Bytes (num6 * 25 + num7 + 3);
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.14\ := SmartResize(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ * to_signed(25, 32), 32);
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_26\;
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_25\ => 
                        -- State after the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.15\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.14\ + \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.16\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.15\ + to_signed(3, 32);
                        -- Begin SimpleMemory read.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.16\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_27\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_27\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\ := \DataIn\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.pixelBytes\ := (unsigned(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\(7 downto 0)), unsigned(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\(15 downto 8)), unsigned(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\(23 downto 16)), unsigned(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.dataIn.3\(31 downto 24)));
                            -- The following section was transformed from the .NET statement below:
                            -- PixelProcessingTaskInput objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf = new PixelProcessingTaskInput { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\.\IsNull\ := false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\.\PixelBytes\ := (others => to_unsigned(0, 8));
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\.\ContrastValue\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.ContrastValue = num3;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\.\ContrastValue\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num3\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf.PixelBytes = pixelBytes;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\.\PixelBytes\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.pixelBytes\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [num7] = Task.Factory.StartNew ((Func<object, PixelProcessingTaskOutput>)this.<ChangeContrast>b__7_0, objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf);
                            -- 
                            -- Starting state machine invocation for the following method: Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object)
                            case \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\ is 
                                when 0 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.0\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\ <= true;
                                when 1 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.1\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\ <= true;
                                when 2 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.2\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\ <= true;
                                when 3 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.3\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\ <= true;
                                when 4 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.4\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\ <= true;
                                when 5 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.5\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\ <= true;
                                when 6 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.6\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\ <= true;
                                when 7 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.7\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\ <= true;
                                when 8 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.8\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\ <= true;
                                when 9 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.9\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\ <= true;
                                when 10 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.10\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\ <= true;
                                when 11 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.11\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\ <= true;
                                when 12 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.12\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\ <= true;
                                when 13 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.13\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\ <= true;
                                when 14 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.14\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\ <= true;
                                when 15 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.15\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\ <= true;
                                when 16 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.16\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\ <= true;
                                when 17 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.17\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\ <= true;
                                when 18 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.18\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\ <= true;
                                when 19 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.19\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\ <= true;
                                when 20 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.20\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\ <= true;
                                when 21 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.21\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\ <= true;
                                when 22 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.22\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\ <= true;
                                when 23 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.23\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\ <= true;
                                when 24 => 
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.24\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.objecte152f956f9b6be7585fc1c80f0edc04392ad752829e30bb491a35a2ce29f38bf\;
                                    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\ <= true;
                            end case;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- num7 = num7 + 1;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.17\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\ + to_signed(1, 32);
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num7\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.17\;
                            -- Returning to the repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\ if the loop wasn't exited with a state change.
                            if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_27\) then 
                                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_24\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object)
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.1\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.2\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.3\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.4\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.5\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.6\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.7\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.8\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.9\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.10\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.11\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.12\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.13\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.14\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.15\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.16\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.17\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.18\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.19\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.20\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.21\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.22\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.23\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.24\ and \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.0\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\ <= false;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).invocationIndex\ := 0;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.0\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.0\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.1\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.1\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.2\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.2\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.3\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.3\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.4\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.4\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.5\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.5\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.6\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.6\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.7\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.7\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.8\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.8\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.9\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.9\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.10\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.10\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.11\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.11\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.12\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.12\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.13\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.13\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.14\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.14\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.15\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.15\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.16\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.16\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.17\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.17\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.18\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.18\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.19\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.19\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.20\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.20\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.21\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.21\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.22\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.22\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.23\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.23\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.24\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.24\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(0) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.0\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(1) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.1\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(2) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.2\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(3) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.3\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(4) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.4\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(5) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.5\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(6) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.6\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(7) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.7\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(8) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.8\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(9) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.9\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(10) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.10\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(11) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.11\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(12) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.12\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(13) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.13\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(14) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.14\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(15) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.15\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(16) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.16\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(17) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.17\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(18) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.18\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(19) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.19\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(20) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.20\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(21) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.21\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(22) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.22\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(23) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.23\;
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(24) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.return.24\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num8;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num8 = 0;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num8 < 25) {
                            -- 	int cellIndex;
                            -- 	cellIndex = num6 * 25 + num8 + 3;
                            -- 	byte[] array2;
                            -- 	array2 = new byte[3];
                            -- 	array2 [0] = array [num8].Result.R;
                            -- 	array2 [1] = array [num8].Result.G;
                            -- 	array2 [2] = array [num8].Result.B;
                            -- 	memory.Write4Bytes (cellIndex, array2);
                            -- 	num8 = num8 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_29\ => 
                        -- Repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\.
                        -- The while loop's condition:
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.18\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\ < to_signed(25, 32);
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.18\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int cellIndex;
                            -- 	cellIndex = num6 * 25 + num8 + 3;
                            -- 	byte[] array2;
                            -- 	array2 = new byte[3];
                            -- 	array2 [0] = array [num8].Result.R;
                            -- 	array2 [1] = array [num8].Result.G;
                            -- 	array2 [2] = array [num8].Result.B;
                            -- 	memory.Write4Bytes (cellIndex, array2);
                            -- 	num8 = num8 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int cellIndex;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- cellIndex = num6 * 25 + num8 + 3;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.19\ := SmartResize(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ * to_signed(25, 32), 32);
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_31\;
                        else 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6961
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_30\ => 
                        -- State after the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\.
                        -- The following section was transformed from the .NET statement below:
                        -- num6 = num6 + 1;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.23\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ + to_signed(1, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num6\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.23\;
                        -- Returning to the repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_20\ if the loop wasn't exited with a state change.
                        if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_30\) then 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_31\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.20\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.19\ + \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.21\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.20\ + to_signed(3, 32);
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.cellIndex\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.21\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte[] array2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array2 = new byte[3];
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\ := (others => to_unsigned(0, 8));
                        -- The following section was transformed from the .NET statement below:
                        -- array2 [0] = array [num8].Result.R;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(to_integer(to_signed(0, 32))) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(to_integer(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\)).\R\;
                        -- The following section was transformed from the .NET statement below:
                        -- array2 [1] = array [num8].Result.G;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(to_integer(to_signed(1, 32))) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(to_integer(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\)).\G\;
                        -- The following section was transformed from the .NET statement below:
                        -- array2 [2] = array [num8].Result.B;
                        -- 
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(to_integer(to_signed(2, 32))) := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.array\(to_integer(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\)).\B\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.Write4Bytes (cellIndex, array2);
                        -- 
                        -- Begin SimpleMemory write.
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.cellIndex\;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\(7 downto 0) <= std_logic_vector(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(0));
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\(15 downto 8) <= std_logic_vector(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(1));
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\(23 downto 16) <= std_logic_vector(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.array2\(2));
                        \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_32\;
                        -- Clock cycles needed to complete this state (approximation): 0.6526
                    when \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_32\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num8 = num8 + 1;
                            -- 
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.22\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\ + to_signed(1, 32);
                            \ImageContrastModifier::ChangeContrast(SimpleMemory).0.num8\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.22\;
                            -- Returning to the repeated state of the while loop which was started in state \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_28\ if the loop wasn't exited with a state change.
                            if (\ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ = \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_32\) then 
                                \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State\ := \ImageContrastModifier::ChangeContrast(SimpleMemory).0._State_29\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).0 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).0 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).1 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).1 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).2 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).2 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).3 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).3 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).4 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).4 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).5 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).5 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).6 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).6 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).7 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).7 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).8 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).8 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).9 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).9 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).10 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).10 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).11 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).11 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).12 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).12 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).13 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).13 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).14 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).14 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).15 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).15 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).16 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).16 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).17 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).17 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).18 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).18 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).19 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).19 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).20 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).20 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).21 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).21 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).22 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).22 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).23 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).23 state machine end


    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).24 state machine start
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\: \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._States\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_0\;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.8\: boolean := false;
        Variable \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\: Variable is "true";
        attribute dont_touch of \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Finished\ <= false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.return\ <= to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_0\;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel\ := to_unsigned(0, 8);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.3\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.5\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.6\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.8\ := false;
                \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.9\ := false;
            else 
                case \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ is 
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Started\ = true) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Finished\ <= true;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Finished\ <= false;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_2\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel.parameter.In\;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(pixel) * 1000 / 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel\), 32)) * to_signed(1000, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_3\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_4\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.0\ / to_signed(255, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_4\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num - 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ - to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * contrastValue;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.3\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ * \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue\, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_5\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_6\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.1\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_6\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 500;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.5\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ + to_signed(500, 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num * 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.6\ := SmartResize(\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ * to_signed(255, 32), 32);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num / 1000;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_7\ => 
                        -- Waiting for the result to appear in \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\ >= to_signed(10, 32)) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\;
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\ := to_signed(0, 32);
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.clockCyclesWaitedForBinaryOperationResult.2\ + to_signed(1, 32);
                        end if;
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ / to_signed(1000, 32);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\ => 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (num < 0) {
                        -- 	num = 0;
                        -- } else if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.8\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ < to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\.
                        --     * The false branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_9\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.8\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\;
                        else 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_9\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (byte)num;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.return\ <= SmartResize(unsigned(\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\), 8);
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_10\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\ => 
                        -- False branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 255) {
                        -- 	num = 255;
                        -- }
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.9\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ > to_signed(255, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\ and ends in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\.
                        --     * Execution after either branch will continue in the following state: \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\.

                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.9\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\ => 
                        -- State after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\.
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_8\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\ => 
                        -- True branch of the if-else started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 255;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 255;
                        -- 
                        \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.num\ := to_signed(255, 32);
                        -- Going to the state after the if-else which was started in state \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_11\.
                        if (\ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ = \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_13\) then 
                            \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State\ := \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32).24 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).0 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).0 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).1 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).1 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).2 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).2 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).3 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).3 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).4 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).4 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).5 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).5 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).6 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).6 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).7 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).7 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).8 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).8 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).9 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).9 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).10 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).10 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).11 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).11 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).12 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).12 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).13 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).13 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).14 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).14 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).15 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).15 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).16 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).16 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).17 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).17 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).18 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).18 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).19 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).19 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).20 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).20 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).21 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).21 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).22 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).22 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).23 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).23 state machine end


    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).24 state machine start
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._StateMachine\: process (\Clock\) 
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\: \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._States\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_0\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskInput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\: \Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput\;
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Finished\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= to_signed(0, 32);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_0\;
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.0\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.1\ := to_unsigned(0, 8);
                \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.2\ := to_unsigned(0, 8);
            else 
                case \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ is 
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Started\ = true) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Finished\ <= true;
                        else 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Finished\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.Out\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_2\ => 
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- PixelProcessingTaskOutput objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7 = new PixelProcessingTaskOutput { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\IsNull\ := false;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := to_unsigned(0, 8);
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.B = this.ChangePixelValue (inputObject.PixelBytes [2], inputObject.ContrastValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\PixelBytes\(to_integer(to_signed(2, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.0\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\B\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.G = this.ChangePixelValue (inputObject.PixelBytes [1], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\PixelBytes\(to_integer(to_signed(1, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.1\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\G\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7.R = this.ChangePixelValue (inputObject.PixelBytes [0], inputObject.ContrastValue);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_7\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\PixelBytes\(to_integer(to_signed(0, 32)));
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject\.\ContrastValue\;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= true;
                        \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32)
                        if (\ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ = \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\) then 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\ <= false;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.2\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\.\R\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7;
                            -- 
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.objecta9703dde4a7251bc2f667ebdc09be11866efcb506f55c0c9dbe4b8a4d4dde8f7\;
                            \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State\ := \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).24 state machine end


    -- System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Loopback::Run(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Loopback::Run(SimpleMemory).0._State\: \Loopback::Run(SimpleMemory).0._States\ := \Loopback::Run(SimpleMemory).0._State_0\;
        Variable \Loopback::Run(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \Loopback::Run(SimpleMemory).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Loopback::Run(SimpleMemory).0._Finished\ <= false;
                \Loopback::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Loopback::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_0\;
                \Loopback::Run(SimpleMemory).0.dataIn.0\ := (others => '0');
                \Loopback::Run(SimpleMemory).0.binaryOperationResult.0\ := to_signed(0, 32);
            else 
                case \Loopback::Run(SimpleMemory).0._State\ is 
                    when \Loopback::Run(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Loopback::Run(SimpleMemory).0._Started\ = true) then 
                            \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Loopback::Run(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Loopback::Run(SimpleMemory).0._Started\ = true) then 
                            \Loopback::Run(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Loopback::Run(SimpleMemory).0._Finished\ <= false;
                            \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Loopback::Run(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteInt32 (0, memory.ReadInt32 (0) + 1);
                        -- 
                        -- Begin SimpleMemory read.
                        \Loopback::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Loopback::Run(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Loopback::Run(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Loopback::Run(SimpleMemory).0.binaryOperationResult.0\ := ConvertStdLogicVectorToInt32(\Loopback::Run(SimpleMemory).0.dataIn.0\) + to_signed(1, 32);
                            -- Begin SimpleMemory write.
                            \Loopback::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \Loopback::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\Loopback::Run(SimpleMemory).0.binaryOperationResult.0\);
                            \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \Loopback::Run(SimpleMemory).0._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Loopback::Run(SimpleMemory).0._State\ := \Loopback::Run(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \MemoryContainer::.ctor(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \MemoryContainer::.ctor(SimpleMemory).0._State\: \MemoryContainer::.ctor(SimpleMemory).0._States\ := \MemoryContainer::.ctor(SimpleMemory).0._State_0\;
        Variable \MemoryContainer::.ctor(SimpleMemory).0.this\: \Hast.Samples.SampleAssembly.MemoryContainer\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MemoryContainer::.ctor(SimpleMemory).0._Finished\ <= false;
                \MemoryContainer::.ctor(SimpleMemory).0._State\ := \MemoryContainer::.ctor(SimpleMemory).0._State_0\;
            else 
                case \MemoryContainer::.ctor(SimpleMemory).0._State\ is 
                    when \MemoryContainer::.ctor(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MemoryContainer::.ctor(SimpleMemory).0._Started\ = true) then 
                            \MemoryContainer::.ctor(SimpleMemory).0._State\ := \MemoryContainer::.ctor(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryContainer::.ctor(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MemoryContainer::.ctor(SimpleMemory).0._Started\ = true) then 
                            \MemoryContainer::.ctor(SimpleMemory).0._Finished\ <= true;
                        else 
                            \MemoryContainer::.ctor(SimpleMemory).0._Finished\ <= false;
                            \MemoryContainer::.ctor(SimpleMemory).0._State\ := \MemoryContainer::.ctor(SimpleMemory).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.Out\ <= \MemoryContainer::.ctor(SimpleMemory).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryContainer::.ctor(SimpleMemory).0._State_2\ => 
                        \MemoryContainer::.ctor(SimpleMemory).0.this\ := \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this._memory = memory;
                        -- 
                        \MemoryContainer::.ctor(SimpleMemory).0._State\ := \MemoryContainer::.ctor(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput().0 state machine start
    \MemoryContainer::GetInput().0._StateMachine\: process (\Clock\) 
        Variable \MemoryContainer::GetInput().0._State\: \MemoryContainer::GetInput().0._States\ := \MemoryContainer::GetInput().0._State_0\;
        Variable \MemoryContainer::GetInput().0.this\: \Hast.Samples.SampleAssembly.MemoryContainer\;
        Variable \MemoryContainer::GetInput().0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MemoryContainer::GetInput().0._Finished\ <= false;
                \MemoryContainer::GetInput().0.return\ <= to_unsigned(0, 32);
                \MemoryContainer::GetInput().0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \MemoryContainer::GetInput().0.SimpleMemory.DataOut\ <= (others => '0');
                \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\ <= false;
                \MemoryContainer::GetInput().0.SimpleMemory.WriteEnable\ <= false;
                \MemoryContainer::GetInput().0._State\ := \MemoryContainer::GetInput().0._State_0\;
                \MemoryContainer::GetInput().0.dataIn.0\ := (others => '0');
            else 
                case \MemoryContainer::GetInput().0._State\ is 
                    when \MemoryContainer::GetInput().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MemoryContainer::GetInput().0._Started\ = true) then 
                            \MemoryContainer::GetInput().0._State\ := \MemoryContainer::GetInput().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryContainer::GetInput().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MemoryContainer::GetInput().0._Started\ = true) then 
                            \MemoryContainer::GetInput().0._Finished\ <= true;
                        else 
                            \MemoryContainer::GetInput().0._Finished\ <= false;
                            \MemoryContainer::GetInput().0._State\ := \MemoryContainer::GetInput().0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \MemoryContainer::GetInput().0.this.parameter.Out\ <= \MemoryContainer::GetInput().0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryContainer::GetInput().0._State_2\ => 
                        \MemoryContainer::GetInput().0.this\ := \MemoryContainer::GetInput().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \MemoryContainer::GetInput().0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\ <= true;
                        \MemoryContainer::GetInput().0._State\ := \MemoryContainer::GetInput().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryContainer::GetInput().0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\ <= false;
                            \MemoryContainer::GetInput().0.dataIn.0\ := \DataIn\;
                            \MemoryContainer::GetInput().0.return\ <= ConvertStdLogicVectorToUInt32(\MemoryContainer::GetInput().0.dataIn.0\);
                            \MemoryContainer::GetInput().0._State\ := \MemoryContainer::GetInput().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput().0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \MemoryTest::Run(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \MemoryTest::Run(SimpleMemory).0._State\: \MemoryTest::Run(SimpleMemory).0._States\ := \MemoryTest::Run(SimpleMemory).0._State_0\;
        Variable \MemoryTest::Run(SimpleMemory).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \MemoryTest::Run(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \MemoryTest::Run(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.1\: boolean := false;
        Variable \MemoryTest::Run(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MemoryTest::Run(SimpleMemory).0._Finished\ <= false;
                \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_0\;
                \MemoryTest::Run(SimpleMemory).0.num\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.dataIn.0\ := (others => '0');
                \MemoryTest::Run(SimpleMemory).0.num2\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.dataIn.1\ := (others => '0');
                \MemoryTest::Run(SimpleMemory).0.num3\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.0\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.num4\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.1\ := false;
                \MemoryTest::Run(SimpleMemory).0.dataIn.2\ := (others => '0');
                \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
                \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \MemoryTest::Run(SimpleMemory).0._State\ is 
                    when \MemoryTest::Run(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MemoryTest::Run(SimpleMemory).0._Started\ = true) then 
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MemoryTest::Run(SimpleMemory).0._Started\ = true) then 
                            \MemoryTest::Run(SimpleMemory).0._Finished\ <= true;
                        else 
                            \MemoryTest::Run(SimpleMemory).0._Finished\ <= false;
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \MemoryTest::Run(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \MemoryTest::Run(SimpleMemory).0.num\ := ConvertStdLogicVectorToInt32(\MemoryTest::Run(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = memory.ReadInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \MemoryTest::Run(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \MemoryTest::Run(SimpleMemory).0.num2\ := ConvertStdLogicVectorToInt32(\MemoryTest::Run(SimpleMemory).0.dataIn.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- int num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num + num2;
                            -- 
                            \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.0\ := \MemoryTest::Run(SimpleMemory).0.num\ + \MemoryTest::Run(SimpleMemory).0.num2\;
                            \MemoryTest::Run(SimpleMemory).0.num3\ := \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = num;
                            -- 
                            \MemoryTest::Run(SimpleMemory).0.num4\ := \MemoryTest::Run(SimpleMemory).0.num\;
                            -- The following section was transformed from the .NET statement below:
                            -- while (num4 < num3) {
                            -- 	memory.WriteInt32 (num4, memory.ReadInt32 (num4) + 1);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MemoryTest::Run(SimpleMemory).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \MemoryTest::Run(SimpleMemory).0._State_5\.
                        -- The while loop's condition:
                        \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.1\ := \MemoryTest::Run(SimpleMemory).0.num4\ < \MemoryTest::Run(SimpleMemory).0.num3\;
                        if (\MemoryTest::Run(SimpleMemory).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteInt32 (num4, memory.ReadInt32 (num4) + 1);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (num4, memory.ReadInt32 (num4) + 1);
                            -- 
                            -- Begin SimpleMemory read.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= \MemoryTest::Run(SimpleMemory).0.num4\;
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_8\;
                        else 
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \MemoryTest::Run(SimpleMemory).0._State_7\ => 
                        -- State after the while loop which was started in state \MemoryTest::Run(SimpleMemory).0._State_5\.
                        \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MemoryTest::Run(SimpleMemory).0._State_8\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \MemoryTest::Run(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.2\ := ConvertStdLogicVectorToInt32(\MemoryTest::Run(SimpleMemory).0.dataIn.2\) + to_signed(1, 32);
                            -- Begin SimpleMemory write.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= \MemoryTest::Run(SimpleMemory).0.num4\;
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\MemoryTest::Run(SimpleMemory).0.binaryOperationResult.2\);
                            \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MemoryTest::Run(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = num4 + 1;
                            -- 
                            \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.3\ := \MemoryTest::Run(SimpleMemory).0.num4\ + to_signed(1, 32);
                            \MemoryTest::Run(SimpleMemory).0.num4\ := \MemoryTest::Run(SimpleMemory).0.binaryOperationResult.3\;
                            -- Returning to the repeated state of the while loop which was started in state \MemoryTest::Run(SimpleMemory).0._State_5\ if the loop wasn't exited with a state change.
                            if (\MemoryTest::Run(SimpleMemory).0._State\ = \MemoryTest::Run(SimpleMemory).0._State_9\) then 
                                \MemoryTest::Run(SimpleMemory).0._State\ := \MemoryTest::Run(SimpleMemory).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).0 state machine start
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._StateMachine\: process (\Clock\) 
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._States\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_0\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\: \Hast.Algorithms.Random.RandomXorshiftLfsr16\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.1\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.14\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.15\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.16\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.17\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Finished\ <= false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_0\;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.0\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\ := to_signed(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.1\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num4\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.2\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.3\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.4\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.6\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num5\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.9\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.10\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.11\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.12\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.13\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.14\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.15\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.16\ := to_unsigned(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.17\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.18\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.19\ := to_signed(0, 32);
            else 
                case \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ is 
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Finished\ <= true;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Finished\ <= false;
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\ => 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- RandomXorshiftLfsr16 randomXorshiftLfsr;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr = new RandomXorshiftLfsr16 { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\IsNull\ := false;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := SmartResize(unsigned(to_signed(49813, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((uint)(this.randomSeed) + num);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.0\ := SmartResize(SmartResize((\System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed\), 32) + \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num\, 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num3) < this.iterationsPerTask) {
                        -- 	uint num4;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	uint num5;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 		num2 = (uint)((long)(num2) + 1L);
                        -- 	}
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\.
                        -- The while loop's condition:
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.1\ := SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\), 64) < \System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask\;
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	uint num4;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	uint num5;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                            -- 		num2 = (uint)((long)(num2) + 1L);
                            -- 	}
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num4;
                            -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.2\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.2\)), 32))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.3\);
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.4\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_5\;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8817
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_4\ => 
                        -- State after the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.4\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.6\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.6\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.7\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num4\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.8\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.8776
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.8\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.9\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.10\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.10\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.11\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.12\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.13\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.12\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.13\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num5\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.874
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.14\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num4\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num4\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.15\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num5\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num5\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.8416
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.16\ := SmartResize(unsigned((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.14\) + (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.15\)), 64);
                        -- Since the integer literal 4294836225 was out of the VHDL integer range it was substituted with a binary literal (11111111111111100000000000000001).
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.17\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.16\) <= "0000000000000000000000000000000011111111111111100000000000000001";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\ and ends in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\.

                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.17\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6795
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\ => 
                        -- State after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.19\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\ + to_signed(1, 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num3\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.19\;
                        -- Returning to the repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_2\ if the loop wasn't exited with a state change.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\ => 
                        -- True branch of the if-else started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (uint)((long)(num2) + 1L);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.18\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\), 64)) + to_signed(1, 64)), 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.num2\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.binaryOperationResult.18\);
                        -- Going to the state after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_8\.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_10\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).1 state machine start
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._StateMachine\: process (\Clock\) 
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._States\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_0\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\: \Hast.Algorithms.Random.RandomXorshiftLfsr16\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.1\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.14\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.15\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.16\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.17\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Finished\ <= false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_0\;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.0\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\ := to_signed(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.1\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num4\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.2\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.3\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.4\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.5\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.6\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.7\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num5\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.8\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.9\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.10\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.11\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.12\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.13\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.14\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.15\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.16\ := to_unsigned(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.17\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.18\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.19\ := to_signed(0, 32);
            else 
                case \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ is 
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Finished\ <= true;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Finished\ <= false;
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\ => 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- RandomXorshiftLfsr16 randomXorshiftLfsr;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr = new RandomXorshiftLfsr16 { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\IsNull\ := false;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := SmartResize(unsigned(to_signed(49813, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((uint)(this.randomSeed) + num);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.0\ := SmartResize(SmartResize((\System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed\), 32) + \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num\, 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num3) < this.iterationsPerTask) {
                        -- 	uint num4;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	uint num5;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 		num2 = (uint)((long)(num2) + 1L);
                        -- 	}
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\.
                        -- The while loop's condition:
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.1\ := SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\), 64) < \System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask\;
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	uint num4;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	uint num5;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                            -- 		num2 = (uint)((long)(num2) + 1L);
                            -- 	}
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num4;
                            -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.2\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.2\)), 32))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.3\);
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.4\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_5\;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8817
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_4\ => 
                        -- State after the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.4\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.6\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.6\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.7\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num4\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.8\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.8776
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.8\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.9\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.10\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.10\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.11\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.12\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.13\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.12\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.13\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num5\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.874
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.14\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num4\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num4\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.15\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num5\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num5\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.8416
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.16\ := SmartResize(unsigned((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.14\) + (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.15\)), 64);
                        -- Since the integer literal 4294836225 was out of the VHDL integer range it was substituted with a binary literal (11111111111111100000000000000001).
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.17\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.16\) <= "0000000000000000000000000000000011111111111111100000000000000001";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\ and ends in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\.
                        --     * Execution after either branch will continue in the following state: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\.

                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.17\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6795
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\ => 
                        -- State after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.19\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\ + to_signed(1, 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num3\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.19\;
                        -- Returning to the repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_2\ if the loop wasn't exited with a state change.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\ => 
                        -- True branch of the if-else started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (uint)((long)(num2) + 1L);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.18\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\), 64)) + to_signed(1, 64)), 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.num2\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.binaryOperationResult.18\);
                        -- Going to the state after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_8\.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_10\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).1 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).2 state machine start
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._StateMachine\: process (\Clock\) 
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._States\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_0\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\: \Hast.Algorithms.Random.RandomXorshiftLfsr16\;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.1\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.12\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.14\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.15\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.16\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.17\: boolean := false;
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Finished\ <= false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_0\;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.0\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\ := to_signed(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.1\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num4\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.2\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.3\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.4\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.5\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.6\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.7\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num5\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.8\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.9\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.10\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.11\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.12\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.13\ := to_unsigned(0, 16);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.14\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.15\ := to_signed(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.16\ := to_unsigned(0, 64);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.17\ := false;
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.18\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.19\ := to_signed(0, 32);
            else 
                case \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ is 
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Started\ = true) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Finished\ <= true;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Finished\ <= false;
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\ => 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- RandomXorshiftLfsr16 randomXorshiftLfsr;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr = new RandomXorshiftLfsr16 { };
                        -- 
                        -- Initializing record fields to their defaults.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\IsNull\ := false;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := SmartResize(unsigned(to_signed(49813, 32)), 16);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((uint)(this.randomSeed) + num);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.0\ := SmartResize(SmartResize((\System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed\), 32) + \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num\, 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num3) < this.iterationsPerTask) {
                        -- 	uint num4;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 	uint num5;
                        -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 		num2 = (uint)((long)(num2) + 1L);
                        -- 	}
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\.
                        -- The while loop's condition:
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.1\ := SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\), 64) < \System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask\;
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	uint num4;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 	uint num5;
                            -- 	// Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 	randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                            -- 	return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                            -- 	// Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 	num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                            -- 	if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                            -- 		num2 = (uint)((long)(num2) + 1L);
                            -- 	}
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num4;
                            -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- ushort return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.2\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.2\)), 32))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.3\);
                            -- The following section was transformed from the .NET statement below:
                            -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                            -- 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.4\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_5\;
                        else 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8817
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_4\ => 
                        -- State after the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\;
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.4\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.6\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.6\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.7\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35 = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num4\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_dba77f4a42e26f5b021109a2fcf7c5bd107feefdea3a2dbaa4059a0fc0385b35\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- // Starting inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 7)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.8\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(7, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.8776
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.8\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.9\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) << 9)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.10\ := SmartResize(unsigned(shift_left(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(9, 32), 5))))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.10\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.11\);
                        -- The following section was transformed from the .NET statement below:
                        -- randomXorshiftLfsr.State = (ushort)((int)(randomXorshiftLfsr.State) ^ (int)((ushort)((int)(randomXorshiftLfsr.State) >> 13)));
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.12\ := SmartResize(unsigned(shift_right(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)), to_integer(unsigned(SmartResize(to_signed(13, 32), 5) and "11111")))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.13\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\), 32)) xor signed(SmartResize(((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.12\)), 32))), 16);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.13\);
                        -- The following section was transformed from the .NET statement below:
                        -- return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d = randomXorshiftLfsr.State;
                        -- // Ending inlined block of the method System.UInt16 Hast.Algorithms.Random.RandomXorshiftLfsr16::NextUInt16().
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.randomXorshiftLfsr\.\State\;
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num5\ := SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return_7180f808f710fb52fb18dd6672bbdb004ff4bb0c497b2a035d0f38fda7af8f2d\, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- if ((ulong)((long)(num4 * num4) + (long)(num5 * num5)) <= 4294836225uL) {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.874
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.14\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num4\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num4\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.15\ := signed(SmartResize(\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num5\ * \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num5\, 64));
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.8416
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.16\ := SmartResize(unsigned((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.14\) + (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.15\)), 64);
                        -- Since the integer literal 4294836225 was out of the VHDL integer range it was substituted with a binary literal (11111111111111100000000000000001).
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.17\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.16\) <= "0000000000000000000000000000000011111111111111100000000000000001";

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\ and ends in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\.
                        --     * Execution after either branch will continue in the following state: \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\.

                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.17\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6795
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\ => 
                        -- State after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.19\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\ + to_signed(1, 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num3\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.19\;
                        -- Returning to the repeated state of the while loop which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_2\ if the loop wasn't exited with a state change.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\ => 
                        -- True branch of the if-else started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (uint)((long)(num2) + 1L);
                        -- 
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.18\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\), 64)) + to_signed(1, 64)), 32);
                        \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.num2\ := (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.binaryOperationResult.18\);
                        -- Going to the state after the if-else which was started in state \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_8\.
                        if (\MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ = \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_10\) then 
                            \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State\ := \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object).2 state machine end


    -- System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\: \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._States\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_0\;
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\: \unsigned32_Array\(0 to 122) := (others => to_unsigned(0, 32));
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.1\: boolean := false;
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\: integer range 0 to 2 := 0;
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.3\: boolean := false;
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        attribute dont_touch of \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Finished\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.0\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.1\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.2\ <= to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\ <= false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_0\;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.0\ := (others => '0');
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.1\ := (others => '0');
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\ := to_signed(0, 64);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\ := (others => to_unsigned(0, 32));
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.1\ := false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\ := 0;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.0\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.1\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.2\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\ := to_signed(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.3\ := false;
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.5\ := to_signed(0, 32);
            else 
                case \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ is 
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Started\ = true) then 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Started\ = true) then 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Finished\ <= true;
                        else 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Finished\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- <>c__DisplayClass5_0 <>c__DisplayClass5_;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- <>c__DisplayClass5_ = new <>c__DisplayClass5_0 ();
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- <>c__DisplayClass5_.randomSeed = (ushort)memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \System.UInt16 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::randomSeed\ := SmartResize(ConvertStdLogicVectorToUInt32(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.dataIn.1\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- <>c__DisplayClass5_.iterationsPerTask = (long)num / 123L;
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_6\ => 
                        -- Waiting for the result to appear in \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\ (have to wait 27 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(27, 32)) then 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_7\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\ := signed(SmartResize(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num\, 64)) / to_signed(123, 64);
                        -- Clock cycles needed to complete this state (approximation): 27
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_7\ => 
                        \System.Int64 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::iterationsPerTask\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- Task<uint>[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new Task<uint>[123];
                        -- 
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u;
                        -- 
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((long)(num2) < 123L) {
                        -- 	array [num2] = Task.Factory.StartNew (<>c__DisplayClass5_.<>9__0 ?? (<>c__DisplayClass5_.<>9__0 = <>c__DisplayClass5_.<EstimatePi>b__0), num2);
                        -- 	num2 = (uint)((long)(num2) + 1L);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_7\.
                        -- The while loop's condition:
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.1\ := signed(SmartResize((\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\), 64)) < to_signed(123, 64);
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [num2] = Task.Factory.StartNew (<>c__DisplayClass5_.<>9__0 ?? (<>c__DisplayClass5_.<>9__0 = <>c__DisplayClass5_.<EstimatePi>b__0), num2);
                            -- 	num2 = (uint)((long)(num2) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [num2] = Task.Factory.StartNew (<>c__DisplayClass5_.<>9__0 ?? (<>c__DisplayClass5_.<>9__0 = <>c__DisplayClass5_.<EstimatePi>b__0), num2);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object)
                            case \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\ is 
                                when 0 => 
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.0\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\;
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\ <= true;
                                when 1 => 
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.1\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\;
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\ <= true;
                                when 2 => 
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.2\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\;
                                    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\ <= true;
                            end case;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (uint)((long)(num2) + 1L);
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\), 64)) + to_signed(1, 64)), 32);
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num2\ := (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.2\);
                        else 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6795
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_9\ => 
                        -- State after the while loop which was started in state \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object)
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\ = \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.1\ and \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\ = \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.2\ and \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\ = \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.0\) then 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).invocationIndex\ := 0;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.0\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.0\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.1\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.1\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.2\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.2\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\(0) := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.0\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\(1) := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.1\;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\(2) := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 0u;
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- int num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0;
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num4 < 123) {
                            -- 	num3 = num3 + array [num4].Result;
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_11\ => 
                        -- Repeated state of the while loop which was started in state \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_10\.
                        -- The while loop's condition:
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.3\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\ < to_signed(123, 32);
                        if (\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.3\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num3 = num3 + array [num4].Result;
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + array [num4].Result;
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.4\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\ + \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.array\(to_integer(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\));
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = num4 + 1;
                            -- 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.5\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\ + to_signed(1, 32);
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num4\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.5\;
                        else 
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_12\ => 
                        -- State after the while loop which was started in state \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (0, num3);
                        -- 
                        -- Begin SimpleMemory write.
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.num3\);
                        \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_13\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State\ := \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32).0 state machine start
    \NumberContainer::.ctor(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::.ctor(UInt32).0._State\: \NumberContainer::.ctor(UInt32).0._States\ := \NumberContainer::.ctor(UInt32).0._State_0\;
        Variable \NumberContainer::.ctor(UInt32).0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::.ctor(UInt32).0.number\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::.ctor(UInt32).0._Finished\ <= false;
                \NumberContainer::.ctor(UInt32).0._State\ := \NumberContainer::.ctor(UInt32).0._State_0\;
                \NumberContainer::.ctor(UInt32).0.number\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::.ctor(UInt32).0._State\ is 
                    when \NumberContainer::.ctor(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::.ctor(UInt32).0._Started\ = true) then 
                            \NumberContainer::.ctor(UInt32).0._State\ := \NumberContainer::.ctor(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::.ctor(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::.ctor(UInt32).0._Started\ = true) then 
                            \NumberContainer::.ctor(UInt32).0._Finished\ <= true;
                        else 
                            \NumberContainer::.ctor(UInt32).0._Finished\ <= false;
                            \NumberContainer::.ctor(UInt32).0._State\ := \NumberContainer::.ctor(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::.ctor(UInt32).0.this.parameter.Out\ <= \NumberContainer::.ctor(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::.ctor(UInt32).0._State_2\ => 
                        \NumberContainer::.ctor(UInt32).0.this\ := \NumberContainer::.ctor(UInt32).0.this.parameter.In\;
                        \NumberContainer::.ctor(UInt32).0.number\ := \NumberContainer::.ctor(UInt32).0.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Number = 9u;
                        -- 
                        \NumberContainer::.ctor(UInt32).0.this\.\Number\ := to_unsigned(9, 32);
                        \NumberContainer::.ctor(UInt32).0._State\ := \NumberContainer::.ctor(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32).0 state machine start
    \NumberContainer::IncreaseNumber(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::IncreaseNumber(UInt32).0._State\: \NumberContainer::IncreaseNumber(UInt32).0._States\ := \NumberContainer::IncreaseNumber(UInt32).0._State_0\;
        Variable \NumberContainer::IncreaseNumber(UInt32).0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::IncreaseNumber(UInt32).0.increaseBy\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \NumberContainer::IncreaseNumber(UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::IncreaseNumber(UInt32).0._Finished\ <= false;
                \NumberContainer::IncreaseNumber(UInt32).0.return\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumber(UInt32).0._State\ := \NumberContainer::IncreaseNumber(UInt32).0._State_0\;
                \NumberContainer::IncreaseNumber(UInt32).0.increaseBy\ := to_unsigned(0, 32);
                \NumberContainer::IncreaseNumber(UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::IncreaseNumber(UInt32).0._State\ is 
                    when \NumberContainer::IncreaseNumber(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::IncreaseNumber(UInt32).0._Started\ = true) then 
                            \NumberContainer::IncreaseNumber(UInt32).0._State\ := \NumberContainer::IncreaseNumber(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumber(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::IncreaseNumber(UInt32).0._Started\ = true) then 
                            \NumberContainer::IncreaseNumber(UInt32).0._Finished\ <= true;
                        else 
                            \NumberContainer::IncreaseNumber(UInt32).0._Finished\ <= false;
                            \NumberContainer::IncreaseNumber(UInt32).0._State\ := \NumberContainer::IncreaseNumber(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\ <= \NumberContainer::IncreaseNumber(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumber(UInt32).0._State_2\ => 
                        \NumberContainer::IncreaseNumber(UInt32).0.this\ := \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\;
                        \NumberContainer::IncreaseNumber(UInt32).0.increaseBy\ := \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.WasIncreased = true;
                        -- 
                        \NumberContainer::IncreaseNumber(UInt32).0.this\.\WasIncreased\ := true;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.Number = @this.Number + increaseBy;
                        -- 
                        \NumberContainer::IncreaseNumber(UInt32).0.binaryOperationResult.0\ := \NumberContainer::IncreaseNumber(UInt32).0.this\.\Number\ + \NumberContainer::IncreaseNumber(UInt32).0.increaseBy\;
                        \NumberContainer::IncreaseNumber(UInt32).0.this\.\Number\ := \NumberContainer::IncreaseNumber(UInt32).0.binaryOperationResult.0\;
                        \NumberContainer::IncreaseNumber(UInt32).0.return\ <= \NumberContainer::IncreaseNumber(UInt32).0.this\.\Number\;
                        \NumberContainer::IncreaseNumber(UInt32).0._State\ := \NumberContainer::IncreaseNumber(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10().0 state machine start
    \NumberContainer::IncreaseNumberBy10().0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::IncreaseNumberBy10().0._State\: \NumberContainer::IncreaseNumberBy10().0._States\ := \NumberContainer::IncreaseNumberBy10().0._State_0\;
        Variable \NumberContainer::IncreaseNumberBy10().0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::IncreaseNumberBy10().0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::IncreaseNumberBy10().0._Finished\ <= false;
                \NumberContainer::IncreaseNumberBy10().0.return\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                \NumberContainer::IncreaseNumberBy10().0._State\ := \NumberContainer::IncreaseNumberBy10().0._State_0\;
                \NumberContainer::IncreaseNumberBy10().0.return.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::IncreaseNumberBy10().0._State\ is 
                    when \NumberContainer::IncreaseNumberBy10().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::IncreaseNumberBy10().0._Started\ = true) then 
                            \NumberContainer::IncreaseNumberBy10().0._State\ := \NumberContainer::IncreaseNumberBy10().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumberBy10().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::IncreaseNumberBy10().0._Started\ = true) then 
                            \NumberContainer::IncreaseNumberBy10().0._Finished\ <= true;
                        else 
                            \NumberContainer::IncreaseNumberBy10().0._Finished\ <= false;
                            \NumberContainer::IncreaseNumberBy10().0._State\ := \NumberContainer::IncreaseNumberBy10().0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::IncreaseNumberBy10().0.this.parameter.Out\ <= \NumberContainer::IncreaseNumberBy10().0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumberBy10().0._State_2\ => 
                        \NumberContainer::IncreaseNumberBy10().0.this\ := \NumberContainer::IncreaseNumberBy10().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (@this, 10u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \NumberContainer::IncreaseNumberBy10().0.this\;
                        \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(10, 32);
                        \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                        \NumberContainer::IncreaseNumberBy10().0._State\ := \NumberContainer::IncreaseNumberBy10().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumberBy10().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \NumberContainer::IncreaseNumberBy10().0.return.0\ := \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \NumberContainer::IncreaseNumberBy10().0.this\ := \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            \NumberContainer::IncreaseNumberBy10().0.return\ <= \NumberContainer::IncreaseNumberBy10().0.return.0\;
                            \NumberContainer::IncreaseNumberBy10().0._State\ := \NumberContainer::IncreaseNumberBy10().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10().0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&).0 state machine start
    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\: \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._States\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_0\;
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Finished\ <= false;
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.Out\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.Out\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_0\;
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\ := to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber\ := to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.return.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ is 
                    when \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Started\ = true) then 
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Started\ = true) then 
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Finished\ <= true;
                        else 
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Finished\ <= false;
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.Out\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.Out\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.Out\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_2\ => 
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.In\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.In\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- originalNumber = @this.Number;
                        -- 
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\.\Number\;
                        -- The following section was transformed from the .NET statement below:
                        -- increaseBy = (uint)((long)(increaseBy) * 10L);
                        -- 
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\), 64)) * to_signed(10, 64)), 32);
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\ := (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (@this, increaseBy);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy\;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                        \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.7638
                    when \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.return.0\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State\ := \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive().0 state machine start
    \NumberContainer::get_NumberPlusFive().0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::get_NumberPlusFive().0._State\: \NumberContainer::get_NumberPlusFive().0._States\ := \NumberContainer::get_NumberPlusFive().0._State_0\;
        Variable \NumberContainer::get_NumberPlusFive().0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::get_NumberPlusFive().0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::get_NumberPlusFive().0._Finished\ <= false;
                \NumberContainer::get_NumberPlusFive().0.return\ <= to_unsigned(0, 32);
                \NumberContainer::get_NumberPlusFive().0._State\ := \NumberContainer::get_NumberPlusFive().0._State_0\;
                \NumberContainer::get_NumberPlusFive().0.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::get_NumberPlusFive().0._State\ is 
                    when \NumberContainer::get_NumberPlusFive().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::get_NumberPlusFive().0._Started\ = true) then 
                            \NumberContainer::get_NumberPlusFive().0._State\ := \NumberContainer::get_NumberPlusFive().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::get_NumberPlusFive().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::get_NumberPlusFive().0._Started\ = true) then 
                            \NumberContainer::get_NumberPlusFive().0._Finished\ <= true;
                        else 
                            \NumberContainer::get_NumberPlusFive().0._Finished\ <= false;
                            \NumberContainer::get_NumberPlusFive().0._State\ := \NumberContainer::get_NumberPlusFive().0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::get_NumberPlusFive().0.this.parameter.Out\ <= \NumberContainer::get_NumberPlusFive().0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::get_NumberPlusFive().0._State_2\ => 
                        \NumberContainer::get_NumberPlusFive().0.this\ := \NumberContainer::get_NumberPlusFive().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(@this.Number) + 5L);
                        -- 
                        \NumberContainer::get_NumberPlusFive().0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\NumberContainer::get_NumberPlusFive().0.this\.\Number\), 64)) + to_signed(5, 64)), 32);
                        \NumberContainer::get_NumberPlusFive().0.return\ <= (\NumberContainer::get_NumberPlusFive().0.binaryOperationResult.0\);
                        \NumberContainer::get_NumberPlusFive().0._State\ := \NumberContainer::get_NumberPlusFive().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive().0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32).0 state machine start
    \NumberContainer::set_NumberPlusFive(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \NumberContainer::set_NumberPlusFive(UInt32).0._State\: \NumberContainer::set_NumberPlusFive(UInt32).0._States\ := \NumberContainer::set_NumberPlusFive(UInt32).0._State_0\;
        Variable \NumberContainer::set_NumberPlusFive(UInt32).0.this\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainer::set_NumberPlusFive(UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \NumberContainer::set_NumberPlusFive(UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainer::set_NumberPlusFive(UInt32).0._Finished\ <= false;
                \NumberContainer::set_NumberPlusFive(UInt32).0._State\ := \NumberContainer::set_NumberPlusFive(UInt32).0._State_0\;
                \NumberContainer::set_NumberPlusFive(UInt32).0.value\ := to_unsigned(0, 32);
                \NumberContainer::set_NumberPlusFive(UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainer::set_NumberPlusFive(UInt32).0._State\ is 
                    when \NumberContainer::set_NumberPlusFive(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainer::set_NumberPlusFive(UInt32).0._Started\ = true) then 
                            \NumberContainer::set_NumberPlusFive(UInt32).0._State\ := \NumberContainer::set_NumberPlusFive(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::set_NumberPlusFive(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainer::set_NumberPlusFive(UInt32).0._Started\ = true) then 
                            \NumberContainer::set_NumberPlusFive(UInt32).0._Finished\ <= true;
                        else 
                            \NumberContainer::set_NumberPlusFive(UInt32).0._Finished\ <= false;
                            \NumberContainer::set_NumberPlusFive(UInt32).0._State\ := \NumberContainer::set_NumberPlusFive(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.Out\ <= \NumberContainer::set_NumberPlusFive(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainer::set_NumberPlusFive(UInt32).0._State_2\ => 
                        \NumberContainer::set_NumberPlusFive(UInt32).0.this\ := \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.In\;
                        \NumberContainer::set_NumberPlusFive(UInt32).0.value\ := \NumberContainer::set_NumberPlusFive(UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Number = (uint)((long)(value) - 5L);
                        -- 
                        \NumberContainer::set_NumberPlusFive(UInt32).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\NumberContainer::set_NumberPlusFive(UInt32).0.value\), 64)) - to_signed(5, 64)), 32);
                        \NumberContainer::set_NumberPlusFive(UInt32).0.this\.\Number\ := (\NumberContainer::set_NumberPlusFive(UInt32).0.binaryOperationResult.0\);
                        \NumberContainer::set_NumberPlusFive(UInt32).0._State\ := \NumberContainer::set_NumberPlusFive(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer).0 state machine start
    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._StateMachine\: process (\Clock\) 
        Variable \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\: \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._States\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_0\;
        Variable \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Finished\ <= false;
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return\ <= to_unsigned(0, 32);
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(0, 32);
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_0\;
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return.0\ := to_unsigned(0, 32);
            else 
                case \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ is 
                    when \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Started\ = true) then 
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Started\ = true) then 
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Finished\ <= true;
                        else 
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Finished\ <= false;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.Out\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_2\ => 
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (numberContainer, 20u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer\;
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(20, 32);
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                        \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return.0\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return.0\;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State\ := \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \ObjectOrientedShowcase::Run(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0._State\: \ObjectOrientedShowcase::Run(SimpleMemory).0._States\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_0\;
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.input\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\: \Hast.Samples.SampleAssembly.MemoryContainer\;
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.array\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.originalNumber\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.array3\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 0);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\: \Hast.Samples.SampleAssembly.NumberContainer\;
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.unaryOperationResult.0\: boolean := false;
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.3\: boolean := false;
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ObjectOrientedShowcase::Run(SimpleMemory).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ObjectOrientedShowcase::Run(SimpleMemory).0._Finished\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).number.parameter.Out.0\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.Out.0\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.Out.0\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_0\;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.input\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.0\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.1\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.2\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.3\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.originalNumber\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.4\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.5\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.unaryOperationResult.0\ := false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.6\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.num\ := to_signed(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.3\ := false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.7\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 32);
                \ObjectOrientedShowcase::Run(SimpleMemory).0.return.8\ := to_unsigned(0, 32);
            else 
                case \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ is 
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0._Started\ = true) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0._Started\ = true) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._Finished\ <= true;
                        else 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._Finished\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint input;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- MemoryContainer object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e = new MemoryContainer (memory);
                        -- 
                        -- Initializing record fields to their defaults.
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\ <= true;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- input = Hast.Samples.SampleAssembly.MemoryContainer.GetInput (object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput()
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput()
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.0\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.object7e7dc6d022987a25983ea8f5036696cfb72caafc2d5248454d6ba8a53092597e\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.In.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.input\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- NumberContainer[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new NumberContainer[4];
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [0] = new NumberContainer { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32))).\IsNull\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32))).\WasIncreased\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32))).\Number\ := to_unsigned(99, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- array [0].Number = input;
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32))).\Number\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.input\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [1] = new NumberContainer { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32))).\IsNull\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32))).\WasIncreased\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32))).\Number\ := to_unsigned(99, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- array [1].Number = (uint)((long)(input) + 4L);
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\ObjectOrientedShowcase::Run(SimpleMemory).0.input\), 64)) + to_signed(4, 64)), 32);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32))).\Number\ := (\ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- array [2] = new NumberContainer { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))).\IsNull\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))).\WasIncreased\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))).\Number\ := to_unsigned(99, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- array [2].Number = 24u;
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))).\Number\ := to_unsigned(24, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- array [3] = new NumberContainer (9u);
                            -- 
                            -- Initializing record fields to their defaults.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))).\IsNull\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))).\WasIncreased\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))).\Number\ := to_unsigned(99, 32);
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).number.parameter.Out.0\ <= to_unsigned(9, 32);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.set_NumberPlusFive (array [0], (uint)((long)(input) + 10L));
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\ObjectOrientedShowcase::Run(SimpleMemory).0.input\), 64)) + to_signed(10, 64)), 32);
                            -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).value.parameter.Out.0\ <= (\ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.1\);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(0, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (array [1], 5u);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(5, 32);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.1\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(1, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumberBy10 (array [2]);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10()
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10()
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.2\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- NumberContainerExtensions.IncreaseNumberBy20 (array [2]);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.3\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(2, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint increaseBy;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- increaseBy = 10u;
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\ := to_unsigned(10, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- uint originalNumber;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumberByParameterTimes10 (array [3], ref increaseBy, out originalNumber);
                            -- 
                            -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.originalNumber\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.In.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.In.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.originalNumber\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (array [3], increaseBy + originalNumber);
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.2\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.increaseBy\ + \ObjectOrientedShowcase::Run(SimpleMemory).0.originalNumber\;
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32)));
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.2\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.4\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(to_signed(3, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- NumberContainer[] array3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array3 = new NumberContainer[1];
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- NumberContainer numberContainer;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- numberContainer = new NumberContainer { };
                            -- 
                            -- Initializing record fields to their defaults.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\IsNull\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\WasIncreased\ := false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\Number\ := to_unsigned(99, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- numberContainer.Number = 5u;
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\Number\ := to_unsigned(5, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- numberContainer.Number = Hast.Samples.SampleAssembly.NumberContainer.get_NumberPlusFive (numberContainer);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive()
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive()
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.5\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.In.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\Number\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (!numberContainer.WasIncreased) {
                            -- 	Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (numberContainer, 5u);
                            -- }
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.unaryOperationResult.0\ := not(\ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\.\WasIncreased\);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_14\ and ends in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_15\.
                            --     * Execution after either branch will continue in the following state: \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\.

                            if (\ObjectOrientedShowcase::Run(SimpleMemory).0.unaryOperationResult.0\) then 
                                \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_14\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\ => 
                        -- State after the if-else which was started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- array3 [0] = numberContainer;
                        -- 
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.array3\(to_integer(to_signed(0, 32))) := \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.num\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num < 4) {
                        -- 	Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (array [num], array3 [0].Number);
                        -- 	num = num + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_14\ => 
                        -- True branch of the if-else started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (numberContainer, 5u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (numberContainer, 5u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= to_unsigned(5, 32);
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.6\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.numberContainer\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_12\.
                            if (\ObjectOrientedShowcase::Run(SimpleMemory).0._State\ = \ObjectOrientedShowcase::Run(SimpleMemory).0._State_15\) then 
                                \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_16\ => 
                        -- Repeated state of the while loop which was started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\.
                        -- The while loop's condition:
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.3\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.num\ < to_signed(4, 32);
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.3\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (array [num], array3 [0].Number);
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Hast.Samples.SampleAssembly.NumberContainer.IncreaseNumber (array [num], array3 [0].Number);
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_18\;
                        else 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_17\ => 
                        -- State after the while loop which was started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (0, this.SumNumberContainers (array));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[])
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\ <= true;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_18\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(\ObjectOrientedShowcase::Run(SimpleMemory).0.num\));
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.array3\(to_integer(to_signed(0, 32))).\Number\;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= true;
                        \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32)
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.7\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\(to_integer(\ObjectOrientedShowcase::Run(SimpleMemory).0.num\)) := \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.4\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.num\ + to_signed(1, 32);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.num\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.binaryOperationResult.4\;
                            -- Returning to the repeated state of the while loop which was started in state \ObjectOrientedShowcase::Run(SimpleMemory).0._State_13\ if the loop wasn't exited with a state change.
                            if (\ObjectOrientedShowcase::Run(SimpleMemory).0._State\ = \ObjectOrientedShowcase::Run(SimpleMemory).0._State_19\) then 
                                \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_16\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[])
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\ = \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Finished.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.return.8\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).return.0\;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.array\ := \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.In.0\;
                            -- Begin SimpleMemory write.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\ObjectOrientedShowcase::Run(SimpleMemory).0.return.8\);
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::Run(SimpleMemory).0._State_21\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0._State\ := \ObjectOrientedShowcase::Run(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]).0 state machine start
    \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._StateMachine\: process (\Clock\) 
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\: \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._States\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_0\;
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers\: \Hast.Samples.SampleAssembly.NumberContainer_Array\(0 to 3);
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.0\: boolean := false;
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Finished\ <= false;
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.return\ <= to_unsigned(0, 32);
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_0\;
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\ := to_signed(0, 32);
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.0\ := false;
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.2\ := to_signed(0, 32);
            else 
                case \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ is 
                    when \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Started\ = true) then 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Started\ = true) then 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Finished\ <= true;
                        else 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Finished\ <= false;
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.Out\ <= \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_2\ => 
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0u;
                        -- 
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num2 < 4) {
                        -- 	num = num + numberContainers [num2].Number;
                        -- 	num2 = num2 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_2\.
                        -- The while loop's condition:
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.0\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\ < to_signed(4, 32);
                        if (\ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num = num + numberContainers [num2].Number;
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + numberContainers [num2].Number;
                            -- 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.1\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\ + \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers\(to_integer(\ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\)).\Number\;
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.2\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\ + to_signed(1, 32);
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num2\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.binaryOperationResult.2\;
                        else 
                            \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_4\ => 
                        -- State after the while loop which was started in state \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num;
                        -- 
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.return\ <= \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.num\;
                        \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State\ := \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).0 state machine start
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._StateMachine\: process (\Clock\) 
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._States\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_0\;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.2\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.0\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.1\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Finished\ <= false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.return\ <= to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_0\;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.0\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.1\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.2\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.0\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.4\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.1\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.5\ := to_signed(0, 32);
            else 
                case \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ is 
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Finished\ <= true;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Finished\ <= false;
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\ => 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = this.input + num * 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.0\ := SmartResize(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\ * to_signed(2, 32), 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.1\ := \System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.0\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = true;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\ := true;
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\ := to_signed(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num3 < 9999999) {
                        -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                        -- 	if ((!flag)) {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 	} else {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 	}
                        -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 	flag = !flag;
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4484
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\.
                        -- The while loop's condition:
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\ < to_signed(9999999, 32);
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 	if ((!flag)) {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- 	} else {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- 	}
                            -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                            -- 	flag = !flag;
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((!flag)) {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- } else {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- }
                            -- 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.0\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\.
                            --     * The false branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\.
                            --     * Execution after either branch will continue in the following state: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\.

                            if ((\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.0\)) then 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\;
                            else 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\;
                            end if;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3755
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_4\ => 
                        -- State after the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.return\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\ => 
                        -- State after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag = !flag;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.1\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.flag\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.unaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.5\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\ + to_signed(1, 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.5\;
                        -- Returning to the repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_2\ if the loop wasn't exited with a state change.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4265
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\ => 
                        -- True branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\ - \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.3\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_6\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\ => 
                        -- False branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.4\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num2\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.binaryOperationResult.4\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_7\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).1 state machine start
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._StateMachine\: process (\Clock\) 
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._States\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_0\;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.2\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.0\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.1\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Finished\ <= false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.return\ <= to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_0\;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.0\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.1\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.2\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.0\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.4\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.1\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.5\ := to_signed(0, 32);
            else 
                case \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ is 
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Finished\ <= true;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Finished\ <= false;
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\ => 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = this.input + num * 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.0\ := SmartResize(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\ * to_signed(2, 32), 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.1\ := \System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.0\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = true;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\ := true;
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\ := to_signed(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num3 < 9999999) {
                        -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                        -- 	if ((!flag)) {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 	} else {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 	}
                        -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 	flag = !flag;
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4484
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\.
                        -- The while loop's condition:
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\ < to_signed(9999999, 32);
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 	if ((!flag)) {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- 	} else {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- 	}
                            -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                            -- 	flag = !flag;
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((!flag)) {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- } else {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- }
                            -- 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.0\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\.
                            --     * The false branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\.
                            --     * Execution after either branch will continue in the following state: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\.

                            if ((\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.0\)) then 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\;
                            else 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\;
                            end if;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3755
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_4\ => 
                        -- State after the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.return\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\ => 
                        -- State after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag = !flag;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.1\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.flag\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.unaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.5\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\ + to_signed(1, 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.5\;
                        -- Returning to the repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_2\ if the loop wasn't exited with a state change.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4265
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\ => 
                        -- True branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\ - \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.3\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_6\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\ => 
                        -- False branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.4\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num2\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.binaryOperationResult.4\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_7\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).1 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).2 state machine start
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._StateMachine\: process (\Clock\) 
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._States\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_0\;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.2\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.0\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.1\: boolean := false;
        Variable \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Finished\ <= false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.return\ <= to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_0\;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.0\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.1\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.2\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.0\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.3\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.4\ := to_signed(0, 32);
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.1\ := false;
                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.5\ := to_signed(0, 32);
            else 
                case \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ is 
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Started\ = true) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Finished\ <= true;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Finished\ <= false;
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\ => 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = indexObject;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = this.input + num * 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.0\ := SmartResize(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\ * to_signed(2, 32), 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.1\ := \System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.0\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = true;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\ := true;
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\ := to_signed(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num3 < 9999999) {
                        -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                        -- 	if ((!flag)) {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 	} else {
                        -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 	}
                        -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 	flag = !flag;
                        -- 	num3 = num3 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.4484
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\.
                        -- The while loop's condition:
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.2\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\ < to_signed(9999999, 32);
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 	if ((!flag)) {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- 	} else {
                            -- 		conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- 	}
                            -- 	num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                            -- 	flag = !flag;
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((!flag)) {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                            -- } else {
                            -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                            -- }
                            -- 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.0\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\.
                            --     * The false branch starts in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\ and ends in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\.
                            --     * Execution after either branch will continue in the following state: \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\.

                            if ((\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.0\)) then 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\;
                            else 
                                \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\;
                            end if;
                        else 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3755
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_4\ => 
                        -- State after the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num2;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.return\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\ => 
                        -- State after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag = !flag;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.1\ := not(\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.flag\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.unaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = num3 + 1;
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.5\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\ + to_signed(1, 32);
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.5\;
                        -- Returning to the repeated state of the while loop which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_2\ if the loop wasn't exited with a state change.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4265
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\ => 
                        -- True branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 - num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.3\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\ - \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.3\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_6\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\ => 
                        -- False branch of the if-else started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98 = (num2 + num);
                        -- 
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.4\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num2\ + \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.num\;
                        \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.conditionaldf06b407998e7ef8314c91f14d040054a99fa414c44f08a48e44fb764b671e98\ := (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.binaryOperationResult.4\);
                        -- Going to the state after the if-else which was started in state \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_3\.
                        if (\ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ = \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_7\) then 
                            \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State\ := \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object).2 state machine end


    -- System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \ParallelAlgorithm::Run(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \ParallelAlgorithm::Run(SimpleMemory).0._State\: \ParallelAlgorithm::Run(SimpleMemory).0._States\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_0\;
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.array\: \signed32_Array\(0 to 259) := (others => to_signed(0, 32));
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\: integer range 0 to 2 := 0;
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.return.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.return.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.return.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.2\: boolean := false;
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \ParallelAlgorithm::Run(SimpleMemory).0._Finished\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.0\ <= to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.1\ <= to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.2\ <= to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\ <= false;
                \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_0\;
                \ParallelAlgorithm::Run(SimpleMemory).0.dataIn.0\ := (others => '0');
                \ParallelAlgorithm::Run(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                \ParallelAlgorithm::Run(SimpleMemory).0.num\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.0\ := false;
                \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\ := 0;
                \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.return.0\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.return.1\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.return.2\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.num2\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.num3\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.2\ := false;
                \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
                \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 32);
            else 
                case \ParallelAlgorithm::Run(SimpleMemory).0._State\ is 
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\ParallelAlgorithm::Run(SimpleMemory).0._Started\ = true) then 
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\ParallelAlgorithm::Run(SimpleMemory).0._Started\ = true) then 
                            \ParallelAlgorithm::Run(SimpleMemory).0._Finished\ <= true;
                        else 
                            \ParallelAlgorithm::Run(SimpleMemory).0._Finished\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- <>c__DisplayClass3_0 <>c__DisplayClass3_;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- <>c__DisplayClass3_ = new <>c__DisplayClass3_0 ();
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- <>c__DisplayClass3_.input = memory.ReadInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::input\ := ConvertStdLogicVectorToInt32(\ParallelAlgorithm::Run(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- Task<int>[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new Task<int>[260];
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                            -- The following section was transformed from the .NET statement below:
                            -- int num;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num = 0;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.num\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num < 260) {
                            -- 	array [num] = Task.Factory.StartNew (<>c__DisplayClass3_.<>9__0 ?? (<>c__DisplayClass3_.<>9__0 = <>c__DisplayClass3_.<Run>b__0), num);
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \ParallelAlgorithm::Run(SimpleMemory).0._State_3\.
                        -- The while loop's condition:
                        \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.0\ := \ParallelAlgorithm::Run(SimpleMemory).0.num\ < to_signed(260, 32);
                        if (\ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [num] = Task.Factory.StartNew (<>c__DisplayClass3_.<>9__0 ?? (<>c__DisplayClass3_.<>9__0 = <>c__DisplayClass3_.<Run>b__0), num);
                            -- 	num = num + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [num] = Task.Factory.StartNew (<>c__DisplayClass3_.<>9__0 ?? (<>c__DisplayClass3_.<>9__0 = <>c__DisplayClass3_.<Run>b__0), num);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object)
                            case \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\ is 
                                when 0 => 
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.0\ <= \ParallelAlgorithm::Run(SimpleMemory).0.num\;
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\ <= true;
                                when 1 => 
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.1\ <= \ParallelAlgorithm::Run(SimpleMemory).0.num\;
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\ <= true;
                                when 2 => 
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.2\ <= \ParallelAlgorithm::Run(SimpleMemory).0.num\;
                                    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\ <= true;
                            end case;
                            \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\ := \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num + 1;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.1\ := \ParallelAlgorithm::Run(SimpleMemory).0.num\ + to_signed(1, 32);
                            \ParallelAlgorithm::Run(SimpleMemory).0.num\ := \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.1\;
                        else 
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6016
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_5\ => 
                        -- State after the while loop which was started in state \ParallelAlgorithm::Run(SimpleMemory).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object)
                        if (\ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\ = \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.1\ and \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\ = \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.2\ and \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\ = \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.0\) then 
                            \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).invocationIndex\ := 0;
                            \ParallelAlgorithm::Run(SimpleMemory).0.return.0\ := \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.0\;
                            \ParallelAlgorithm::Run(SimpleMemory).0.return.1\ := \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.1\;
                            \ParallelAlgorithm::Run(SimpleMemory).0.return.2\ := \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.2\;
                            \ParallelAlgorithm::Run(SimpleMemory).0.array\(0) := \ParallelAlgorithm::Run(SimpleMemory).0.return.0\;
                            \ParallelAlgorithm::Run(SimpleMemory).0.array\(1) := \ParallelAlgorithm::Run(SimpleMemory).0.return.1\;
                            \ParallelAlgorithm::Run(SimpleMemory).0.array\(2) := \ParallelAlgorithm::Run(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.num2\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- int num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 0;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.num3\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num3 < 260) {
                            -- 	num2 = num2 + array [num3].Result;
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \ParallelAlgorithm::Run(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.2\ := \ParallelAlgorithm::Run(SimpleMemory).0.num3\ < to_signed(260, 32);
                        if (\ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2 = num2 + array [num3].Result;
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + array [num3].Result;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.3\ := \ParallelAlgorithm::Run(SimpleMemory).0.num2\ + \ParallelAlgorithm::Run(SimpleMemory).0.array\(to_integer(\ParallelAlgorithm::Run(SimpleMemory).0.num3\));
                            \ParallelAlgorithm::Run(SimpleMemory).0.num2\ := \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + 1;
                            -- 
                            \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.4\ := \ParallelAlgorithm::Run(SimpleMemory).0.num3\ + to_signed(1, 32);
                            \ParallelAlgorithm::Run(SimpleMemory).0.num3\ := \ParallelAlgorithm::Run(SimpleMemory).0.binaryOperationResult.4\;
                        else 
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \ParallelAlgorithm::Run(SimpleMemory).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteInt32 (0, num2);
                        -- 
                        -- Begin SimpleMemory write.
                        \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\ParallelAlgorithm::Run(SimpleMemory).0.num2\);
                        \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \ParallelAlgorithm::Run(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \ParallelAlgorithm::Run(SimpleMemory).0._State\ := \ParallelAlgorithm::Run(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\: \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._States\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_0\;
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\: boolean := false;
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.1\: boolean := false;
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.5\: boolean := false;
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.6\: boolean := false;
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\ <= false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_0\;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.dataIn.0\ := (others => '0');
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.1\ := false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 64);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.5\ := false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.6\ := false;
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.8\ := to_signed(0, 64);
                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.9\ := false;
            else 
                case \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ is 
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\ <= false;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint number;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- number = memory.ReadUInt32 (0);
                        -- // Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        -- Begin SimpleMemory read.
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number\ := ConvertStdLogicVectorToUInt32(\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = number;
                            -- 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number\;
                            -- The following section was transformed from the .NET statement below:
                            -- bool return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 / 2u;
                            -- 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.0\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ / to_unsigned(2, 32);
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = 2u;
                            -- 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := to_unsigned(2, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 <= num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 && (long)(number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 - number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 / num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 * num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) != 0L) {
                            -- 	num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = (uint)((long)(num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) + 1L);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\.
                        -- The while loop's condition:
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.1\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ <= \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\;
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_5\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = (long)(num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) == (long)(num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) + 1L;
                        -- // Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.8\ := signed(SmartResize((\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\), 64)) + to_signed(1, 64);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.9\ := signed(SmartResize((\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\), 64)) = \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.8\;
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteBoolean (0, return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4);
                        -- 
                        -- Begin SimpleMemory write.
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertBooleanToStdLogicVector(\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.return_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.6715
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_6\ => 
                        -- Waiting for the result to appear in \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_7\;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ / \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\;
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_7\ => 
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.3\ := SmartResize(\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2\ * \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\, 32);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.4\ := signed(SmartResize(\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.number_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ - \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.3\, 64));
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.5\ := (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.4\) /= to_signed(0, 64);
                        \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.6\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.1\ and \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.5\;
                        if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = (uint)((long)(num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4 = (uint)((long)(num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4) + 1L);
                            -- 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\), 64)) + to_signed(1, 64)), 32);
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.num2_65edf02126ec999da8ed01ba559c6407e75facb2cf0b8edcf75f68a119ff33b4\ := (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.7\);
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_3\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ = \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_8\) then 
                                \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_4\;
                            end if;
                        else 
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                    when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\: \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._States\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Finished\ <= false;
                \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= false;
                \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_0\;
            else 
                case \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ is 
                    when \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Finished\ <= false;
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.IsPrimeNumberSync (memory);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= true;
                        \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
                        if (\PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ = \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\) then 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- return Task.CompletedTask;
                            -- 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State\ := \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\: \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._States\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_0\;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.10\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.11\: boolean := false;
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        attribute dont_touch of \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Finished\ <= false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_0\;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.0\ := (others => '0');
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\ := to_signed(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.1\ := (others => '0');
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\ := to_signed(0, 64);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.10\ := to_signed(0, 64);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.11\ := false;
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.12\ := to_signed(0, 32);
                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.13\ := to_signed(0, 32);
            else 
                case \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ is 
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Finished\ <= false;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((long)(num2) < (long)(num)) {
                            -- 	uint number;
                            -- 	number = memory.ReadUInt32 (1 + num2);
                            -- 	// Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                            -- 	uint number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number;
                            -- 	bool return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	uint num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / 2u;
                            -- 	uint num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = 2u;
                            -- 	while (num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 <= num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 && (long)(number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 - number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 * num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) != 0L) {
                            -- 		num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (uint)((long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L);
                            -- 	}
                            -- 	return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) == (long)(num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L;
                            -- 	// Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                            -- 	memory.WriteBoolean (1 + num2, return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\.
                        -- The while loop's condition:
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\ := SmartResize((\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\), 64) < signed(SmartResize((\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num\), 64));
                        if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	uint number;
                            -- 	number = memory.ReadUInt32 (1 + num2);
                            -- 	// Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                            -- 	uint number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number;
                            -- 	bool return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	uint num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / 2u;
                            -- 	uint num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 	num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = 2u;
                            -- 	while (num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 <= num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 && (long)(number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 - number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 * num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) != 0L) {
                            -- 		num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (uint)((long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L);
                            -- 	}
                            -- 	return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) == (long)(num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L;
                            -- 	// Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                            -- 	memory.WriteBoolean (1 + num2, return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint number;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- number = memory.ReadUInt32 (1 + num2);
                            -- // Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\ := to_signed(1, 32) + \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\;
                            -- Begin SimpleMemory read.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\;
                        else 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.616
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_5\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\.
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number\ := ConvertStdLogicVectorToUInt32(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.dataIn.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number;
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number\;
                            -- The following section was transformed from the .NET statement below:
                            -- bool return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / 2u;
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ / to_unsigned(2, 32);
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = 2u;
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := to_unsigned(2, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 <= num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 && (long)(number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 - number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 / num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 * num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) != 0L) {
                            -- 	num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (uint)((long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ <= \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) == (long)(num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L;
                        -- // Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.10\ := signed(SmartResize((\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\), 64)) + to_signed(1, 64);
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.11\ := signed(SmartResize((\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\), 64)) = \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.10\;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteBoolean (1 + num2, return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10);
                        -- 
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.12\ := to_signed(1, 32) + \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\;
                        -- Begin SimpleMemory write.
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.12\;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertBooleanToStdLogicVector(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.return_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\);
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.9978
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_9\ => 
                        -- Waiting for the result to appear in \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_10\;
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ / \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\;
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_10\ => 
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\ := SmartResize(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ * \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\, 32);
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\ := signed(SmartResize(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.number_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ - \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\, 64));
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\ := (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\) /= to_signed(0, 64);
                        \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\ and \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\;
                        if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (uint)((long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10 = (uint)((long)(num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10) + 1L);
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\), 64)) + to_signed(1, 64)), 32);
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2_34478f687c77b7294b6488b7f6532e8a78dcd57f11c7406121f3f606bd60ed10\ := (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\);
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_6\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ = \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_11\) then 
                                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_7\;
                            end if;
                        else 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                    when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_12\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.13\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\ + to_signed(1, 32);
                            \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.num2\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.13\;
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_3\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ = \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_12\) then 
                                \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\: \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._States\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_0\;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\: \boolean_Array\(0 to 29) := (others => false);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\: integer range 0 to 2 := 0;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.0\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.1\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.2\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\: boolean := false;
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Finished\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.0\ <= to_unsigned(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.1\ <= to_unsigned(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.2\ <= to_unsigned(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\ <= false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_0\;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.0\ := (others => '0');
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\ := (others => false);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\ := to_unsigned(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.1\ := (others => '0');
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\ := 0;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.0\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.1\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.2\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\ := false;
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\ := to_signed(0, 32);
                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\ := to_signed(0, 32);
            else 
                case \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ is 
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Started\ = true) then 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Finished\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- Task<bool>[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new Task<bool>[30];
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\ := (others => false);
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((long)(num2) < (long)(num)) {
                            -- 	int num3;
                            -- 	num3 = 0;
                            -- 	while (num3 < 30) {
                            -- 		uint num4;
                            -- 		num4 = memory.ReadUInt32 (1 + num2 + num3);
                            -- 		array [num3] = Task.Factory.StartNew ((Func<object, bool>)this.<ParallelizedArePrimeNumbers>b__9_0, num4);
                            -- 		num3 = num3 + 1;
                            -- 	}
                            -- 	Task.WhenAll (array).Wait ();
                            -- 	int num5;
                            -- 	num5 = 0;
                            -- 	while (num5 < 30) {
                            -- 		memory.WriteBoolean (1 + num2 + num5, array [num5].Result);
                            -- 		num5 = num5 + 1;
                            -- 	}
                            -- 	num2 = num2 + 30;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\.
                        -- The while loop's condition:
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\ := SmartResize((\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\), 64) < signed(SmartResize((\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num\), 64));
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int num3;
                            -- 	num3 = 0;
                            -- 	while (num3 < 30) {
                            -- 		uint num4;
                            -- 		num4 = memory.ReadUInt32 (1 + num2 + num3);
                            -- 		array [num3] = Task.Factory.StartNew ((Func<object, bool>)this.<ParallelizedArePrimeNumbers>b__9_0, num4);
                            -- 		num3 = num3 + 1;
                            -- 	}
                            -- 	Task.WhenAll (array).Wait ();
                            -- 	int num5;
                            -- 	num5 = 0;
                            -- 	while (num5 < 30) {
                            -- 		memory.WriteBoolean (1 + num2 + num5, array [num5].Result);
                            -- 		num5 = num5 + 1;
                            -- 	}
                            -- 	num2 = num2 + 30;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 0;
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num3 < 30) {
                            -- 	uint num4;
                            -- 	num4 = memory.ReadUInt32 (1 + num2 + num3);
                            -- 	array [num3] = Task.Factory.StartNew ((Func<object, bool>)this.<ParallelizedArePrimeNumbers>b__9_0, num4);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_6\;
                        else 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_5\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\.
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\.
                        -- The while loop's condition:
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\ < to_signed(30, 32);
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	uint num4;
                            -- 	num4 = memory.ReadUInt32 (1 + num2 + num3);
                            -- 	array [num3] = Task.Factory.StartNew ((Func<object, bool>)this.<ParallelizedArePrimeNumbers>b__9_0, num4);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- uint num4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = memory.ReadUInt32 (1 + num2 + num3);
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\ := to_signed(1, 32) + \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.2\ + \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\;
                            -- Begin SimpleMemory read.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.3\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_8\;
                        else 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_7\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll (array).Wait ();
                        -- 
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_8\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\ := ConvertStdLogicVectorToUInt32(\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.dataIn.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- array [num3] = Task.Factory.StartNew ((Func<object, bool>)this.<ParallelizedArePrimeNumbers>b__9_0, num4);
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object)
                            case \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\ is 
                                when 0 => 
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.0\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\;
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\ <= true;
                                when 1 => 
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.1\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\;
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\ <= true;
                                when 2 => 
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.2\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num4\;
                                    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\ <= true;
                            end case;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + 1;
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\ + to_signed(1, 32);
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num3\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4\;
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_8\) then 
                                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object)
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.1\ and \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.2\ and \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.0\) then 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\ <= false;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).invocationIndex\ := 0;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.0\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.0\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.1\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.1\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.2\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.2\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\(0) := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.0\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\(1) := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.1\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\(2) := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- int num5;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = 0;
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num5 < 30) {
                            -- 	memory.WriteBoolean (1 + num2 + num5, array [num5].Result);
                            -- 	num5 = num5 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_10\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\.
                        -- The while loop's condition:
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\ < to_signed(30, 32);
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.5\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteBoolean (1 + num2 + num5, array [num5].Result);
                            -- 	num5 = num5 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteBoolean (1 + num2 + num5, array [num5].Result);
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\ := to_signed(1, 32) + \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.6\ + \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\;
                            -- Begin SimpleMemory write.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.7\;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertBooleanToStdLogicVector(\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.array\(to_integer(\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\)));
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_12\;
                        else 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_11\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + 30;
                        -- 
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\ + to_signed(30, 32);
                        \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num2\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.9\;
                        -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_3\ if the loop wasn't exited with a state change.
                        if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_11\) then 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_12\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = num5 + 1;
                            -- 
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\ + to_signed(1, 32);
                            \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.num5\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.binaryOperationResult.8\;
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_9\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ = \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_12\) then 
                                \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State\ := \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).0 state machine start
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\: \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._States\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_0\;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.1\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.5\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.6\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Finished\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_0\;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.1\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.4\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.5\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.6\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.8\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.9\ := false;
            else 
                case \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ is 
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Finished\ <= true;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Finished\ <= false;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = numberObject;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / to_unsigned(2, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 <= num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 && (long)(number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 - number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 * num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) != 0L) {
                        -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\.
                        -- The while loop's condition:
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.1\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_4\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) == (long)(num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L;
                        -- // Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.8\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.9\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.8\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- return return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.6715
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_5\ => 
                        -- Waiting for the result to appear in \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_6\;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_6\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.3\ := SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2\ * \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.4\ := signed(SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ - \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.3\, 64));
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.5\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.4\) /= to_signed(0, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.6\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.1\ and \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.5\;
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64)), 32);
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.7\);
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_2\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_7\) then 
                                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_3\;
                            end if;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).0 state machine end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).1 state machine start
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\: \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._States\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_0\;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.1\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.5\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.6\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Finished\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_0\;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.1\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.4\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.5\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.6\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.7\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.8\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.9\ := false;
            else 
                case \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ is 
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Finished\ <= true;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Finished\ <= false;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = numberObject;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / to_unsigned(2, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 <= num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 && (long)(number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 - number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 * num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) != 0L) {
                        -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\.
                        -- The while loop's condition:
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.1\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_4\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) == (long)(num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L;
                        -- // Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.8\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.9\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.8\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- return return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.6715
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_5\ => 
                        -- Waiting for the result to appear in \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_6\;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_6\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.3\ := SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2\ * \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.4\ := signed(SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ - \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.3\, 64));
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.5\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.4\) /= to_signed(0, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.6\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.1\ and \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.5\;
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64)), 32);
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.7\);
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_2\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_7\) then 
                                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_3\;
                            end if;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).1 state machine end


    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).2 state machine start
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._StateMachine\: process (\Clock\) 
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\: \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._States\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_0\;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.1\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.5\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.6\: boolean := false;
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.9\: boolean := false;
        attribute dont_touch of \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\: Variable is "true";
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Finished\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return\ <= false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_0\;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.1\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.4\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.5\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.6\ := false;
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.7\ := to_unsigned(0, 32);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.8\ := to_signed(0, 64);
                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.9\ := false;
            else 
                case \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ is 
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Started\ = true) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Finished\ <= true;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Finished\ <= false;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ;
                        -- // Starting inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = numberObject;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / to_unsigned(2, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = 2u;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := to_unsigned(2, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 <= num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 && (long)(number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 - number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 / num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 * num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) != 0L) {
                        -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\.
                        -- The while loop's condition:
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.1\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_4\ => 
                        -- State after the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) == (long)(num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L;
                        -- // Ending inlined block of the method System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberInternal(System.UInt32).
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.8\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.9\ := signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.8\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- return return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893;
                        -- 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.6715
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_5\ => 
                        -- Waiting for the result to appear in \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\ (have to wait 9 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(9, 32)) then 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_6\;
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ / \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\;
                        -- Clock cycles needed to complete this state (approximation): 9
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_6\ => 
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.3\ := SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2\ * \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\, 32);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.4\ := signed(SmartResize(\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.number_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ - \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.3\, 64));
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.7471
                    when \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.5\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.4\) /= to_signed(0, 64);
                        \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.6\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.1\ and \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.5\;
                        if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893 = (uint)((long)(num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893) + 1L);
                            -- 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\), 64)) + to_signed(1, 64)), 32);
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.num2_8b287aa690232679281c158d2c66f713a281a6926ef9ca245a3e83aa99c72893\ := (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.7\);
                            -- Returning to the repeated state of the while loop which was started in state \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_2\ if the loop wasn't exited with a state change.
                            if (\PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ = \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_7\) then 
                                \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_3\;
                            end if;
                        else 
                            \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State\ := \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object).2 state machine end


    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\: \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._States\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_0\;
        Variable \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Finished\ <= false;
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_0\;
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.return.0\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ is 
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Started\ = true) then 
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Started\ = true) then 
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Finished\ <= false;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, 1u);
                        -- 
                        -- Begin SimpleMemory write.
                        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(to_unsigned(1, 32));
                        \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- short number;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- number = (short)memory.ReadInt32 (0);
                            -- 
                            -- Begin SimpleMemory read.
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.number\ := SmartResize(ConvertStdLogicVectorToInt32(\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 (0, this.RecursivelyCalculateFibonacchiSeries (memory, number));
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.number\;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.return.0\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.return.0\);
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_6\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\: \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._States\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_0\;
        Variable \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Finished\ <= false;
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_0\;
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.return.0\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ is 
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Started\ = true) then 
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Started\ = true) then 
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Finished\ <= false;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, 1u);
                        -- 
                        -- Begin SimpleMemory write.
                        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(to_unsigned(1, 32));
                        \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- short number;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- number = (short)memory.ReadInt32 (0);
                            -- 
                            -- Begin SimpleMemory read.
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.number\ := SmartResize(ConvertStdLogicVectorToInt32(\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.dataIn.0\), 16);
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteUInt32 (0, this.RecursivelyCalculateFactorial (memory, number));
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.number\;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= true;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.return.0\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\;
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.return.0\);
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_6\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State\ := \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._States\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.2\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.3\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.4\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.5\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.2\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.3\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.4\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.5\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.1\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.6\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0 || (int)(number) == 1) {
                            -- 	return (uint)number;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\), 32) = to_signed(0, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.2\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\), 32) = to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.3\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.1\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.2\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.3\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 2)) + this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 1));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.4\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\), 32) - to_signed(2, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.4\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return (uint)number;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)number;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return\ <= ToUnsignedAndExpand(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.5\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number\), 32) - to_signed(1, 32), 16);
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_8\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_9\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.5\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.1\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.6\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.0\ + \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return.1\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.binaryOperationResult.6\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._States\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.2\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.3\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.4\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.5\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.2\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.3\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.4\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.5\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.1\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.6\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0 || (int)(number) == 1) {
                            -- 	return (uint)number;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\), 32) = to_signed(0, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.2\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\), 32) = to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.3\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.1\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.2\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.3\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 2)) + this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 1));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.4\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\), 32) - to_signed(2, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.4\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return (uint)number;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)number;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return\ <= ToUnsignedAndExpand(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.5\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number\), 32) - to_signed(1, 32), 16);
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_8\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_9\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.5\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.1\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.6\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.0\ + \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return.1\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.binaryOperationResult.6\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._States\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.2\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.3\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.4\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.5\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.2\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.3\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.4\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.5\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.1\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.6\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0 || (int)(number) == 1) {
                            -- 	return (uint)number;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\), 32) = to_signed(0, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.2\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\), 32) = to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.3\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.1\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.2\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.3\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 2)) + this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 1));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.4\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\), 32) - to_signed(2, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.4\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return (uint)number;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)number;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return\ <= ToUnsignedAndExpand(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.5\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number\), 32) - to_signed(1, 32), 16);
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_8\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_9\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.5\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.1\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.6\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.0\ + \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return.1\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.binaryOperationResult.6\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._States\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.2\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.3\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.4\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.5\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.2\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.3\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.4\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.5\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.1\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.6\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0 || (int)(number) == 1) {
                            -- 	return (uint)number;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\), 32) = to_signed(0, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.2\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\), 32) = to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.3\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.1\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.2\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.3\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6518
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 2)) + this.RecursivelyCalculateFibonacchiSeries (memory, (short)((int)(number) - 1));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.4\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\), 32) - to_signed(2, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.4\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return (uint)number;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)number;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return\ <= ToUnsignedAndExpand(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.5\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number\), 32) - to_signed(1, 32), 16);
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_8\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_9\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.5\);
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.1\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.6\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.0\ + \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return.1\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.binaryOperationResult.6\;
                            \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._States\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.2\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.2\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0) {
                            -- 	return 1u;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\), 32) = to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.1\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(number) * (long)(this.RecursivelyCalculateFactorial (memory, (short)((int)(number) - 1))));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.2\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\), 32) - to_signed(1, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.2\);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return 1u;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return\ <= to_unsigned(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.3\ := SmartResize(unsigned(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number\), 64) * signed(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return.0\), 64))), 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.binaryOperationResult.3\);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7638
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._States\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.2\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.2\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0) {
                            -- 	return 1u;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\), 32) = to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.1\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(number) * (long)(this.RecursivelyCalculateFactorial (memory, (short)((int)(number) - 1))));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.2\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\), 32) - to_signed(1, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.2\);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return 1u;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return\ <= to_unsigned(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.3\ := SmartResize(unsigned(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number\), 64) * signed(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return.0\), 64))), 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.binaryOperationResult.3\);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7638
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._States\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.2\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.2\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0) {
                            -- 	return 1u;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\), 32) = to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.1\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(number) * (long)(this.RecursivelyCalculateFactorial (memory, (short)((int)(number) - 1))));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.2\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\), 32) - to_signed(1, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.2\);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return 1u;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return\ <= to_unsigned(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.3\ := SmartResize(unsigned(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number\), 64) * signed(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return.0\), 64))), 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.binaryOperationResult.3\);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7638
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 state machine end


    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 state machine start
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._StateMachine\: process (\Clock\) 
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._States\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_0\;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.1\: boolean := false;
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.2\: signed(15 downto 0) := to_signed(0, 16);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Finished\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return\ <= to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.DataOut\ <= (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_0\;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.dataIn.0\ := (others => '0');
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.1\ := false;
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.2\ := to_signed(0, 16);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return.0\ := to_unsigned(0, 32);
                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ is 
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Started\ = true) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Finished\ <= true;
                        else 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Finished\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_2\ => 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (1, (uint)((long)(memory.ReadUInt32 (1)) + 1L));
                        -- 
                        -- Begin SimpleMemory read.
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.dataIn.0\ := \DataIn\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((ConvertStdLogicVectorToUInt32(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.dataIn.0\)), 64)) + to_signed(1, 64)), 32);
                            -- Begin SimpleMemory write.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.CellIndex\ <= to_signed(1, 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= true;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.0\));
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((int)(number) == 0) {
                            -- 	return 1u;
                            -- }
                            -- 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.1\ := SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\), 32) = to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\ and ends in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\.
                            --     * Execution after either branch will continue in the following state: \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_5\.

                            if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.1\) then 
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.264
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_5\ => 
                        -- State after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)((long)(number) * (long)(this.RecursivelyCalculateFactorial (memory, (short)((int)(number) - 1))));
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.2\ := SmartResize(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\), 32) - to_signed(1, 32), 16);
                        -- Starting state machine invocation for the following method: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.2\);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= true;
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\ => 
                        -- True branch of the if-else started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	return 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- return 1u;
                        -- 
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return\ <= to_unsigned(1, 32);
                        \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_1\;
                        -- Going to the state after the if-else which was started in state \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_4\.
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_6\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16)
                        if (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ = \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\) then 
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\ <= false;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return.0\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\;
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.3\ := SmartResize(unsigned(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number\), 64) * signed(SmartResize((\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return.0\), 64))), 32);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return\ <= (\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.binaryOperationResult.3\);
                            \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State\ := \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7638
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).3 state machine end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \SimdCalculator::AddVectors(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \SimdCalculator::AddVectors(SimpleMemory).0._State\: \SimdCalculator::AddVectors(SimpleMemory).0._States\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \SimdCalculator::AddVectors(SimpleMemory).0._Finished\ <= false;
                \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                \SimdCalculator::AddVectors(SimpleMemory).0._State\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_0\;
            else 
                case \SimdCalculator::AddVectors(SimpleMemory).0._State\ is 
                    when \SimdCalculator::AddVectors(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\SimdCalculator::AddVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::AddVectors(SimpleMemory).0._State\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::AddVectors(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\SimdCalculator::AddVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::AddVectors(SimpleMemory).0._Finished\ <= true;
                        else 
                            \SimdCalculator::AddVectors(SimpleMemory).0._Finished\ <= false;
                            \SimdCalculator::AddVectors(SimpleMemory).0._State\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::AddVectors(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.RunSimdOperation (memory, SimdOperation.Add);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\ <= \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Add\;
                        \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= true;
                        \SimdCalculator::AddVectors(SimpleMemory).0._State\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::AddVectors(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        if (\SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\) then 
                            \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                            \SimdCalculator::AddVectors(SimpleMemory).0._State\ := \SimdCalculator::AddVectors(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \SimdCalculator::SubtractVectors(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \SimdCalculator::SubtractVectors(SimpleMemory).0._State\: \SimdCalculator::SubtractVectors(SimpleMemory).0._States\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \SimdCalculator::SubtractVectors(SimpleMemory).0._Finished\ <= false;
                \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_0\;
            else 
                case \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ is 
                    when \SimdCalculator::SubtractVectors(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\SimdCalculator::SubtractVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::SubtractVectors(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\SimdCalculator::SubtractVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::SubtractVectors(SimpleMemory).0._Finished\ <= true;
                        else 
                            \SimdCalculator::SubtractVectors(SimpleMemory).0._Finished\ <= false;
                            \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::SubtractVectors(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.RunSimdOperation (memory, SimdOperation.Subtract);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\ <= \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Subtract\;
                        \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= true;
                        \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::SubtractVectors(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        if (\SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\) then 
                            \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                            \SimdCalculator::SubtractVectors(SimpleMemory).0._State\ := \SimdCalculator::SubtractVectors(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \SimdCalculator::MultiplyVectors(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\: \SimdCalculator::MultiplyVectors(SimpleMemory).0._States\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \SimdCalculator::MultiplyVectors(SimpleMemory).0._Finished\ <= false;
                \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_0\;
            else 
                case \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ is 
                    when \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\SimdCalculator::MultiplyVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\SimdCalculator::MultiplyVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0._Finished\ <= true;
                        else 
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0._Finished\ <= false;
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.RunSimdOperation (memory, SimdOperation.Multiply);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\ <= \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Multiply\;
                        \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= true;
                        \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        if (\SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\) then 
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0._State\ := \SimdCalculator::MultiplyVectors(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \SimdCalculator::DivideVectors(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \SimdCalculator::DivideVectors(SimpleMemory).0._State\: \SimdCalculator::DivideVectors(SimpleMemory).0._States\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_0\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \SimdCalculator::DivideVectors(SimpleMemory).0._Finished\ <= false;
                \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                \SimdCalculator::DivideVectors(SimpleMemory).0._State\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_0\;
            else 
                case \SimdCalculator::DivideVectors(SimpleMemory).0._State\ is 
                    when \SimdCalculator::DivideVectors(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\SimdCalculator::DivideVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::DivideVectors(SimpleMemory).0._State\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::DivideVectors(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\SimdCalculator::DivideVectors(SimpleMemory).0._Started\ = true) then 
                            \SimdCalculator::DivideVectors(SimpleMemory).0._Finished\ <= true;
                        else 
                            \SimdCalculator::DivideVectors(SimpleMemory).0._Finished\ <= false;
                            \SimdCalculator::DivideVectors(SimpleMemory).0._State\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::DivideVectors(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- this.RunSimdOperation (memory, SimdOperation.Divide);
                        -- 
                        -- Starting state machine invocation for the following method: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\ <= \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Divide\;
                        \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= true;
                        \SimdCalculator::DivideVectors(SimpleMemory).0._State\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::DivideVectors(SimpleMemory).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation)
                        if (\SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\) then 
                            \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ <= false;
                            \SimdCalculator::DivideVectors(SimpleMemory).0._State\ := \SimdCalculator::DivideVectors(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation).0 state machine start
    \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._StateMachine\: process (\Clock\) 
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\: \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._States\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_0\;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation\: \Hast.Samples.SampleAssembly.SimdOperation\;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.0\: boolean := false;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\: \signed32_Array\(0 to 19) := (others => to_signed(0, 32));
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\: \signed32_Array\(0 to 19) := (others => to_signed(0, 32));
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\: \signed32_Array\(0 to 19) := (others => to_signed(0, 32));
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.1\: boolean := false;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.1\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.5\: boolean := false;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.2\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.90\: boolean := false;
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.91\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.92\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.93\: signed(31 downto 0) := to_signed(0, 32);
        Variable \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.94\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\ <= false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.DataOut\ <= (others => '0');
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ <= false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.10\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.11\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.12\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.13\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.14\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.15\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.16\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.17\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.18\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.19\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.20\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.21\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.22\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.23\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.24\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.25\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.26\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.27\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.28\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.29\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.30\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.31\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.32\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.33\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.34\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.35\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.36\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.37\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.38\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.39\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.40\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.41\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.42\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.43\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.44\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.45\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.46\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.47\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.48\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.49\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.50\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.51\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.52\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.53\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.54\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.55\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.56\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.57\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.58\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.59\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.60\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.61\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.62\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.63\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.64\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.65\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.66\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.67\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.68\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.69\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89\ <= to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_0\;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.0\ := (others => '0');
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.0\ := false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\ := (others => to_signed(0, 32));
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\ := (others => to_signed(0, 32));
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (others => to_signed(0, 32));
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.1\ := false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.2\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.3\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.1\ := (others => '0');
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.4\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.5\ := false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.6\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.7\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.8\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.2\ := (others => '0');
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.9\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.90\ := false;
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.91\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.92\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.93\ := to_signed(0, 32);
                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.94\ := to_signed(0, 32);
            else 
                case \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ is 
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ = true) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ = true) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\ <= true;
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\ <= false;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_2\ => 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= true;
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= false;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.0\ := \DataIn\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num\ := ConvertStdLogicVectorToInt32(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- int num2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2 < num) {
                            -- 	int[] array;
                            -- 	array = new int[20];
                            -- 	int[] array2;
                            -- 	array2 = new int[20];
                            -- 	int[] array3;
                            -- 	array3 = new int[20];
                            -- 	int num3;
                            -- 	num3 = 0;
                            -- 	while (num3 < 20) {
                            -- 		array [num3] = memory.ReadInt32 (1 + num2 + num3);
                            -- 		num3 = num3 + 1;
                            -- 	}
                            -- 	int num4;
                            -- 	num4 = 0;
                            -- 	while (num4 < 20) {
                            -- 		array2 [num4] = memory.ReadInt32 (1 + num2 + num4 + num);
                            -- 		num4 = num4 + 1;
                            -- 	}
                            -- 	switch (operation) {
                            -- 	case SimdOperation.Add:
                            -- 		array3 = SimdOperations.AddVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Subtract:
                            -- 		array3 = SimdOperations.SubtractVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Multiply:
                            -- 		array3 = SimdOperations.MultiplyVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Divide:
                            -- 		array3 = SimdOperations.DivideVectors (array, array2, 20);
                            -- 		break;
                            -- 	}
                            -- 	int num5;
                            -- 	num5 = 0;
                            -- 	while (num5 < 20) {
                            -- 		memory.WriteInt32 (1 + num2 + num5, array3 [num5]);
                            -- 		num5 = num5 + 1;
                            -- 	}
                            -- 	num2 = num2 + 20;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\.
                        -- The while loop's condition:
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.0\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\ < \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num\;
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	int[] array;
                            -- 	array = new int[20];
                            -- 	int[] array2;
                            -- 	array2 = new int[20];
                            -- 	int[] array3;
                            -- 	array3 = new int[20];
                            -- 	int num3;
                            -- 	num3 = 0;
                            -- 	while (num3 < 20) {
                            -- 		array [num3] = memory.ReadInt32 (1 + num2 + num3);
                            -- 		num3 = num3 + 1;
                            -- 	}
                            -- 	int num4;
                            -- 	num4 = 0;
                            -- 	while (num4 < 20) {
                            -- 		array2 [num4] = memory.ReadInt32 (1 + num2 + num4 + num);
                            -- 		num4 = num4 + 1;
                            -- 	}
                            -- 	switch (operation) {
                            -- 	case SimdOperation.Add:
                            -- 		array3 = SimdOperations.AddVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Subtract:
                            -- 		array3 = SimdOperations.SubtractVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Multiply:
                            -- 		array3 = SimdOperations.MultiplyVectors (array, array2, 20);
                            -- 		break;
                            -- 	case SimdOperation.Divide:
                            -- 		array3 = SimdOperations.DivideVectors (array, array2, 20);
                            -- 		break;
                            -- 	}
                            -- 	int num5;
                            -- 	num5 = 0;
                            -- 	while (num5 < 20) {
                            -- 		memory.WriteInt32 (1 + num2 + num5, array3 [num5]);
                            -- 		num5 = num5 + 1;
                            -- 	}
                            -- 	num2 = num2 + 20;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- int[] array;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array = new int[20];
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\ := (others => to_signed(0, 32));
                            -- The following section was transformed from the .NET statement below:
                            -- int[] array2;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array2 = new int[20];
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\ := (others => to_signed(0, 32));
                            -- The following section was transformed from the .NET statement below:
                            -- int[] array3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array3 = new int[20];
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (others => to_signed(0, 32));
                            -- The following section was transformed from the .NET statement below:
                            -- int num3;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 0;
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num3 < 20) {
                            -- 	array [num3] = memory.ReadInt32 (1 + num2 + num3);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_6\;
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2753
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_5\ => 
                        -- State after the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\.
                        -- The while loop's condition:
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.1\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\ < to_signed(20, 32);
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [num3] = memory.ReadInt32 (1 + num2 + num3);
                            -- 	num3 = num3 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [num3] = memory.ReadInt32 (1 + num2 + num3);
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.2\ := to_signed(1, 32) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.3\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.2\ + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\;
                            -- Begin SimpleMemory read.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.3\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_8\;
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\ => 
                        -- State after the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = 0;
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num4 < 20) {
                        -- 	array2 [num4] = memory.ReadInt32 (1 + num2 + num4 + num);
                        -- 	num4 = num4 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_8\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= false;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.1\ := \DataIn\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(to_integer(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\)) := ConvertStdLogicVectorToInt32(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 + 1;
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.4\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\ + to_signed(1, 32);
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num3\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.4\;
                            -- Returning to the repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\ if the loop wasn't exited with a state change.
                            if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_8\) then 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\.
                        -- The while loop's condition:
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.5\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\ < to_signed(20, 32);
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.5\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array2 [num4] = memory.ReadInt32 (1 + num2 + num4 + num);
                            -- 	num4 = num4 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array2 [num4] = memory.ReadInt32 (1 + num2 + num4 + num);
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.6\ := to_signed(1, 32) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.7\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.6\ + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_11\;
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\ => 
                        -- State after the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- switch (operation) {
                        -- case SimdOperation.Add:
                        -- 	array3 = SimdOperations.AddVectors (array, array2, 20);
                        -- 	break;
                        -- case SimdOperation.Subtract:
                        -- 	array3 = SimdOperations.SubtractVectors (array, array2, 20);
                        -- 	break;
                        -- case SimdOperation.Multiply:
                        -- 	array3 = SimdOperations.MultiplyVectors (array, array2, 20);
                        -- 	break;
                        -- case SimdOperation.Divide:
                        -- 	array3 = SimdOperations.DivideVectors (array, array2, 20);
                        -- 	break;
                        -- }
                        -- 
                        case \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation\ is 
                            when \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Add\ => 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_14\;
                            when \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Subtract\ => 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_16\;
                            when \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Multiply\ => 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_18\;
                            when \Hast.Samples.SampleAssembly.SimdOperation Hast.Samples.SampleAssembly.SimdOperation::Divide\ => 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_20\;
                            when others => 
                                null;
                        end case;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.8\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.7\ + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num\;
                        -- Begin SimpleMemory read.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.8\;
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= true;
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_12\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ <= false;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.2\ := \DataIn\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(to_integer(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\)) := ConvertStdLogicVectorToInt32(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.dataIn.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = num4 + 1;
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.9\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\ + to_signed(1, 32);
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num4\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.9\;
                            -- Returning to the repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_7\ if the loop wasn't exited with a state change.
                            if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_12\) then 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_9\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\ => 
                        -- State after the case statement which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = 0;
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (num5 < 20) {
                        -- 	memory.WriteInt32 (1 + num2 + num5, array3 [num5]);
                        -- 	num5 = num5 + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_14\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- array3 = SimdOperations.AddVectors (array, array2, 20);
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.10\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(0) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(0);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.11\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(1) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(1);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.12\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(2) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(2);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.13\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(3) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(3);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.14\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(4) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(4);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.15\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(5) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(5);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.16\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(6) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(6);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.17\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(7) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(7);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.18\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(8) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(8);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.19\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(9) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(9);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.20\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(10) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(10);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.21\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(11) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(11);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.22\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(12) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(12);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.23\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(13) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(13);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.24\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(14) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(14);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.25\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(15) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(15);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.26\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(16) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(16);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.27\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(17) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(17);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.28\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(18) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(18);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.29\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(19) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(19);
                        -- A SIMD operation's results should always be read out in the next clock cycle at earliest, so closing the current state.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_15\ => 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.10\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.11\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.12\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.13\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.14\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.15\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.16\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.17\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.18\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.19\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.20\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.21\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.22\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.23\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.24\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.25\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.26\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.27\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.28\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.29\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_15\) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_16\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- array3 = SimdOperations.SubtractVectors (array, array2, 20);
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.30\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(0) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(0);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.31\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(1) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(1);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.32\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(2) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(2);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.33\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(3) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(3);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.34\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(4) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(4);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.35\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(5) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(5);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.36\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(6) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(6);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.37\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(7) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(7);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.38\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(8) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(8);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.39\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(9) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(9);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.40\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(10) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(10);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.41\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(11) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(11);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.42\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(12) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(12);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.43\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(13) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(13);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.44\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(14) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(14);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.45\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(15) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(15);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.46\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(16) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(16);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.47\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(17) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(17);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.48\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(18) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(18);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.49\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(19) - \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(19);
                        -- A SIMD operation's results should always be read out in the next clock cycle at earliest, so closing the current state.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_17\ => 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.30\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.31\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.32\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.33\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.34\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.35\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.36\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.37\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.38\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.39\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.40\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.41\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.42\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.43\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.44\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.45\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.46\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.47\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.48\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.49\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_17\) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_18\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- array3 = SimdOperations.MultiplyVectors (array, array2, 20);
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.50\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(0) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(0), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.51\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(1) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(1), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.52\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(2) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(2), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.53\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(3) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(3), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.54\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(4) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(4), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.55\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(5) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(5), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.56\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(6) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(6), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.57\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(7) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(7), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.58\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(8) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(8), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.59\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(9) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(9), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.60\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(10) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(10), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.61\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(11) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(11), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.62\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(12) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(12), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.63\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(13) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(13), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.64\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(14) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(14), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.65\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(15) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(15), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.66\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(16) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(16), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.67\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(17) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(17), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.68\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(18) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(18), 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.69\ <= SmartResize(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(19) * \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(19), 32);
                        -- A SIMD operation's results should always be read out in the next clock cycle at earliest, so closing the current state.
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.4208
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_19\ => 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.50\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.51\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.52\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.53\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.54\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.55\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.56\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.57\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.58\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.59\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.60\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.61\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.62\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.63\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.64\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.65\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.66\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.67\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.68\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.69\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_19\) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_20\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- array3 = SimdOperations.DivideVectors (array, array2, 20);
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_21\ => 
                        -- Waiting for the result to appear in \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\ (have to wait 10 clock cycles in this state).
                        -- The assignment needs to be kept up for multi-cycle operations for the result to actually appear in the target.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\ >= to_signed(10, 32)) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_22\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\ := to_signed(0, 32);
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.clockCyclesWaitedForBinaryOperationResult.0\ + to_signed(1, 32);
                        end if;
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(0) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(0);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(1) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(1);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(2) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(2);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(3) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(3);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(4) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(4);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(5) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(5);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(6) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(6);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(7) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(7);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(8) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(8);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(9) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(9);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(10) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(10);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(11) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(11);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(12) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(12);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(13) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(13);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(14) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(14);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(15) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(15);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(16) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(16);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(17) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(17);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(18) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(18);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array\(19) / \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array2\(19);
                        -- Clock cycles needed to complete this state (approximation): 10
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_22\ => 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\ := (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88\, \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89\);
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Going to the state after the case statement which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_10\.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_22\) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_23\ => 
                        -- Repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\.
                        -- The while loop's condition:
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.90\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\ < to_signed(20, 32);
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.90\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteInt32 (1 + num2 + num5, array3 [num5]);
                            -- 	num5 = num5 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (1 + num2 + num5, array3 [num5]);
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.91\ := to_signed(1, 32) + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.92\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.91\ + \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\;
                            -- Begin SimpleMemory write.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\ <= \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.92\;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.array3\(to_integer(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\)));
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_25\;
                        else 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9279
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_24\ => 
                        -- State after the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + 20;
                        -- 
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.94\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\ + to_signed(20, 32);
                        \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num2\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.94\;
                        -- Returning to the repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_3\ if the loop wasn't exited with a state change.
                        if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_24\) then 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                    when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_25\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = num5 + 1;
                            -- 
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.93\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\ + to_signed(1, 32);
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.num5\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.93\;
                            -- Returning to the repeated state of the while loop which was started in state \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_13\ if the loop wasn't exited with a state change.
                            if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ = \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_25\) then 
                                \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State\ := \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3263
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation).0 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 1 => 
                            if (\Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 2 => 
                            if (\Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 3 => 
                            if (\Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 4 => 
                            if (\Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 5 => 
                            if (\Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 6 => 
                            if (\Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 7 => 
                            if (\Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 8 => 
                            if (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 9 => 
                            if (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 10 => 
                            if (\Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 11 => 
                            if (\Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 12 => 
                            if (\Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 13 => 
                            if (\Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 14 => 
                            if (\Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 15 => 
                            if (\Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 16 => 
                            if (\Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 17 => 
                            if (\Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \GenomeMatcher::FillTable(SimpleMemory).0._Started\ <= \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Started.0\;
    \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::FillTable(SimpleMemory)._Finished.0\ <= \GenomeMatcher::FillTable(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::FillTable(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \GenomeMatcher::Traceback(SimpleMemory).0._Started\ <= \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Started.0\;
    \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0.GenomeMatcher::Traceback(SimpleMemory)._Finished.0\ <= \GenomeMatcher::Traceback(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::Traceback(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Started.0\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).stateObject.parameter.Out.0\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object)._Finished.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).return.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).stateObject.parameter.In.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(Object).0.stateObject.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_0(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.0\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.0\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.0\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).0.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.1\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.1\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.1\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.1\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.1\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).1.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.2\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.2\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.2\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.2\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.2\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).2.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#3):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.3\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.3\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.3\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.3\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.3\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).3.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#4):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.4\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.4\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.4\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.4\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.4\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).4.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#5):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.5\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.5\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.5\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.5\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.5\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).5.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#6):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.6\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.6\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.6\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.6\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.6\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).6.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#7):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.7\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.7\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.7\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.7\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.7\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).7.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#8):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.8\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.8\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.8\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.8\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.8\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).8.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#9):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.9\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.9\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.9\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.9\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.9\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).9.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#10):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.10\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.10\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.10\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.10\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.10\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).10.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#11):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.11\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.11\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.11\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.11\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.11\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).11.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#12):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.12\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.12\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.12\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.12\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.12\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).12.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#13):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.13\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.13\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.13\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.13\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.13\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).13.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#14):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.14\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.14\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.14\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.14\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.14\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).14.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#15):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.15\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.15\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.15\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.15\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.15\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).15.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#16):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.16\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.16\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.16\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.16\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.16\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).16.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#17):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.17\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.17\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.17\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.17\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.17\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).17.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#18):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.18\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.18\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.18\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.18\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.18\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).18.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#19):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.19\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.19\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.19\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.19\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.19\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).19.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#20):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.20\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.20\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.20\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.20\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.20\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).20.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#21):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.21\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.21\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.21\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.21\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.21\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).21.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#22):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.22\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.22\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.22\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.22\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.22\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).22.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#23):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.23\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.23\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.23\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.23\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.23\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).23.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#24):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.24\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.24\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.24\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.24\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.24\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).24.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#25):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.25\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.25\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.25\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.25\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.25\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).25.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#26):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.26\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.26\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.26\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.26\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.26\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).26.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#27):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.27\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.27\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.27\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.27\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.27\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).27.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#28):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.28\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.28\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.28\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.28\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.28\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).28.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#29):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.29\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.29\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.29\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.29\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.29\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).29.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#30):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.30\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.30\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.30\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.30\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.30\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).30.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#31):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.31\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.31\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.31\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.31\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.31\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).31.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#32):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.32\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.32\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.32\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.32\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.32\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).32.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#33):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.33\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.33\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.33\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.33\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.33\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).33.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#34):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.34\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.34\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.34\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.34\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.34\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).34.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#35):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.35\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.35\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.35\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.35\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.35\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).35.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#36):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.36\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.36\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.36\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.36\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.36\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).36.stateObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#37):
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Started\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Started.37\;
    \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.In\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.Out.37\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object)._Finished.37\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37._Finished\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).return.37\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.return\;
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).stateObject.parameter.In.37\ <= \HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(Object).37.stateObject.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp+<>c::<CreateMatrix>b__7_1(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.0\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.0\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.1\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.1\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.1\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.1\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.1\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.2\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.2\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.2\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.2\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.2\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#3):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.3\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.3\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.3\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.3\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.3\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#4):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.4\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.4\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.4\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.4\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.4\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#5):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.5\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.5\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.5\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.5\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.5\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#6):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.6\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.6\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.6\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.6\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.6\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#7):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.7\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.7\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.7\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.7\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.7\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#8):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.8\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.8\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.8\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.8\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.8\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#9):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.9\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.9\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.9\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.9\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.9\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#10):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.10\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.10\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.10\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.10\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.10\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#11):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.11\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.11\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.11\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.11\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.11\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#12):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.12\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.12\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.12\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.12\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.12\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#13):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.13\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.13\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.13\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.13\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.13\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#14):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.14\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.14\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.14\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.14\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.14\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#15):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.15\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.15\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.15\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.15\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.15\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#16):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.16\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.16\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.16\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.16\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.16\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#17):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.17\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.17\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.17\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.17\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.17\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#18):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.18\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.18\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.18\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.18\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.18\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#19):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.19\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.19\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.19\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.19\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.19\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#20):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.20\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.20\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.20\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.20\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.20\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#21):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.21\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.21\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.21\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.21\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.21\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#22):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.22\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.22\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.22\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.22\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.22\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#23):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.23\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.23\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.23\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.23\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.23\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.inputObject.parameter.Out\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#24):
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Started\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Started.24\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.In\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.Out.24\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object)._Finished.24\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24._Finished\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).return.24\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.return\;
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0.ImageContrastModifier::<ChangeContrast>b__7_0(Object).inputObject.parameter.In.24\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.inputObject.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32) start
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).0 (#0):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).0._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).0.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).0.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).1 (#1):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).1._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).1.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).1.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).2 (#2):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).2._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).2.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).2.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).3 (#3):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).3._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).3.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).3.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).4 (#4):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).4._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).4.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).4.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).5 (#5):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).5._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).5.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).5.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).6 (#6):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).6._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).6.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).6.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).7 (#7):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).7._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).7.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).7.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).8 (#8):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).8._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).8.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).8.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).9 (#9):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).9._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).9.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).9.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).10 (#10):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).10._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).10.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).10.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).11 (#11):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).11._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).11.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).11.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).12 (#12):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).12._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).12.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).12.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).13 (#13):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).13._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).13.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).13.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).14 (#14):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).14._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).14.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).14.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).15 (#15):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).15._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).15.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).15.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).16 (#16):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).16._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).16.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).16.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).17 (#17):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).17._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).17.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).17.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).18 (#18):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).18._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).18.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).18.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).19 (#19):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).19._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).19.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).19.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).20 (#20):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).20._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).20.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).20.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).21 (#21):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).21._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).21.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).21.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).22 (#22):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).22._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).22.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).22.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).23 (#23):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).23._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).23.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).23.return\;
    -- Signal connections for Hast.Samples.SampleAssembly.ImageContrastModifier+PixelProcessingTaskOutput Hast.Samples.SampleAssembly.ImageContrastModifier::<ChangeContrast>b__7_0(System.Object).24 (#24):
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Started\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Started.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.pixel.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).pixel.parameter.Out.0\;
    \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.contrastValue.parameter.In\ <= \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).contrastValue.parameter.Out.0\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32)._Finished.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).24._Finished\;
    \ImageContrastModifier::<ChangeContrast>b__7_0(Object).24.ImageContrastModifier::ChangePixelValue(Byte,Int32).return.0\ <= \ImageContrastModifier::ChangePixelValue(Byte,Int32).24.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Hast.Samples.SampleAssembly.ImageContrastModifier::ChangePixelValue(System.Byte,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Started\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.0\;
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.indexObject.parameter.In\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.0\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.0\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0._Finished\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.0\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).0.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Started\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.1\;
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.indexObject.parameter.In\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.1\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.1\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1._Finished\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.1\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).1.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Started\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Started.2\;
    \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.indexObject.parameter.In\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).indexObject.parameter.Out.2\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object)._Finished.2\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2._Finished\;
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).return.2\ <= \MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(Object).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.MonteCarloPiEstimator+<>c__DisplayClass5_0::<EstimatePi>b__0(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32) start
    \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10().0
                case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\) then 
                            \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningIndex.0\ := 0;
                            \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= true;
                            \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\ <= \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\;
                            \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\ <= \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningIndex.0\ is 
                            when 0 => 
                                if (\NumberContainer::IncreaseNumber(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\ := AfterFinished;
                                    \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= true;
                                    \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= false;
                                    \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).return.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.return\;
                                    \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberBy10().0.runningState.0\ := WaitingForStarted;
                            \NumberContainer::IncreaseNumberBy10().0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&).0
                case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\) then 
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningIndex.0\ := 0;
                            \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= true;
                            \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\;
                            \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningIndex.0\ is 
                            when 0 => 
                                if (\NumberContainer::IncreaseNumber(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\ := AfterFinished;
                                    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= true;
                                    \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= false;
                                    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).return.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.return\;
                                    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.runningState.0\ := WaitingForStarted;
                            \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer).0
                case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\) then 
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningIndex.0\ := 0;
                            \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= true;
                            \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\;
                            \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningIndex.0\ is 
                            when 0 => 
                                if (\NumberContainer::IncreaseNumber(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\ := AfterFinished;
                                    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= true;
                                    \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= false;
                                    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).return.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.return\;
                                    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.runningState.0\ := WaitingForStarted;
                            \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\) then 
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningIndex.0\ := 0;
                            \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= true;
                            \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.Out.0\;
                            \NumberContainer::IncreaseNumber(UInt32).0.increaseBy.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).increaseBy.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\NumberContainer::IncreaseNumber(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= true;
                                    \NumberContainer::IncreaseNumber(UInt32).0._Started\ <= false;
                                    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).return.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.return\;
                                    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32).this.parameter.In.0\ <= \NumberContainer::IncreaseNumber(UInt32).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().NumberContainer::IncreaseNumber(UInt32).ObjectOrientedShowcase::Run(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumber(UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumber(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \MemoryContainer::.ctor(SimpleMemory).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Started.0\;
    \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory)._Finished.0\ <= \MemoryContainer::.ctor(SimpleMemory).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::.ctor(SimpleMemory).this.parameter.In.0\ <= \MemoryContainer::.ctor(SimpleMemory).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MemoryContainer::.ctor(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput() start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \MemoryContainer::GetInput().0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Started.0\;
    \MemoryContainer::GetInput().0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput()._Finished.0\ <= \MemoryContainer::GetInput().0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().return.0\ <= \MemoryContainer::GetInput().0.return\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.MemoryContainer::GetInput().this.parameter.In.0\ <= \MemoryContainer::GetInput().0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.MemoryContainer::GetInput() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainer::.ctor(UInt32).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Started.0\;
    \NumberContainer::.ctor(UInt32).0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.Out.0\;
    \NumberContainer::.ctor(UInt32).0.number.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).number.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32)._Finished.0\ <= \NumberContainer::.ctor(UInt32).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::.ctor(UInt32).this.parameter.In.0\ <= \NumberContainer::.ctor(UInt32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::.ctor(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainer::set_NumberPlusFive(UInt32).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Started.0\;
    \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.Out.0\;
    \NumberContainer::set_NumberPlusFive(UInt32).0.value.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).value.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32)._Finished.0\ <= \NumberContainer::set_NumberPlusFive(UInt32).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::set_NumberPlusFive(UInt32).this.parameter.In.0\ <= \NumberContainer::set_NumberPlusFive(UInt32).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::set_NumberPlusFive(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10() start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainer::IncreaseNumberBy10().0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Started.0\;
    \NumberContainer::IncreaseNumberBy10().0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10()._Finished.0\ <= \NumberContainer::IncreaseNumberBy10().0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().return.0\ <= \NumberContainer::IncreaseNumberBy10().0.return\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberBy10().this.parameter.In.0\ <= \NumberContainer::IncreaseNumberBy10().0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberBy10() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Started.0\;
    \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer)._Finished.0\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).return.0\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.return\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).numberContainer.parameter.In.0\ <= \NumberContainerExtensions::IncreaseNumberBy20(NumberContainer).0.numberContainer.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainerExtensions::IncreaseNumberBy20(Hast.Samples.SampleAssembly.NumberContainer) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Started.0\;
    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.Out.0\;
    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.Out.0\;
    \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&)._Finished.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).this.parameter.In.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.this.parameter.Out\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).increaseBy.parameter.In.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.increaseBy.parameter.Out\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).originalNumber.parameter.In.0\ <= \NumberContainer::IncreaseNumberByParameterTimes10(UInt32&,UInt32&).0.originalNumber.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.NumberContainer::IncreaseNumberByParameterTimes10(System.UInt32&,System.UInt32&) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive() start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \NumberContainer::get_NumberPlusFive().0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Started.0\;
    \NumberContainer::get_NumberPlusFive().0.this.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive()._Finished.0\ <= \NumberContainer::get_NumberPlusFive().0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().return.0\ <= \NumberContainer::get_NumberPlusFive().0.return\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.NumberContainer::get_NumberPlusFive().this.parameter.In.0\ <= \NumberContainer::get_NumberPlusFive().0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.NumberContainer::get_NumberPlusFive() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Started\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Started.0\;
    \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.In\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.Out.0\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[])._Finished.0\ <= \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0._Finished\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).return.0\ <= \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.return\;
    \ObjectOrientedShowcase::Run(SimpleMemory).0.ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).numberContainers.parameter.In.0\ <= \ObjectOrientedShowcase::SumNumberContainers(NumberContainer[]).0.numberContainers.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.ObjectOrientedShowcase::SumNumberContainers(Hast.Samples.SampleAssembly.NumberContainer[]) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Started\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.0\;
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.indexObject.parameter.In\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.0\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.0\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0._Finished\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.0\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).0.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Started\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.1\;
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.indexObject.parameter.In\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.1\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.1\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1._Finished\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.1\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).1.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Started\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Started.2\;
    \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.indexObject.parameter.In\ <= \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).indexObject.parameter.Out.2\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object)._Finished.2\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2._Finished\;
    \ParallelAlgorithm::Run(SimpleMemory).0.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).return.2\ <= \ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(Object).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.ParallelAlgorithm+<>c__DisplayClass3_0::<Run>b__0(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\ := WaitingForStarted;
                \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
                \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\) then 
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningIndex.0\ := 0;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ <= true;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= true;
                                    \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0.PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast::ExternalInvocationProxy()
                case \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\) then 
                            \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningIndex.0\ := 0;
                            \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ <= true;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningIndex.0\ is 
                            when 0 => 
                                if (\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\ := AfterFinished;
                                    \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= true;
                                    \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory).Hast::ExternalInvocationProxy().runningState.0\ := WaitingForStarted;
                            \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberSync(SimpleMemory)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberSync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Started\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.0\;
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.numberObject.parameter.In\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.0\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.0\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0._Finished\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.0\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Started\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.1\;
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.numberObject.parameter.In\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.1\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.1\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1._Finished\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.1\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Started\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Started.2\;
    \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.numberObject.parameter.In\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).numberObject.parameter.Out.2\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object)._Finished.2\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2._Finished\;
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).return.2\ <= \PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Hast.Samples.SampleAssembly.PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(System.Object) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Started\ <= \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.number.parameter.In\ <= \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0._Finished\;
    \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 (#1):
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 (#2):
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 (#3):
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Started\ <= \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.number.parameter.In\ <= \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0._Finished\;
    \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).0 (#1):
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).1 (#2):
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.return\;
    -- Signal connections for System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16).2 (#3):
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Started\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Started.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.number.parameter.In\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).number.parameter.Out.0\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16)._Finished.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3._Finished\;
    \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).return.0\ <= \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Hast.Samples.SampleAssembly.RecursiveAlgorithms::RecursivelyCalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,System.Int16) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation) start
    \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\) then 
                            \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningIndex.0\ := 0;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\ <= \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= true;
                                    \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::AddVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \SimdCalculator::AddVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\) then 
                            \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningIndex.0\ := 0;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\ <= \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= true;
                                    \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::SubtractVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \SimdCalculator::SubtractVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\) then 
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningIndex.0\ := 0;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\ <= \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= true;
                                    \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::MultiplyVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \SimdCalculator::MultiplyVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\) then 
                            \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningIndex.0\ := 0;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= true;
                            \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.operation.parameter.In\ <= \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).operation.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= true;
                                    \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0._Started\ <= false;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).SimdCalculator::DivideVectors(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \SimdCalculator::DivideVectors(SimpleMemory).0.SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::RunSimdOperation(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory,Hast.Samples.SampleAssembly.SimdOperation) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory)._Finished.0\ <= \GenomeMatcher::CalculateLongestCommonSubsequence(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.GenomeMatcher::CalculateLongestCommonSubsequence(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory)._Finished.0\ <= \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.HastlayerAcceleratedImageSharp::CreateMatrix(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().ImageContrastModifier::ChangeContrast(SimpleMemory)._Finished.0\ <= \ImageContrastModifier::ChangeContrast(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ImageContrastModifier::ChangeContrast(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Loopback::Run(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Loopback::Run(SimpleMemory)._Finished.0\ <= \Loopback::Run(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Loopback::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \MemoryTest::Run(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().MemoryTest::Run(SimpleMemory)._Finished.0\ <= \MemoryTest::Run(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MemoryTest::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().MonteCarloPiEstimator::EstimatePi(SimpleMemory)._Finished.0\ <= \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.MonteCarloPiEstimator::EstimatePi(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \ObjectOrientedShowcase::Run(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().ObjectOrientedShowcase::Run(SimpleMemory)._Finished.0\ <= \ObjectOrientedShowcase::Run(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ObjectOrientedShowcase::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \ParallelAlgorithm::Run(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().ParallelAlgorithm::Run(SimpleMemory)._Finished.0\ <= \ParallelAlgorithm::Run(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.ParallelAlgorithm::Run(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().PrimeCalculator::IsPrimeNumberAsync(SimpleMemory)._Finished.0\ <= \PrimeCalculator::IsPrimeNumberAsync(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Threading.Tasks.Task Hast.Samples.SampleAssembly.PrimeCalculator::IsPrimeNumberAsync(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().PrimeCalculator::ArePrimeNumbers(SimpleMemory)._Finished.0\ <= \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory)._Finished.0\ <= \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PrimeCalculator::ParallelizedArePrimeNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory)._Finished.0\ <= \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFibonacchiSeries(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().RecursiveAlgorithms::CalculateFactorial(SimpleMemory)._Finished.0\ <= \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.RecursiveAlgorithms::CalculateFactorial(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \SimdCalculator::AddVectors(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().SimdCalculator::AddVectors(SimpleMemory)._Finished.0\ <= \SimdCalculator::AddVectors(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::AddVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \SimdCalculator::SubtractVectors(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().SimdCalculator::SubtractVectors(SimpleMemory)._Finished.0\ <= \SimdCalculator::SubtractVectors(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::SubtractVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \SimdCalculator::MultiplyVectors(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().SimdCalculator::MultiplyVectors(SimpleMemory)._Finished.0\ <= \SimdCalculator::MultiplyVectors(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::MultiplyVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \SimdCalculator::DivideVectors(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().SimdCalculator::DivideVectors(SimpleMemory)._Finished.0\ <= \SimdCalculator::DivideVectors(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.SimdCalculator::DivideVectors(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.CellIndex\) when \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\ or \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.CellIndex\) when \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ or \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.CellIndex\) when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ or \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.CellIndex\) when \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\Loopback::Run(SimpleMemory).0.SimpleMemory.CellIndex\) when \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\MemoryContainer::GetInput().0.SimpleMemory.CellIndex\) when \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\ or \MemoryContainer::GetInput().0.SimpleMemory.WriteEnable\ else to_integer(\MemoryTest::Run(SimpleMemory).0.SimpleMemory.CellIndex\) when \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.CellIndex\) when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ or \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.CellIndex\) when \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.CellIndex\) when \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.CellIndex\) when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\) when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.CellIndex\) when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ else to_integer(\RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.CellIndex\) when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ else to_integer(\SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.CellIndex\) when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ or \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.DataOut\ when \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\ else \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.DataOut\ when \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ else \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.DataOut\ when \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ else \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.DataOut\ when \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ else \Loopback::Run(SimpleMemory).0.SimpleMemory.DataOut\ when \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else \MemoryContainer::GetInput().0.SimpleMemory.DataOut\ when \MemoryContainer::GetInput().0.SimpleMemory.WriteEnable\ else \MemoryTest::Run(SimpleMemory).0.SimpleMemory.DataOut\ when \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.DataOut\ when \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ else \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.DataOut\ when \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.DataOut\ when \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ else \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.DataOut\ when \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ else \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ when \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.DataOut\ when \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.DataOut\ when \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.DataOut\ when \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ else \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.DataOut\ when \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ else \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.DataOut\ when \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ else (others => '0');
    \ReadEnable\ <= \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.ReadEnable\ or \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Loopback::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \MemoryContainer::GetInput().0.SimpleMemory.ReadEnable\ or \MemoryTest::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.ReadEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.ReadEnable\ or \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.ReadEnable\ or \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \GenomeMatcher::Traceback(SimpleMemory).0.SimpleMemory.WriteEnable\ or \HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.SimpleMemory.WriteEnable\ or \ImageContrastModifier::ChangeContrast(SimpleMemory).0.SimpleMemory.WriteEnable\ or \Loopback::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ or \MemoryContainer::GetInput().0.SimpleMemory.WriteEnable\ or \MemoryTest::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ or \MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.SimpleMemory.WriteEnable\ or \ObjectOrientedShowcase::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ or \ParallelAlgorithm::Run(SimpleMemory).0.SimpleMemory.WriteEnable\ or \PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.SimpleMemory.WriteEnable\ or \PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ or \PrimeCalculator::ParallelizedArePrimeNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::CalculateFibonacchiSeries(SimpleMemory).0.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::CalculateFactorial(SimpleMemory).0.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFibonacchiSeries(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).0.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).1.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).2.SimpleMemory.WriteEnable\ or \RecursiveAlgorithms::RecursivelyCalculateFactorial(SimpleMemory,Int16).3.SimpleMemory.WriteEnable\ or \SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.SimpleMemory.WriteEnable\ or \GenomeMatcher::FillTable(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.3*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*HastlayerAcceleratedImageSharp::CreateMatrix(SimpleMemory).0.binaryOperationResult.6*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.6*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangeContrast(SimpleMemory).0.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).0.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).1.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).2.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).3.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).4.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).5.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).6.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).7.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).8.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).9.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).10.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).11.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).12.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).13.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).14.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).15.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).16.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).17.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).18.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).19.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).20.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).21.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).22.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).23.binaryOperationResult.7*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.1*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.4*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*ImageContrastModifier::ChangePixelValue(Byte,Int32).24.binaryOperationResult.7*}]
set_multicycle_path 27 -setup -to [get_cells -hierarchical {*MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 26 -hold -to [get_cells -hierarchical {*MonteCarloPiEstimator::EstimatePi(SimpleMemory).0.binaryOperationResult.0*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*PrimeCalculator::IsPrimeNumberSync(SimpleMemory).0.binaryOperationResult.2*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*PrimeCalculator::ArePrimeNumbers(SimpleMemory).0.binaryOperationResult.4*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).0.binaryOperationResult.2*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).1.binaryOperationResult.2*}]
set_multicycle_path 9 -setup -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2*}]
set_multicycle_path 8 -hold -to [get_cells -hierarchical {*PrimeCalculator::<ParallelizedArePrimeNumbers>b__9_0(Object).2.binaryOperationResult.2*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.70*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.71*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.72*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.73*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.74*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.75*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.76*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.77*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.78*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.79*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.80*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.81*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.82*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.83*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.84*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.85*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.86*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.87*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.88*}]
set_multicycle_path 10 -setup -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89*}]
set_multicycle_path 9 -hold -to [get_cells -hierarchical {*SimdCalculator::RunSimdOperation(SimpleMemory,SimdOperation).0.binaryOperationResult.89*}]